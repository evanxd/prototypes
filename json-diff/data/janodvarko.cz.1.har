{
  "log": {
    "version": "1.1",
    "creator": {
      "name": "Firebug",
      "version": "1.12"
    },
    "browser": {
      "name": "Firefox",
      "version": "21.0a1"
    },
    "pages": [
      {
        "startedDateTime": "2013-03-06T08:11:16.956+01:00",
        "id": "page_30168",
        "title": "JSON Diff @VERSION@",
        "pageTimings": {
          "onContentLoad": -1,
          "onLoad": -1
        }
      }
    ],
    "entries": [
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:16.956+01:00",
        "time": 111,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 291,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:48 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=7200"
            },
            {
              "name": "Expires",
              "value": "Wed, 06 Mar 2013 09:11:48 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=43"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Transfer-Encoding",
              "value": "chunked"
            },
            {
              "name": "Content-Type",
              "value": "text/html"
            }
          ],
          "content": {
            "mimeType": "text/html",
            "size": 1179,
            "text": "<!DOCTYPE html>\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\r\n<head>\r\n    <title>JSON Diff @VERSION@</title>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/>\r\n    <script src=\"scripts/jquery.js\"></script>\r\n    <script data-main=\"scripts/main\" src=\"scripts/requirejs/require.js\"></script>\r\n    <link rel=\"stylesheet\" href=\"css/main.css\" type=\"text/css\"/>\r\n    <script type=\"text/javascript\">\r\n    require({\r\n        paths: {\r\n            text: \"requirejs/text\",\r\n            i18n: \"requirejs/i18n\"\r\n        }\r\n    });\r\n    </script>\r\n</head>\r\n<body class=\"body\">\r\n\r\n<!-- Diff Tree -->\r\n<div id=\"content\"></div>\r\n\r\n<!-- Helper Trees -->\r\n<table cellspacing=\"10\" cellpadding=\"0\">\r\n<tr>\r\n    <td style=\"vertical-align: top\">\r\n        <h2>Original object:</h2>\r\n        <div id=\"oldObject\"></div>\r\n    </td>\r\n    <td width=\"50px\">&nbsp;</td>\r\n    <td style=\"vertical-align: top\">\r\n        <h2>Modified object:</h2>\r\n        <div id=\"newObject\"></div>\r\n    </td>\r\n    <td width=\"50px\">&nbsp;</td>\r\n    <td style=\"vertical-align: top\">\r\n        <h2>Computed Diff Tree:</h2>\r\n        <div id=\"differences\"></div>\r\n    </td>\r\n</tr>\r\n</table>\r\n\r\n</body>\r\n</html>\r\n"
          },
          "redirectURL": "",
          "headersSize": 249,
          "bodySize": 1179
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "connect": 0,
          "send": 0,
          "wait": 111,
          "receive": 0
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:17.161+01:00",
        "time": 1109,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/scripts/jquery.js",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 291,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:48 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:38 GMT"
            },
            {
              "name": "Etag",
              "value": "\"120845d-34f08-4d7330a013d80\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "216840"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=30"
            },
            {
              "name": "Expires",
              "value": "Wed, 06 Mar 2013 07:12:18 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=42"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "application/javascript"
            }
          ],
          "content": {
            "mimeType": "application/javascript",
            "size": 216840,
            "text": "/*!\n * jQuery JavaScript Library v1.5.1\n * http://jquery.com/\n *\n * Copyright 2011, John Resig\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n * Copyright 2011, The Dojo Foundation\n * Released under the MIT, BSD, and GPL Licenses.\n *\n * Date: Wed Feb 23 13:55:29 2011 -0500\n */\n(function( window, undefined ) {\n\n// Use the correct document accordingly with window argument (sandbox)\nvar document = window.document;\nvar jQuery = (function() {\n\n// Define a local copy of jQuery\nvar jQuery = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\treturn new jQuery.fn.init( selector, context, rootjQuery );\n\t},\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$,\n\n\t// A central reference to the root jQuery(document)\n\trootjQuery,\n\n\t// A simple way to check for HTML strings or ID strings\n\t// (both of which we optimize for)\n\tquickExpr = /^(?:[^<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]+)$)/,\n\n\t// Check if a string has a non-whitespace character in it\n\trnotwhite = /\\S/,\n\n\t// Used for trimming whitespace\n\ttrimLeft = /^\\s+/,\n\ttrimRight = /\\s+$/,\n\n\t// Check for digits\n\trdigit = /\\d/,\n\n\t// Match a standalone tag\n\trsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/,\n\n\t// JSON RegExp\n\trvalidchars = /^[\\],:{}\\s]*$/,\n\trvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\n\trvalidtokens = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\n\trvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g,\n\n\t// Useragent RegExp\n\trwebkit = /(webkit)[ \\/]([\\w.]+)/,\n\tropera = /(opera)(?:.*version)?[ \\/]([\\w.]+)/,\n\trmsie = /(msie) ([\\w.]+)/,\n\trmozilla = /(mozilla)(?:.*? rv:([\\w.]+))?/,\n\n\t// Keep a UserAgent string for use with jQuery.browser\n\tuserAgent = navigator.userAgent,\n\n\t// For matching the engine and version of the browser\n\tbrowserMatch,\n\n\t// Has the ready events already been bound?\n\treadyBound = false,\n\n\t// The deferred used on DOM ready\n\treadyList,\n\n\t// Promise methods\n\tpromiseMethods = \"then done fail isResolved isRejected promise\".split( \" \" ),\n\n\t// The ready event handler\n\tDOMContentLoaded,\n\n\t// Save a reference to some core methods\n\ttoString = Object.prototype.toString,\n\thasOwn = Object.prototype.hasOwnProperty,\n\tpush = Array.prototype.push,\n\tslice = Array.prototype.slice,\n\ttrim = String.prototype.trim,\n\tindexOf = Array.prototype.indexOf,\n\n\t// [[Class]] -> type pairs\n\tclass2type = {};\n\njQuery.fn = jQuery.prototype = {\n\tconstructor: jQuery,\n\tinit: function( selector, context, rootjQuery ) {\n\t\tvar match, elem, ret, doc;\n\n\t\t// Handle $(\"\"), $(null), or $(undefined)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle $(DOMElement)\n\t\tif ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\t\t}\n\n\t\t// The body element only exists once, optimize finding it\n\t\tif ( selector === \"body\" && !context && document.body ) {\n\t\t\tthis.context = document;\n\t\t\tthis[0] = document.body;\n\t\t\tthis.selector = \"body\";\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\t// Are we dealing with HTML string or an ID?\n\t\t\tmatch = quickExpr.exec( selector );\n\n\t\t\t// Verify a match, and that no context was specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\t\t\t\t\tdoc = (context ? context.ownerDocument || context : document);\n\n\t\t\t\t\t// If a single string is passed in and it's a single tag\n\t\t\t\t\t// just do a createElement and skip the rest\n\t\t\t\t\tret = rsingleTag.exec( selector );\n\n\t\t\t\t\tif ( ret ) {\n\t\t\t\t\t\tif ( jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\t\tselector = [ document.createElement( ret[1] ) ];\n\t\t\t\t\t\t\tjQuery.fn.attr.call( selector, context, true );\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tselector = [ doc.createElement( ret[1] ) ];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret = jQuery.buildFragment( [ match[1] ], [ doc ] );\n\t\t\t\t\t\tselector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.merge( this, selector );\n\n\t\t\t\t// HANDLE: $(\"#id\")\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE and Opera return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id !== match[2] ) {\n\t\t\t\t\t\t\treturn rootjQuery.find( selector );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise, we inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn (context || rootjQuery).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn rootjQuery.ready( selector );\n\t\t}\n\n\t\tif (selector.selector !== undefined) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t},\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The current version of jQuery being used\n\tjquery: \"1.5.1\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\t// The number of elements contained in the matched element set\n\tsize: function() {\n\t\treturn this.length;\n\t},\n\n\ttoArray: function() {\n\t\treturn slice.call( this, 0 );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num == null ?\n\n\t\t\t// Return a 'clean' array\n\t\t\tthis.toArray() :\n\n\t\t\t// Return just the object\n\t\t\t( num < 0 ? this[ this.length + num ] : this[ num ] );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems, name, selector ) {\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = this.constructor();\n\n\t\tif ( jQuery.isArray( elems ) ) {\n\t\t\tpush.apply( ret, elems );\n\n\t\t} else {\n\t\t\tjQuery.merge( ret, elems );\n\t\t}\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\tret.context = this.context;\n\n\t\tif ( name === \"find\" ) {\n\t\t\tret.selector = this.selector + (this.selector ? \" \" : \"\") + selector;\n\t\t} else if ( name ) {\n\t\t\tret.selector = this.selector + \".\" + name + \"(\" + selector + \")\";\n\t\t}\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\tready: function( fn ) {\n\t\t// Attach the listeners\n\t\tjQuery.bindReady();\n\n\t\t// Add the callback\n\t\treadyList.done( fn );\n\n\t\treturn this;\n\t},\n\n\teq: function( i ) {\n\t\treturn i === -1 ?\n\t\t\tthis.slice( i ) :\n\t\t\tthis.slice( i, +i + 1 );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ),\n\t\t\t\"slice\", slice.call(arguments).join(\",\") );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor(null);\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: [].sort,\n\tsplice: [].splice\n};\n\n// Give the init function the jQuery prototype for later instantiation\njQuery.fn.init.prototype = jQuery.fn;\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( length === i ) {\n\t\ttarget = this;\n\t\t--i;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend({\n\tnoConflict: function( deep ) {\n\t\twindow.$ = _$;\n\n\t\tif ( deep ) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\n\t\treturn jQuery;\n\t},\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\t\t// A third-party is pushing the ready event forwards\n\t\tif ( wait === true ) {\n\t\t\tjQuery.readyWait--;\n\t\t}\n\n\t\t// Make sure that the DOM is not already loaded\n\t\tif ( !jQuery.readyWait || (wait !== true && !jQuery.isReady) ) {\n\t\t\t// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\t\t\tif ( !document.body ) {\n\t\t\t\treturn setTimeout( jQuery.ready, 1 );\n\t\t\t}\n\n\t\t\t// Remember that the DOM is ready\n\t\t\tjQuery.isReady = true;\n\n\t\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If there are functions bound, to execute\n\t\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t\t// Trigger any bound ready events\n\t\t\tif ( jQuery.fn.trigger ) {\n\t\t\t\tjQuery( document ).trigger( \"ready\" ).unbind( \"ready\" );\n\t\t\t}\n\t\t}\n\t},\n\n\tbindReady: function() {\n\t\tif ( readyBound ) {\n\t\t\treturn;\n\t\t}\n\n\t\treadyBound = true;\n\n\t\t// Catch cases where $(document).ready() is called after the\n\t\t// browser event has already occurred.\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\treturn setTimeout( jQuery.ready, 1 );\n\t\t}\n\n\t\t// Mozilla, Opera and webkit nightlies currently support this event\n\t\tif ( document.addEventListener ) {\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", jQuery.ready, false );\n\n\t\t// If IE event model is used\n\t\t} else if ( document.attachEvent ) {\n\t\t\t// ensure firing before onload,\n\t\t\t// maybe late but safe also for iframes\n\t\t\tdocument.attachEvent(\"onreadystatechange\", DOMContentLoaded);\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.attachEvent( \"onload\", jQuery.ready );\n\n\t\t\t// If IE and not a frame\n\t\t\t// continually check to see if the document is ready\n\t\t\tvar toplevel = false;\n\n\t\t\ttry {\n\t\t\t\ttoplevel = window.frameElement == null;\n\t\t\t} catch(e) {}\n\n\t\t\tif ( document.documentElement.doScroll && toplevel ) {\n\t\t\t\tdoScrollCheck();\n\t\t\t}\n\t\t}\n\t},\n\n\t// See test/unit/core.js for details concerning isFunction.\n\t// Since version 1.3, DOM methods and functions like alert\n\t// aren't supported. They return false on IE (#2968).\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type(obj) === \"function\";\n\t},\n\n\tisArray: Array.isArray || function( obj ) {\n\t\treturn jQuery.type(obj) === \"array\";\n\t},\n\n\t// A crude way of determining if an object is a window\n\tisWindow: function( obj ) {\n\t\treturn obj && typeof obj === \"object\" && \"setInterval\" in obj;\n\t},\n\n\tisNaN: function( obj ) {\n\t\treturn obj == null || !rdigit.test( obj ) || isNaN( obj );\n\t},\n\n\ttype: function( obj ) {\n\t\treturn obj == null ?\n\t\t\tString( obj ) :\n\t\t\tclass2type[ toString.call(obj) ] || \"object\";\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\t// Must be an Object.\n\t\t// Because of IE, we also have to check the presence of the constructor property.\n\t\t// Make sure that DOM nodes and window objects don't pass through, as well\n\t\tif ( !obj || jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Not own constructor property must be Object\n\t\tif ( obj.constructor &&\n\t\t\t!hasOwn.call(obj, \"constructor\") &&\n\t\t\t!hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own.\n\n\t\tvar key;\n\t\tfor ( key in obj ) {}\n\n\t\treturn key === undefined || hasOwn.call( obj, key );\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tfor ( var name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\terror: function( msg ) {\n\t\tthrow msg;\n\t},\n\n\tparseJSON: function( data ) {\n\t\tif ( typeof data !== \"string\" || !data ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Make sure leading/trailing whitespace is removed (IE can't handle it)\n\t\tdata = jQuery.trim( data );\n\n\t\t// Make sure the incoming data is actual JSON\n\t\t// Logic borrowed from http://json.org/json2.js\n\t\tif ( rvalidchars.test(data.replace(rvalidescape, \"@\")\n\t\t\t.replace(rvalidtokens, \"]\")\n\t\t\t.replace(rvalidbraces, \"\")) ) {\n\n\t\t\t// Try to use the native JSON parser first\n\t\t\treturn window.JSON && window.JSON.parse ?\n\t\t\t\twindow.JSON.parse( data ) :\n\t\t\t\t(new Function(\"return \" + data))();\n\n\t\t} else {\n\t\t\tjQuery.error( \"Invalid JSON: \" + data );\n\t\t}\n\t},\n\n\t// Cross-browser xml parsing\n\t// (xml & tmp used internally)\n\tparseXML: function( data , xml , tmp ) {\n\n\t\tif ( window.DOMParser ) { // Standard\n\t\t\ttmp = new DOMParser();\n\t\t\txml = tmp.parseFromString( data , \"text/xml\" );\n\t\t} else { // IE\n\t\t\txml = new ActiveXObject( \"Microsoft.XMLDOM\" );\n\t\t\txml.async = \"false\";\n\t\t\txml.loadXML( data );\n\t\t}\n\n\t\ttmp = xml.documentElement;\n\n\t\tif ( ! tmp || ! tmp.nodeName || tmp.nodeName === \"parsererror\" ) {\n\t\t\tjQuery.error( \"Invalid XML: \" + data );\n\t\t}\n\n\t\treturn xml;\n\t},\n\n\tnoop: function() {},\n\n\t// Evalulates a script in a global context\n\tglobalEval: function( data ) {\n\t\tif ( data && rnotwhite.test(data) ) {\n\t\t\t// Inspired by code by Andrea Giammarchi\n\t\t\t// http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html\n\t\t\tvar head = document.head || document.getElementsByTagName( \"head\" )[0] || document.documentElement,\n\t\t\t\tscript = document.createElement( \"script\" );\n\n\t\t\tif ( jQuery.support.scriptEval() ) {\n\t\t\t\tscript.appendChild( document.createTextNode( data ) );\n\t\t\t} else {\n\t\t\t\tscript.text = data;\n\t\t\t}\n\n\t\t\t// Use insertBefore instead of appendChild to circumvent an IE6 bug.\n\t\t\t// This arises when a base node is used (#2709).\n\t\t\thead.insertBefore( script, head.firstChild );\n\t\t\thead.removeChild( script );\n\t\t}\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( object, callback, args ) {\n\t\tvar name, i = 0,\n\t\t\tlength = object.length,\n\t\t\tisObj = length === undefined || jQuery.isFunction(object);\n\n\t\tif ( args ) {\n\t\t\tif ( isObj ) {\n\t\t\t\tfor ( name in object ) {\n\t\t\t\t\tif ( callback.apply( object[ name ], args ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( ; i < length; ) {\n\t\t\t\t\tif ( callback.apply( object[ i++ ], args ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isObj ) {\n\t\t\t\tfor ( name in object ) {\n\t\t\t\t\tif ( callback.call( object[ name ], name, object[ name ] ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( var value = object[0];\n\t\t\t\t\ti < length && callback.call( value, i, value ) !== false; value = object[++i] ) {}\n\t\t\t}\n\t\t}\n\n\t\treturn object;\n\t},\n\n\t// Use native String.trim function wherever possible\n\ttrim: trim ?\n\t\tfunction( text ) {\n\t\t\treturn text == null ?\n\t\t\t\t\"\" :\n\t\t\t\ttrim.call( text );\n\t\t} :\n\n\t\t// Otherwise use our own trimming functionality\n\t\tfunction( text ) {\n\t\t\treturn text == null ?\n\t\t\t\t\"\" :\n\t\t\t\ttext.toString().replace( trimLeft, \"\" ).replace( trimRight, \"\" );\n\t\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( array, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( array != null ) {\n\t\t\t// The window, strings (and functions) also have 'length'\n\t\t\t// The extra typeof function check is to prevent crashes\n\t\t\t// in Safari 2 (See: #3039)\n\t\t\t// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930\n\t\t\tvar type = jQuery.type(array);\n\n\t\t\tif ( array.length == null || type === \"string\" || type === \"function\" || type === \"regexp\" || jQuery.isWindow( array ) ) {\n\t\t\t\tpush.call( ret, array );\n\t\t\t} else {\n\t\t\t\tjQuery.merge( ret, array );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, array ) {\n\t\tif ( array.indexOf ) {\n\t\t\treturn array.indexOf( elem );\n\t\t}\n\n\t\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\t\tif ( array[ i ] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar i = first.length,\n\t\t\tj = 0;\n\n\t\tif ( typeof second.length === \"number\" ) {\n\t\t\tfor ( var l = second.length; j < l; j++ ) {\n\t\t\t\tfirst[ i++ ] = second[ j ];\n\t\t\t}\n\n\t\t} else {\n\t\t\twhile ( second[j] !== undefined ) {\n\t\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t\t}\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, inv ) {\n\t\tvar ret = [], retVal;\n\t\tinv = !!inv;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( var i = 0, length = elems.length; i < length; i++ ) {\n\t\t\tretVal = !!callback( elems[ i ], i );\n\t\t\tif ( inv !== retVal ) {\n\t\t\t\tret.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar ret = [], value;\n\n\t\t// Go through the array, translating each of the items to their\n\t\t// new value (or values).\n\t\tfor ( var i = 0, length = elems.length; i < length; i++ ) {\n\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\tif ( value != null ) {\n\t\t\t\tret[ ret.length ] = value;\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn ret.concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\tproxy: function( fn, proxy, thisObject ) {\n\t\tif ( arguments.length === 2 ) {\n\t\t\tif ( typeof proxy === \"string\" ) {\n\t\t\t\tthisObject = fn;\n\t\t\t\tfn = thisObject[ proxy ];\n\t\t\t\tproxy = undefined;\n\n\t\t\t} else if ( proxy && !jQuery.isFunction( proxy ) ) {\n\t\t\t\tthisObject = proxy;\n\t\t\t\tproxy = undefined;\n\t\t\t}\n\t\t}\n\n\t\tif ( !proxy && fn ) {\n\t\t\tproxy = function() {\n\t\t\t\treturn fn.apply( thisObject || this, arguments );\n\t\t\t};\n\t\t}\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tif ( fn ) {\n\t\t\tproxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;\n\t\t}\n\n\t\t// So proxy can be declared as an argument\n\t\treturn proxy;\n\t},\n\n\t// Mutifunctional method to get and set values to a collection\n\t// The value/s can be optionally by executed if its a function\n\taccess: function( elems, key, value, exec, fn, pass ) {\n\t\tvar length = elems.length;\n\n\t\t// Setting many attributes\n\t\tif ( typeof key === \"object\" ) {\n\t\t\tfor ( var k in key ) {\n\t\t\t\tjQuery.access( elems, k, key[k], exec, fn, value );\n\t\t\t}\n\t\t\treturn elems;\n\t\t}\n\n\t\t// Setting one attribute\n\t\tif ( value !== undefined ) {\n\t\t\t// Optionally, function values get executed if exec is true\n\t\t\texec = !pass && exec && jQuery.isFunction(value);\n\n\t\t\tfor ( var i = 0; i < length; i++ ) {\n\t\t\t\tfn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );\n\t\t\t}\n\n\t\t\treturn elems;\n\t\t}\n\n\t\t// Getting an attribute\n\t\treturn length ? fn( elems[0], key ) : undefined;\n\t},\n\n\tnow: function() {\n\t\treturn (new Date()).getTime();\n\t},\n\n\t// Create a simple deferred (one callbacks list)\n\t_Deferred: function() {\n\t\tvar // callbacks list\n\t\t\tcallbacks = [],\n\t\t\t// stored [ context , args ]\n\t\t\tfired,\n\t\t\t// to avoid firing when already doing so\n\t\t\tfiring,\n\t\t\t// flag to know if the deferred has been cancelled\n\t\t\tcancelled,\n\t\t\t// the deferred itself\n\t\t\tdeferred  = {\n\n\t\t\t\t// done( f1, f2, ...)\n\t\t\t\tdone: function() {\n\t\t\t\t\tif ( !cancelled ) {\n\t\t\t\t\t\tvar args = arguments,\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\tlength,\n\t\t\t\t\t\t\telem,\n\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t_fired;\n\t\t\t\t\t\tif ( fired ) {\n\t\t\t\t\t\t\t_fired = fired;\n\t\t\t\t\t\t\tfired = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( i = 0, length = args.length; i < length; i++ ) {\n\t\t\t\t\t\t\telem = args[ i ];\n\t\t\t\t\t\t\ttype = jQuery.type( elem );\n\t\t\t\t\t\t\tif ( type === \"array\" ) {\n\t\t\t\t\t\t\t\tdeferred.done.apply( deferred, elem );\n\t\t\t\t\t\t\t} else if ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tcallbacks.push( elem );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( _fired ) {\n\t\t\t\t\t\t\tdeferred.resolveWith( _fired[ 0 ], _fired[ 1 ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// resolve with given context and args\n\t\t\t\tresolveWith: function( context, args ) {\n\t\t\t\t\tif ( !cancelled && !fired && !firing ) {\n\t\t\t\t\t\tfiring = 1;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twhile( callbacks[ 0 ] ) {\n\t\t\t\t\t\t\t\tcallbacks.shift().apply( context, args );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// We have to add a catch block for\n\t\t\t\t\t\t// IE prior to 8 or else the finally\n\t\t\t\t\t\t// block will never get executed\n\t\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\tfired = [ context, args ];\n\t\t\t\t\t\t\tfiring = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// resolve with this as context and given arguments\n\t\t\t\tresolve: function() {\n\t\t\t\t\tdeferred.resolveWith( jQuery.isFunction( this.promise ) ? this.promise() : this, arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Has this deferred been resolved?\n\t\t\t\tisResolved: function() {\n\t\t\t\t\treturn !!( firing || fired );\n\t\t\t\t},\n\n\t\t\t\t// Cancel\n\t\t\t\tcancel: function() {\n\t\t\t\t\tcancelled = 1;\n\t\t\t\t\tcallbacks = [];\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\treturn deferred;\n\t},\n\n\t// Full fledged deferred (two callbacks list)\n\tDeferred: function( func ) {\n\t\tvar deferred = jQuery._Deferred(),\n\t\t\tfailDeferred = jQuery._Deferred(),\n\t\t\tpromise;\n\t\t// Add errorDeferred methods, then and promise\n\t\tjQuery.extend( deferred, {\n\t\t\tthen: function( doneCallbacks, failCallbacks ) {\n\t\t\t\tdeferred.done( doneCallbacks ).fail( failCallbacks );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tfail: failDeferred.done,\n\t\t\trejectWith: failDeferred.resolveWith,\n\t\t\treject: failDeferred.resolve,\n\t\t\tisRejected: failDeferred.isResolved,\n\t\t\t// Get a promise for this deferred\n\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\tpromise: function( obj ) {\n\t\t\t\tif ( obj == null ) {\n\t\t\t\t\tif ( promise ) {\n\t\t\t\t\t\treturn promise;\n\t\t\t\t\t}\n\t\t\t\t\tpromise = obj = {};\n\t\t\t\t}\n\t\t\t\tvar i = promiseMethods.length;\n\t\t\t\twhile( i-- ) {\n\t\t\t\t\tobj[ promiseMethods[i] ] = deferred[ promiseMethods[i] ];\n\t\t\t\t}\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t} );\n\t\t// Make sure only one callback list will be used\n\t\tdeferred.done( failDeferred.cancel ).fail( deferred.cancel );\n\t\t// Unexpose cancel\n\t\tdelete deferred.cancel;\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( object ) {\n\t\tvar lastIndex = arguments.length,\n\t\t\tdeferred = lastIndex <= 1 && object && jQuery.isFunction( object.promise ) ?\n\t\t\t\tobject :\n\t\t\t\tjQuery.Deferred(),\n\t\t\tpromise = deferred.promise();\n\n\t\tif ( lastIndex > 1 ) {\n\t\t\tvar array = slice.call( arguments, 0 ),\n\t\t\t\tcount = lastIndex,\n\t\t\t\tiCallback = function( index ) {\n\t\t\t\t\treturn function( value ) {\n\t\t\t\t\t\tarray[ index ] = arguments.length > 1 ? slice.call( arguments, 0 ) : value;\n\t\t\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\t\t\tdeferred.resolveWith( promise, array );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\twhile( ( lastIndex-- ) ) {\n\t\t\t\tobject = array[ lastIndex ];\n\t\t\t\tif ( object && jQuery.isFunction( object.promise ) ) {\n\t\t\t\t\tobject.promise().then( iCallback(lastIndex), deferred.reject );\n\t\t\t\t} else {\n\t\t\t\t\t--count;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( !count ) {\n\t\t\t\tdeferred.resolveWith( promise, array );\n\t\t\t}\n\t\t} else if ( deferred !== object ) {\n\t\t\tdeferred.resolve( object );\n\t\t}\n\t\treturn promise;\n\t},\n\n\t// Use of jQuery.browser is frowned upon.\n\t// More details: http://docs.jquery.com/Utilities/jQuery.browser\n\tuaMatch: function( ua ) {\n\t\tua = ua.toLowerCase();\n\n\t\tvar match = rwebkit.exec( ua ) ||\n\t\t\tropera.exec( ua ) ||\n\t\t\trmsie.exec( ua ) ||\n\t\t\tua.indexOf(\"compatible\") < 0 && rmozilla.exec( ua ) ||\n\t\t\t[];\n\n\t\treturn { browser: match[1] || \"\", version: match[2] || \"0\" };\n\t},\n\n\tsub: function() {\n\t\tfunction jQuerySubclass( selector, context ) {\n\t\t\treturn new jQuerySubclass.fn.init( selector, context );\n\t\t}\n\t\tjQuery.extend( true, jQuerySubclass, this );\n\t\tjQuerySubclass.superclass = this;\n\t\tjQuerySubclass.fn = jQuerySubclass.prototype = this();\n\t\tjQuerySubclass.fn.constructor = jQuerySubclass;\n\t\tjQuerySubclass.subclass = this.subclass;\n\t\tjQuerySubclass.fn.init = function init( selector, context ) {\n\t\t\tif ( context && context instanceof jQuery && !(context instanceof jQuerySubclass) ) {\n\t\t\t\tcontext = jQuerySubclass(context);\n\t\t\t}\n\n\t\t\treturn jQuery.fn.init.call( this, selector, context, rootjQuerySubclass );\n\t\t};\n\t\tjQuerySubclass.fn.init.prototype = jQuerySubclass.fn;\n\t\tvar rootjQuerySubclass = jQuerySubclass(document);\n\t\treturn jQuerySubclass;\n\t},\n\n\tbrowser: {}\n});\n\n// Create readyList deferred\nreadyList = jQuery._Deferred();\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object\".split(\" \"), function(i, name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nbrowserMatch = jQuery.uaMatch( userAgent );\nif ( browserMatch.browser ) {\n\tjQuery.browser[ browserMatch.browser ] = true;\n\tjQuery.browser.version = browserMatch.version;\n}\n\n// Deprecated, use jQuery.browser.webkit instead\nif ( jQuery.browser.webkit ) {\n\tjQuery.browser.safari = true;\n}\n\nif ( indexOf ) {\n\tjQuery.inArray = function( elem, array ) {\n\t\treturn indexOf.call( array, elem );\n\t};\n}\n\n// IE doesn't match non-breaking spaces with \\s\nif ( rnotwhite.test( \"\\xA0\" ) ) {\n\ttrimLeft = /^[\\s\\xA0]+/;\n\ttrimRight = /[\\s\\xA0]+$/;\n}\n\n// All jQuery objects should point back to these\nrootjQuery = jQuery(document);\n\n// Cleanup functions for the document ready method\nif ( document.addEventListener ) {\n\tDOMContentLoaded = function() {\n\t\tdocument.removeEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n\t\tjQuery.ready();\n\t};\n\n} else if ( document.attachEvent ) {\n\tDOMContentLoaded = function() {\n\t\t// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\tdocument.detachEvent( \"onreadystatechange\", DOMContentLoaded );\n\t\t\tjQuery.ready();\n\t\t}\n\t};\n}\n\n// The DOM ready check for Internet Explorer\nfunction doScrollCheck() {\n\tif ( jQuery.isReady ) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\t// If IE is used, use the trick by Diego Perini\n\t\t// http://javascript.nwbox.com/IEContentLoaded/\n\t\tdocument.documentElement.doScroll(\"left\");\n\t} catch(e) {\n\t\tsetTimeout( doScrollCheck, 1 );\n\t\treturn;\n\t}\n\n\t// and execute any waiting functions\n\tjQuery.ready();\n}\n\n// Expose jQuery to the global object\nreturn jQuery;\n\n})();\n\n\n(function() {\n\n\tjQuery.support = {};\n\n\tvar div = document.createElement(\"div\");\n\n\tdiv.style.display = \"none\";\n\tdiv.innerHTML = \"   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>\";\n\n\tvar all = div.getElementsByTagName(\"*\"),\n\t\ta = div.getElementsByTagName(\"a\")[0],\n\t\tselect = document.createElement(\"select\"),\n\t\topt = select.appendChild( document.createElement(\"option\") ),\n\t\tinput = div.getElementsByTagName(\"input\")[0];\n\n\t// Can't get basic test support\n\tif ( !all || !all.length || !a ) {\n\t\treturn;\n\t}\n\n\tjQuery.support = {\n\t\t// IE strips leading whitespace when .innerHTML is used\n\t\tleadingWhitespace: div.firstChild.nodeType === 3,\n\n\t\t// Make sure that tbody elements aren't automatically inserted\n\t\t// IE will insert them into empty tables\n\t\ttbody: !div.getElementsByTagName(\"tbody\").length,\n\n\t\t// Make sure that link elements get serialized correctly by innerHTML\n\t\t// This requires a wrapper element in IE\n\t\thtmlSerialize: !!div.getElementsByTagName(\"link\").length,\n\n\t\t// Get the style information from getAttribute\n\t\t// (IE uses .cssText insted)\n\t\tstyle: /red/.test( a.getAttribute(\"style\") ),\n\n\t\t// Make sure that URLs aren't manipulated\n\t\t// (IE normalizes it by default)\n\t\threfNormalized: a.getAttribute(\"href\") === \"/a\",\n\n\t\t// Make sure that element opacity exists\n\t\t// (IE uses filter instead)\n\t\t// Use a regex to work around a WebKit issue. See #5145\n\t\topacity: /^0.55$/.test( a.style.opacity ),\n\n\t\t// Verify style float existence\n\t\t// (IE uses styleFloat instead of cssFloat)\n\t\tcssFloat: !!a.style.cssFloat,\n\n\t\t// Make sure that if no value is specified for a checkbox\n\t\t// that it defaults to \"on\".\n\t\t// (WebKit defaults to \"\" instead)\n\t\tcheckOn: input.value === \"on\",\n\n\t\t// Make sure that a selected-by-default option has a working selected property.\n\t\t// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n\t\toptSelected: opt.selected,\n\n\t\t// Will be defined later\n\t\tdeleteExpando: true,\n\t\toptDisabled: false,\n\t\tcheckClone: false,\n\t\tnoCloneEvent: true,\n\t\tnoCloneChecked: true,\n\t\tboxModel: null,\n\t\tinlineBlockNeedsLayout: false,\n\t\tshrinkWrapBlocks: false,\n\t\treliableHiddenOffsets: true\n\t};\n\n\tinput.checked = true;\n\tjQuery.support.noCloneChecked = input.cloneNode( true ).checked;\n\n\t// Make sure that the options inside disabled selects aren't marked as disabled\n\t// (WebKit marks them as diabled)\n\tselect.disabled = true;\n\tjQuery.support.optDisabled = !opt.disabled;\n\n\tvar _scriptEval = null;\n\tjQuery.support.scriptEval = function() {\n\t\tif ( _scriptEval === null ) {\n\t\t\tvar root = document.documentElement,\n\t\t\t\tscript = document.createElement(\"script\"),\n\t\t\t\tid = \"script\" + jQuery.now();\n\n\t\t\ttry {\n\t\t\t\tscript.appendChild( document.createTextNode( \"window.\" + id + \"=1;\" ) );\n\t\t\t} catch(e) {}\n\n\t\t\troot.insertBefore( script, root.firstChild );\n\n\t\t\t// Make sure that the execution of code works by injecting a script\n\t\t\t// tag with appendChild/createTextNode\n\t\t\t// (IE doesn't support this, fails, and uses .text instead)\n\t\t\tif ( window[ id ] ) {\n\t\t\t\t_scriptEval = true;\n\t\t\t\tdelete window[ id ];\n\t\t\t} else {\n\t\t\t\t_scriptEval = false;\n\t\t\t}\n\n\t\t\troot.removeChild( script );\n\t\t\t// release memory in IE\n\t\t\troot = script = id  = null;\n\t\t}\n\n\t\treturn _scriptEval;\n\t};\n\n\t// Test to see if it's possible to delete an expando from an element\n\t// Fails in Internet Explorer\n\ttry {\n\t\tdelete div.test;\n\n\t} catch(e) {\n\t\tjQuery.support.deleteExpando = false;\n\t}\n\n\tif ( !div.addEventListener && div.attachEvent && div.fireEvent ) {\n\t\tdiv.attachEvent(\"onclick\", function click() {\n\t\t\t// Cloning a node shouldn't copy over any\n\t\t\t// bound event handlers (IE does this)\n\t\t\tjQuery.support.noCloneEvent = false;\n\t\t\tdiv.detachEvent(\"onclick\", click);\n\t\t});\n\t\tdiv.cloneNode(true).fireEvent(\"onclick\");\n\t}\n\n\tdiv = document.createElement(\"div\");\n\tdiv.innerHTML = \"<input type='radio' name='radiotest' checked='checked'/>\";\n\n\tvar fragment = document.createDocumentFragment();\n\tfragment.appendChild( div.firstChild );\n\n\t// WebKit doesn't clone checked state correctly in fragments\n\tjQuery.support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;\n\n\t// Figure out if the W3C box model works as expected\n\t// document.body must exist before we can do this\n\tjQuery(function() {\n\t\tvar div = document.createElement(\"div\"),\n\t\t\tbody = document.getElementsByTagName(\"body\")[0];\n\n\t\t// Frameset documents with no body should not run this code\n\t\tif ( !body ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdiv.style.width = div.style.paddingLeft = \"1px\";\n\t\tbody.appendChild( div );\n\t\tjQuery.boxModel = jQuery.support.boxModel = div.offsetWidth === 2;\n\n\t\tif ( \"zoom\" in div.style ) {\n\t\t\t// Check if natively block-level elements act like inline-block\n\t\t\t// elements when setting their display to 'inline' and giving\n\t\t\t// them layout\n\t\t\t// (IE < 8 does this)\n\t\t\tdiv.style.display = \"inline\";\n\t\t\tdiv.style.zoom = 1;\n\t\t\tjQuery.support.inlineBlockNeedsLayout = div.offsetWidth === 2;\n\n\t\t\t// Check if elements with layout shrink-wrap their children\n\t\t\t// (IE 6 does this)\n\t\t\tdiv.style.display = \"\";\n\t\t\tdiv.innerHTML = \"<div style='width:4px;'></div>\";\n\t\t\tjQuery.support.shrinkWrapBlocks = div.offsetWidth !== 2;\n\t\t}\n\n\t\tdiv.innerHTML = \"<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>\";\n\t\tvar tds = div.getElementsByTagName(\"td\");\n\n\t\t// Check if table cells still have offsetWidth/Height when they are set\n\t\t// to display:none and there are still other visible table cells in a\n\t\t// table row; if so, offsetWidth/Height are not reliable for use when\n\t\t// determining if an element has been hidden directly using\n\t\t// display:none (it is still safe to use offsets if a parent element is\n\t\t// hidden; don safety goggles and see bug #4512 for more information).\n\t\t// (only IE 8 fails this test)\n\t\tjQuery.support.reliableHiddenOffsets = tds[0].offsetHeight === 0;\n\n\t\ttds[0].style.display = \"\";\n\t\ttds[1].style.display = \"none\";\n\n\t\t// Check if empty table cells still have offsetWidth/Height\n\t\t// (IE < 8 fail this test)\n\t\tjQuery.support.reliableHiddenOffsets = jQuery.support.reliableHiddenOffsets && tds[0].offsetHeight === 0;\n\t\tdiv.innerHTML = \"\";\n\n\t\tbody.removeChild( div ).style.display = \"none\";\n\t\tdiv = tds = null;\n\t});\n\n\t// Technique from Juriy Zaytsev\n\t// http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/\n\tvar eventSupported = function( eventName ) {\n\t\tvar el = document.createElement(\"div\");\n\t\teventName = \"on\" + eventName;\n\n\t\t// We only care about the case where non-standard event systems\n\t\t// are used, namely in IE. Short-circuiting here helps us to\n\t\t// avoid an eval call (in setAttribute) which can cause CSP\n\t\t// to go haywire. See: https://developer.mozilla.org/en/Security/CSP\n\t\tif ( !el.attachEvent ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tvar isSupported = (eventName in el);\n\t\tif ( !isSupported ) {\n\t\t\tel.setAttribute(eventName, \"return;\");\n\t\t\tisSupported = typeof el[eventName] === \"function\";\n\t\t}\n\t\tel = null;\n\n\t\treturn isSupported;\n\t};\n\n\tjQuery.support.submitBubbles = eventSupported(\"submit\");\n\tjQuery.support.changeBubbles = eventSupported(\"change\");\n\n\t// release memory in IE\n\tdiv = all = a = null;\n})();\n\n\n\nvar rbrace = /^(?:\\{.*\\}|\\[.*\\])$/;\n\njQuery.extend({\n\tcache: {},\n\n\t// Please use with caution\n\tuuid: 0,\n\n\t// Unique for each copy of jQuery on the page\n\t// Non-digits removed to match rinlinejQuery\n\texpando: \"jQuery\" + ( jQuery.fn.jquery + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// The following elements throw uncatchable exceptions if you\n\t// attempt to add expando properties to them.\n\tnoData: {\n\t\t\"embed\": true,\n\t\t// Ban all objects except for Flash (which handle expandos)\n\t\t\"object\": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\",\n\t\t\"applet\": true\n\t},\n\n\thasData: function( elem ) {\n\t\telem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];\n\n\t\treturn !!elem && !isEmptyDataObject( elem );\n\t},\n\n\tdata: function( elem, name, data, pvt /* Internal Use Only */ ) {\n\t\tif ( !jQuery.acceptData( elem ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar internalKey = jQuery.expando, getByName = typeof name === \"string\", thisCache,\n\n\t\t\t// We have to handle DOM nodes and JS objects differently because IE6-7\n\t\t\t// can't GC object references properly across the DOM-JS boundary\n\t\t\tisNode = elem.nodeType,\n\n\t\t\t// Only DOM nodes need the global jQuery cache; JS object data is\n\t\t\t// attached directly to the object so GC can occur automatically\n\t\t\tcache = isNode ? jQuery.cache : elem,\n\n\t\t\t// Only defining an ID for JS objects if its cache already exists allows\n\t\t\t// the code to shortcut on the same path as a DOM node with no cache\n\t\t\tid = isNode ? elem[ jQuery.expando ] : elem[ jQuery.expando ] && jQuery.expando;\n\n\t\t// Avoid doing any more work than we need to when trying to get data on an\n\t\t// object that has no data at all\n\t\tif ( (!id || (pvt && id && !cache[ id ][ internalKey ])) && getByName && data === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !id ) {\n\t\t\t// Only DOM nodes need a new unique ID for each element since their data\n\t\t\t// ends up in the global cache\n\t\t\tif ( isNode ) {\n\t\t\t\telem[ jQuery.expando ] = id = ++jQuery.uuid;\n\t\t\t} else {\n\t\t\t\tid = jQuery.expando;\n\t\t\t}\n\t\t}\n\n\t\tif ( !cache[ id ] ) {\n\t\t\tcache[ id ] = {};\n\n\t\t\t// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery\n\t\t\t// metadata on plain JS objects when the object is serialized using\n\t\t\t// JSON.stringify\n\t\t\tif ( !isNode ) {\n\t\t\t\tcache[ id ].toJSON = jQuery.noop;\n\t\t\t}\n\t\t}\n\n\t\t// An object can be passed to jQuery.data instead of a key/value pair; this gets\n\t\t// shallow copied over onto the existing cache\n\t\tif ( typeof name === \"object\" || typeof name === \"function\" ) {\n\t\t\tif ( pvt ) {\n\t\t\t\tcache[ id ][ internalKey ] = jQuery.extend(cache[ id ][ internalKey ], name);\n\t\t\t} else {\n\t\t\t\tcache[ id ] = jQuery.extend(cache[ id ], name);\n\t\t\t}\n\t\t}\n\n\t\tthisCache = cache[ id ];\n\n\t\t// Internal jQuery data is stored in a separate object inside the object's data\n\t\t// cache in order to avoid key collisions between internal data and user-defined\n\t\t// data\n\t\tif ( pvt ) {\n\t\t\tif ( !thisCache[ internalKey ] ) {\n\t\t\t\tthisCache[ internalKey ] = {};\n\t\t\t}\n\n\t\t\tthisCache = thisCache[ internalKey ];\n\t\t}\n\n\t\tif ( data !== undefined ) {\n\t\t\tthisCache[ name ] = data;\n\t\t}\n\n\t\t// TODO: This is a hack for 1.5 ONLY. It will be removed in 1.6. Users should\n\t\t// not attempt to inspect the internal events object using jQuery.data, as this\n\t\t// internal data object is undocumented and subject to change.\n\t\tif ( name === \"events\" && !thisCache[name] ) {\n\t\t\treturn thisCache[ internalKey ] && thisCache[ internalKey ].events;\n\t\t}\n\n\t\treturn getByName ? thisCache[ name ] : thisCache;\n\t},\n\n\tremoveData: function( elem, name, pvt /* Internal Use Only */ ) {\n\t\tif ( !jQuery.acceptData( elem ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar internalKey = jQuery.expando, isNode = elem.nodeType,\n\n\t\t\t// See jQuery.data for more information\n\t\t\tcache = isNode ? jQuery.cache : elem,\n\n\t\t\t// See jQuery.data for more information\n\t\t\tid = isNode ? elem[ jQuery.expando ] : jQuery.expando;\n\n\t\t// If there is already no cache entry for this object, there is no\n\t\t// purpose in continuing\n\t\tif ( !cache[ id ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( name ) {\n\t\t\tvar thisCache = pvt ? cache[ id ][ internalKey ] : cache[ id ];\n\n\t\t\tif ( thisCache ) {\n\t\t\t\tdelete thisCache[ name ];\n\n\t\t\t\t// If there is no data left in the cache, we want to continue\n\t\t\t\t// and let the cache object itself get destroyed\n\t\t\t\tif ( !isEmptyDataObject(thisCache) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// See jQuery.data for more information\n\t\tif ( pvt ) {\n\t\t\tdelete cache[ id ][ internalKey ];\n\n\t\t\t// Don't destroy the parent cache unless the internal data object\n\t\t\t// had been the only thing left in it\n\t\t\tif ( !isEmptyDataObject(cache[ id ]) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tvar internalCache = cache[ id ][ internalKey ];\n\n\t\t// Browsers that fail expando deletion also refuse to delete expandos on\n\t\t// the window, but it will allow it on all other JS objects; other browsers\n\t\t// don't care\n\t\tif ( jQuery.support.deleteExpando || cache != window ) {\n\t\t\tdelete cache[ id ];\n\t\t} else {\n\t\t\tcache[ id ] = null;\n\t\t}\n\n\t\t// We destroyed the entire user cache at once because it's faster than\n\t\t// iterating through each key, but we need to continue to persist internal\n\t\t// data if it existed\n\t\tif ( internalCache ) {\n\t\t\tcache[ id ] = {};\n\t\t\t// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery\n\t\t\t// metadata on plain JS objects when the object is serialized using\n\t\t\t// JSON.stringify\n\t\t\tif ( !isNode ) {\n\t\t\t\tcache[ id ].toJSON = jQuery.noop;\n\t\t\t}\n\n\t\t\tcache[ id ][ internalKey ] = internalCache;\n\n\t\t// Otherwise, we need to eliminate the expando on the node to avoid\n\t\t// false lookups in the cache for entries that no longer exist\n\t\t} else if ( isNode ) {\n\t\t\t// IE does not allow us to delete expando properties from nodes,\n\t\t\t// nor does it have a removeAttribute function on Document nodes;\n\t\t\t// we must handle all of these cases\n\t\t\tif ( jQuery.support.deleteExpando ) {\n\t\t\t\tdelete elem[ jQuery.expando ];\n\t\t\t} else if ( elem.removeAttribute ) {\n\t\t\t\telem.removeAttribute( jQuery.expando );\n\t\t\t} else {\n\t\t\t\telem[ jQuery.expando ] = null;\n\t\t\t}\n\t\t}\n\t},\n\n\t// For internal use only.\n\t_data: function( elem, name, data ) {\n\t\treturn jQuery.data( elem, name, data, true );\n\t},\n\n\t// A method for determining if a DOM node can handle the data expando\n\tacceptData: function( elem ) {\n\t\tif ( elem.nodeName ) {\n\t\t\tvar match = jQuery.noData[ elem.nodeName.toLowerCase() ];\n\n\t\t\tif ( match ) {\n\t\t\t\treturn !(match === true || elem.getAttribute(\"classid\") !== match);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n});\n\njQuery.fn.extend({\n\tdata: function( key, value ) {\n\t\tvar data = null;\n\n\t\tif ( typeof key === \"undefined\" ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = jQuery.data( this[0] );\n\n\t\t\t\tif ( this[0].nodeType === 1 ) {\n\t\t\t\t\tvar attr = this[0].attributes, name;\n\t\t\t\t\tfor ( var i = 0, l = attr.length; i < l; i++ ) {\n\t\t\t\t\t\tname = attr[i].name;\n\n\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\tname = name.substr( 5 );\n\t\t\t\t\t\t\tdataAttr( this[0], name, data[ name ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t} else if ( typeof key === \"object\" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.data( this, key );\n\t\t\t});\n\t\t}\n\n\t\tvar parts = key.split(\".\");\n\t\tparts[1] = parts[1] ? \".\" + parts[1] : \"\";\n\n\t\tif ( value === undefined ) {\n\t\t\tdata = this.triggerHandler(\"getData\" + parts[1] + \"!\", [parts[0]]);\n\n\t\t\t// Try to fetch any internally stored data first\n\t\t\tif ( data === undefined && this.length ) {\n\t\t\t\tdata = jQuery.data( this[0], key );\n\t\t\t\tdata = dataAttr( this[0], key, data );\n\t\t\t}\n\n\t\t\treturn data === undefined && parts[1] ?\n\t\t\t\tthis.data( parts[0] ) :\n\t\t\t\tdata;\n\n\t\t} else {\n\t\t\treturn this.each(function() {\n\t\t\t\tvar $this = jQuery( this ),\n\t\t\t\t\targs = [ parts[0], value ];\n\n\t\t\t\t$this.triggerHandler( \"setData\" + parts[1] + \"!\", args );\n\t\t\t\tjQuery.data( this, key, value );\n\t\t\t\t$this.triggerHandler( \"changeData\" + parts[1] + \"!\", args );\n\t\t\t});\n\t\t}\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeData( this, key );\n\t\t});\n\t}\n});\n\nfunction dataAttr( elem, key, data ) {\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tdata = elem.getAttribute( \"data-\" + key );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\tdata === \"false\" ? false :\n\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t!jQuery.isNaN( data ) ? parseFloat( data ) :\n\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tjQuery.data( elem, key, data );\n\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\n\treturn data;\n}\n\n// TODO: This is a hack for 1.5 ONLY to allow objects with a single toJSON\n// property to be considered empty objects; this property always exists in\n// order to make sure JSON.stringify does not expose internal metadata\nfunction isEmptyDataObject( obj ) {\n\tfor ( var name in obj ) {\n\t\tif ( name !== \"toJSON\" ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\n\n\njQuery.extend({\n\tqueue: function( elem, type, data ) {\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\ttype = (type || \"fx\") + \"queue\";\n\t\tvar q = jQuery._data( elem, type );\n\n\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\tif ( !data ) {\n\t\t\treturn q || [];\n\t\t}\n\n\t\tif ( !q || jQuery.isArray(data) ) {\n\t\t\tq = jQuery._data( elem, type, jQuery.makeArray(data) );\n\n\t\t} else {\n\t\t\tq.push( data );\n\t\t}\n\n\t\treturn q;\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tfn = queue.shift();\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift(\"inprogress\");\n\t\t\t}\n\n\t\t\tfn.call(elem, function() {\n\t\t\t\tjQuery.dequeue(elem, type);\n\t\t\t});\n\t\t}\n\n\t\tif ( !queue.length ) {\n\t\t\tjQuery.removeData( elem, type + \"queue\", true );\n\t\t}\n\t}\n});\n\njQuery.fn.extend({\n\tqueue: function( type, data ) {\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t}\n\n\t\tif ( data === undefined ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\t\treturn this.each(function( i ) {\n\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t},\n\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tdelay: function( time, type ) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n\t\ttype = type || \"fx\";\n\n\t\treturn this.queue( type, function() {\n\t\t\tvar elem = this;\n\t\t\tsetTimeout(function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t}, time );\n\t\t});\n\t},\n\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t}\n});\n\n\n\n\nvar rclass = /[\\n\\t\\r]/g,\n\trspaces = /\\s+/,\n\trreturn = /\\r/g,\n\trspecialurl = /^(?:href|src|style)$/,\n\trtype = /^(?:button|input)$/i,\n\trfocusable = /^(?:button|input|object|select|textarea)$/i,\n\trclickable = /^a(?:rea)?$/i,\n\trradiocheck = /^(?:radio|checkbox)$/i;\n\njQuery.props = {\n\t\"for\": \"htmlFor\",\n\t\"class\": \"className\",\n\treadonly: \"readOnly\",\n\tmaxlength: \"maxLength\",\n\tcellspacing: \"cellSpacing\",\n\trowspan: \"rowSpan\",\n\tcolspan: \"colSpan\",\n\ttabindex: \"tabIndex\",\n\tusemap: \"useMap\",\n\tframeborder: \"frameBorder\"\n};\n\njQuery.fn.extend({\n\tattr: function( name, value ) {\n\t\treturn jQuery.access( this, name, value, true, jQuery.attr );\n\t},\n\n\tremoveAttr: function( name, fn ) {\n\t\treturn this.each(function(){\n\t\t\tjQuery.attr( this, name, \"\" );\n\t\t\tif ( this.nodeType === 1 ) {\n\t\t\t\tthis.removeAttribute( name );\n\t\t\t}\n\t\t});\n\t},\n\n\taddClass: function( value ) {\n\t\tif ( jQuery.isFunction(value) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tvar self = jQuery(this);\n\t\t\t\tself.addClass( value.call(this, i, self.attr(\"class\")) );\n\t\t\t});\n\t\t}\n\n\t\tif ( value && typeof value === \"string\" ) {\n\t\t\tvar classNames = (value || \"\").split( rspaces );\n\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ) {\n\t\t\t\tvar elem = this[i];\n\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\tif ( !elem.className ) {\n\t\t\t\t\t\telem.className = value;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar className = \" \" + elem.className + \" \",\n\t\t\t\t\t\t\tsetClass = elem.className;\n\n\t\t\t\t\t\tfor ( var c = 0, cl = classNames.length; c < cl; c++ ) {\n\t\t\t\t\t\t\tif ( className.indexOf( \" \" + classNames[c] + \" \" ) < 0 ) {\n\t\t\t\t\t\t\t\tsetClass += \" \" + classNames[c];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telem.className = jQuery.trim( setClass );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tif ( jQuery.isFunction(value) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tvar self = jQuery(this);\n\t\t\t\tself.removeClass( value.call(this, i, self.attr(\"class\")) );\n\t\t\t});\n\t\t}\n\n\t\tif ( (value && typeof value === \"string\") || value === undefined ) {\n\t\t\tvar classNames = (value || \"\").split( rspaces );\n\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ) {\n\t\t\t\tvar elem = this[i];\n\n\t\t\t\tif ( elem.nodeType === 1 && elem.className ) {\n\t\t\t\t\tif ( value ) {\n\t\t\t\t\t\tvar className = (\" \" + elem.className + \" \").replace(rclass, \" \");\n\t\t\t\t\t\tfor ( var c = 0, cl = classNames.length; c < cl; c++ ) {\n\t\t\t\t\t\t\tclassName = className.replace(\" \" + classNames[c] + \" \", \" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telem.className = jQuery.trim( className );\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\telem.className = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisBool = typeof stateVal === \"boolean\";\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tvar self = jQuery(this);\n\t\t\t\tself.toggleClass( value.call(this, i, self.attr(\"class\"), stateVal), stateVal );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( type === \"string\" ) {\n\t\t\t\t// toggle individual class names\n\t\t\t\tvar className,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\tstate = stateVal,\n\t\t\t\t\tclassNames = value.split( rspaces );\n\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t// check each className given, space seperated list\n\t\t\t\t\tstate = isBool ? state : !self.hasClass( className );\n\t\t\t\t\tself[ state ? \"addClass\" : \"removeClass\" ]( className );\n\t\t\t\t}\n\n\t\t\t} else if ( type === \"undefined\" || type === \"boolean\" ) {\n\t\t\t\tif ( this.className ) {\n\t\t\t\t\t// store className if set\n\t\t\t\t\tjQuery._data( this, \"__className__\", this.className );\n\t\t\t\t}\n\n\t\t\t\t// toggle whole className\n\t\t\t\tthis.className = this.className || value === false ? \"\" : jQuery._data( this, \"__className__\" ) || \"\";\n\t\t\t}\n\t\t});\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className = \" \" + selector + \" \";\n\t\tfor ( var i = 0, l = this.length; i < l; i++ ) {\n\t\t\tif ( (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) > -1 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\tval: function( value ) {\n\t\tif ( !arguments.length ) {\n\t\t\tvar elem = this[0];\n\n\t\t\tif ( elem ) {\n\t\t\t\tif ( jQuery.nodeName( elem, \"option\" ) ) {\n\t\t\t\t\t// attributes.value is undefined in Blackberry 4.7 but\n\t\t\t\t\t// uses .value. See #6932\n\t\t\t\t\tvar val = elem.attributes.value;\n\t\t\t\t\treturn !val || val.specified ? elem.value : elem.text;\n\t\t\t\t}\n\n\t\t\t\t// We need to handle select boxes special\n\t\t\t\tif ( jQuery.nodeName( elem, \"select\" ) ) {\n\t\t\t\t\tvar index = elem.selectedIndex,\n\t\t\t\t\t\tvalues = [],\n\t\t\t\t\t\toptions = elem.options,\n\t\t\t\t\t\tone = elem.type === \"select-one\";\n\n\t\t\t\t\t// Nothing was selected\n\t\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Loop through all the selected options\n\t\t\t\t\tfor ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) {\n\t\t\t\t\t\tvar option = options[ i ];\n\n\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\tif ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null) &&\n\t\t\t\t\t\t\t\t(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" )) ) {\n\n\t\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\t\tvalue = jQuery(option).val();\n\n\t\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fixes Bug #2551 -- select.val() broken in IE after form.reset()\n\t\t\t\t\tif ( one && !values.length && options.length ) {\n\t\t\t\t\t\treturn jQuery( options[ index ] ).val();\n\t\t\t\t\t}\n\n\t\t\t\t\treturn values;\n\t\t\t\t}\n\n\t\t\t\t// Handle the case where in Webkit \"\" is returned instead of \"on\" if a value isn't specified\n\t\t\t\tif ( rradiocheck.test( elem.type ) && !jQuery.support.checkOn ) {\n\t\t\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t\t\t}\n\n\t\t\t\t// Everything else, we just grab the value\n\t\t\t\treturn (elem.value || \"\").replace(rreturn, \"\");\n\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\tvar isFunction = jQuery.isFunction(value);\n\n\t\treturn this.each(function(i) {\n\t\t\tvar self = jQuery(this), val = value;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call(this, i, self.val());\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\t\t\t} else if ( jQuery.isArray(val) ) {\n\t\t\t\tval = jQuery.map(val, function (value) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( jQuery.isArray(val) && rradiocheck.test( this.type ) ) {\n\t\t\t\tthis.checked = jQuery.inArray( self.val(), val ) >= 0;\n\n\t\t\t} else if ( jQuery.nodeName( this, \"select\" ) ) {\n\t\t\t\tvar values = jQuery.makeArray(val);\n\n\t\t\t\tjQuery( \"option\", this ).each(function() {\n\t\t\t\t\tthis.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;\n\t\t\t\t});\n\n\t\t\t\tif ( !values.length ) {\n\t\t\t\t\tthis.selectedIndex = -1;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tattrFn: {\n\t\tval: true,\n\t\tcss: true,\n\t\thtml: true,\n\t\ttext: true,\n\t\tdata: true,\n\t\twidth: true,\n\t\theight: true,\n\t\toffset: true\n\t},\n\n\tattr: function( elem, name, value, pass ) {\n\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || elem.nodeType === 2 ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif ( pass && name in jQuery.attrFn ) {\n\t\t\treturn jQuery(elem)[name](value);\n\t\t}\n\n\t\tvar notxml = elem.nodeType !== 1 || !jQuery.isXMLDoc( elem ),\n\t\t\t// Whether we are setting (or getting)\n\t\t\tset = value !== undefined;\n\n\t\t// Try to normalize/fix the name\n\t\tname = notxml && jQuery.props[ name ] || name;\n\n\t\t// Only do all the following if this is a node (faster for style)\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\t// These attributes require special treatment\n\t\t\tvar special = rspecialurl.test( name );\n\n\t\t\t// Safari mis-reports the default selected property of an option\n\t\t\t// Accessing the parent's selectedIndex property fixes it\n\t\t\tif ( name === \"selected\" && !jQuery.support.optSelected ) {\n\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.selectedIndex;\n\n\t\t\t\t\t// Make sure that it also works with optgroups, see #5701\n\t\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If applicable, access the attribute via the DOM 0 way\n\t\t\t// 'in' checks fail in Blackberry 4.7 #6931\n\t\t\tif ( (name in elem || elem[ name ] !== undefined) && notxml && !special ) {\n\t\t\t\tif ( set ) {\n\t\t\t\t\t// We can't allow the type property to be changed (since it causes problems in IE)\n\t\t\t\t\tif ( name === \"type\" && rtype.test( elem.nodeName ) && elem.parentNode ) {\n\t\t\t\t\t\tjQuery.error( \"type property can't be changed\" );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( value === null ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\telem.removeAttribute( name );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\telem[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// browsers index elements by id/name on forms, give priority to attributes.\n\t\t\t\tif ( jQuery.nodeName( elem, \"form\" ) && elem.getAttributeNode(name) ) {\n\t\t\t\t\treturn elem.getAttributeNode( name ).nodeValue;\n\t\t\t\t}\n\n\t\t\t\t// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n\t\t\t\t// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\tif ( name === \"tabIndex\" ) {\n\t\t\t\t\tvar attributeNode = elem.getAttributeNode( \"tabIndex\" );\n\n\t\t\t\t\treturn attributeNode && attributeNode.specified ?\n\t\t\t\t\t\tattributeNode.value :\n\t\t\t\t\t\trfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?\n\t\t\t\t\t\t\t0 :\n\t\t\t\t\t\t\tundefined;\n\t\t\t\t}\n\n\t\t\t\treturn elem[ name ];\n\t\t\t}\n\n\t\t\tif ( !jQuery.support.style && notxml && name === \"style\" ) {\n\t\t\t\tif ( set ) {\n\t\t\t\t\telem.style.cssText = \"\" + value;\n\t\t\t\t}\n\n\t\t\t\treturn elem.style.cssText;\n\t\t\t}\n\n\t\t\tif ( set ) {\n\t\t\t\t// convert the value to a string (all browsers do this but IE) see #1070\n\t\t\t\telem.setAttribute( name, \"\" + value );\n\t\t\t}\n\n\t\t\t// Ensure that missing attributes return undefined\n\t\t\t// Blackberry 4.7 returns \"\" from getAttribute #6938\n\t\t\tif ( !elem.attributes[ name ] && (elem.hasAttribute && !elem.hasAttribute( name )) ) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tvar attr = !jQuery.support.hrefNormalized && notxml && special ?\n\t\t\t\t\t// Some attributes require a special call on IE\n\t\t\t\t\telem.getAttribute( name, 2 ) :\n\t\t\t\t\telem.getAttribute( name );\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn attr === null ? undefined : attr;\n\t\t}\n\t\t// Handle everything which isn't a DOM element node\n\t\tif ( set ) {\n\t\t\telem[ name ] = value;\n\t\t}\n\t\treturn elem[ name ];\n\t}\n});\n\n\n\n\nvar rnamespaces = /\\.(.*)$/,\n\trformElems = /^(?:textarea|input|select)$/i,\n\trperiod = /\\./g,\n\trspace = / /g,\n\trescape = /[^\\w\\s.|`]/g,\n\tfcleanup = function( nm ) {\n\t\treturn nm.replace(rescape, \"\\\\$&\");\n\t};\n\n/*\n * A number of helper functions used for managing events.\n * Many of the ideas behind this code originated from\n * Dean Edwards' addEvent library.\n */\njQuery.event = {\n\n\t// Bind an event to an element\n\t// Original by Dean Edwards\n\tadd: function( elem, types, handler, data ) {\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// TODO :: Use a try/catch until it's safe to pull this out (likely 1.6)\n\t\t// Minor release fix for bug #8018\n\t\ttry {\n\t\t\t// For whatever reason, IE has trouble passing the window object\n\t\t\t// around, causing it to be cloned in the process\n\t\t\tif ( jQuery.isWindow( elem ) && ( elem !== window && !elem.frameElement ) ) {\n\t\t\t\telem = window;\n\t\t\t}\n\t\t}\n\t\tcatch ( e ) {}\n\n\t\tif ( handler === false ) {\n\t\t\thandler = returnFalse;\n\t\t} else if ( !handler ) {\n\t\t\t// Fixes bug #7229. Fix recommended by jdalton\n\t\t\treturn;\n\t\t}\n\n\t\tvar handleObjIn, handleObj;\n\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t}\n\n\t\t// Make sure that the function being executed has a unique ID\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure\n\t\tvar elemData = jQuery._data( elem );\n\n\t\t// If no elemData is found then we must be trying to bind to one of the\n\t\t// banned noData elements\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar events = elemData.events,\n\t\t\teventHandle = elemData.handle;\n\n\t\tif ( !events ) {\n\t\t\telemData.events = events = {};\n\t\t}\n\n\t\tif ( !eventHandle ) {\n\t\t\telemData.handle = eventHandle = function() {\n\t\t\t\t// Handle the second event of a trigger and when\n\t\t\t\t// an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && !jQuery.event.triggered ?\n\t\t\t\t\tjQuery.event.handle.apply( eventHandle.elem, arguments ) :\n\t\t\t\t\tundefined;\n\t\t\t};\n\t\t}\n\n\t\t// Add elem as a property of the handle function\n\t\t// This is to prevent a memory leak with non-native events in IE.\n\t\teventHandle.elem = elem;\n\n\t\t// Handle multiple events separated by a space\n\t\t// jQuery(...).bind(\"mouseover mouseout\", fn);\n\t\ttypes = types.split(\" \");\n\n\t\tvar type, i = 0, namespaces;\n\n\t\twhile ( (type = types[ i++ ]) ) {\n\t\t\thandleObj = handleObjIn ?\n\t\t\t\tjQuery.extend({}, handleObjIn) :\n\t\t\t\t{ handler: handler, data: data };\n\n\t\t\t// Namespaced event handlers\n\t\t\tif ( type.indexOf(\".\") > -1 ) {\n\t\t\t\tnamespaces = type.split(\".\");\n\t\t\t\ttype = namespaces.shift();\n\t\t\t\thandleObj.namespace = namespaces.slice(0).sort().join(\".\");\n\n\t\t\t} else {\n\t\t\t\tnamespaces = [];\n\t\t\t\thandleObj.namespace = \"\";\n\t\t\t}\n\n\t\t\thandleObj.type = type;\n\t\t\tif ( !handleObj.guid ) {\n\t\t\t\thandleObj.guid = handler.guid;\n\t\t\t}\n\n\t\t\t// Get the current list of functions bound to this event\n\t\t\tvar handlers = events[ type ],\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// Init the event handler queue\n\t\t\tif ( !handlers ) {\n\t\t\t\thandlers = events[ type ] = [];\n\n\t\t\t\t// Check for a special event handler\n\t\t\t\t// Only use addEventListener/attachEvent if the special\n\t\t\t\t// events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\t// Bind the global event handler to the element\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\n\t\t\t\t\t} else if ( elem.attachEvent ) {\n\t\t\t\t\t\telem.attachEvent( \"on\" + type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the function to the element's handler list\n\t\t\thandlers.push( handleObj );\n\n\t\t\t// Keep track of which events have been used, for global triggering\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t\t// Nullify elem to prevent memory leaks in IE\n\t\telem = null;\n\t},\n\n\tglobal: {},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, pos ) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( handler === false ) {\n\t\t\thandler = returnFalse;\n\t\t}\n\n\t\tvar ret, type, fn, j, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType,\n\t\t\telemData = jQuery.hasData( elem ) && jQuery._data( elem ),\n\t\t\tevents = elemData && elemData.events;\n\n\t\tif ( !elemData || !events ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// types is actually an event object here\n\t\tif ( types && types.type ) {\n\t\t\thandler = types.handler;\n\t\t\ttypes = types.type;\n\t\t}\n\n\t\t// Unbind all events for the element\n\t\tif ( !types || typeof types === \"string\" && types.charAt(0) === \".\" ) {\n\t\t\ttypes = types || \"\";\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tjQuery.event.remove( elem, type + types );\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\t// jQuery(...).unbind(\"mouseover mouseout\", fn);\n\t\ttypes = types.split(\" \");\n\n\t\twhile ( (type = types[ i++ ]) ) {\n\t\t\torigType = type;\n\t\t\thandleObj = null;\n\t\t\tall = type.indexOf(\".\") < 0;\n\t\t\tnamespaces = [];\n\n\t\t\tif ( !all ) {\n\t\t\t\t// Namespaced event handlers\n\t\t\t\tnamespaces = type.split(\".\");\n\t\t\t\ttype = namespaces.shift();\n\n\t\t\t\tnamespace = new RegExp(\"(^|\\\\.)\" +\n\t\t\t\t\tjQuery.map( namespaces.slice(0).sort(), fcleanup ).join(\"\\\\.(?:.*\\\\.)?\") + \"(\\\\.|$)\");\n\t\t\t}\n\n\t\t\teventType = events[ type ];\n\n\t\t\tif ( !eventType ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( !handler ) {\n\t\t\t\tfor ( j = 0; j < eventType.length; j++ ) {\n\t\t\t\t\thandleObj = eventType[ j ];\n\n\t\t\t\t\tif ( all || namespace.test( handleObj.namespace ) ) {\n\t\t\t\t\t\tjQuery.event.remove( elem, origType, handleObj.handler, j );\n\t\t\t\t\t\teventType.splice( j--, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\tfor ( j = pos || 0; j < eventType.length; j++ ) {\n\t\t\t\thandleObj = eventType[ j ];\n\n\t\t\t\tif ( handler.guid === handleObj.guid ) {\n\t\t\t\t\t// remove the given handler for the given type\n\t\t\t\t\tif ( all || namespace.test( handleObj.namespace ) ) {\n\t\t\t\t\t\tif ( pos == null ) {\n\t\t\t\t\t\t\teventType.splice( j--, 1 );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( pos != null ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove generic event handler if no more handlers exist\n\t\t\tif ( eventType.length === 0 || pos != null && eventType.length === 1 ) {\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tret = null;\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tvar handle = elemData.handle;\n\t\t\tif ( handle ) {\n\t\t\t\thandle.elem = null;\n\t\t\t}\n\n\t\t\tdelete elemData.events;\n\t\t\tdelete elemData.handle;\n\n\t\t\tif ( jQuery.isEmptyObject( elemData ) ) {\n\t\t\t\tjQuery.removeData( elem, undefined, true );\n\t\t\t}\n\t\t}\n\t},\n\n\t// bubbling is internal\n\ttrigger: function( event, data, elem /*, bubbling */ ) {\n\t\t// Event object or event type\n\t\tvar type = event.type || event,\n\t\t\tbubbling = arguments[3];\n\n\t\tif ( !bubbling ) {\n\t\t\tevent = typeof event === \"object\" ?\n\t\t\t\t// jQuery.Event object\n\t\t\t\tevent[ jQuery.expando ] ? event :\n\t\t\t\t// Object literal\n\t\t\t\tjQuery.extend( jQuery.Event(type), event ) :\n\t\t\t\t// Just the event type (string)\n\t\t\t\tjQuery.Event(type);\n\n\t\t\tif ( type.indexOf(\"!\") >= 0 ) {\n\t\t\t\tevent.type = type = type.slice(0, -1);\n\t\t\t\tevent.exclusive = true;\n\t\t\t}\n\n\t\t\t// Handle a global trigger\n\t\t\tif ( !elem ) {\n\t\t\t\t// Don't bubble custom events when global (to avoid too much overhead)\n\t\t\t\tevent.stopPropagation();\n\n\t\t\t\t// Only trigger if we've ever bound an event for it\n\t\t\t\tif ( jQuery.event.global[ type ] ) {\n\t\t\t\t\t// XXX This code smells terrible. event.js should not be directly\n\t\t\t\t\t// inspecting the data cache\n\t\t\t\t\tjQuery.each( jQuery.cache, function() {\n\t\t\t\t\t\t// internalKey variable is just used to make it easier to find\n\t\t\t\t\t\t// and potentially change this stuff later; currently it just\n\t\t\t\t\t\t// points to jQuery.expando\n\t\t\t\t\t\tvar internalKey = jQuery.expando,\n\t\t\t\t\t\t\tinternalCache = this[ internalKey ];\n\t\t\t\t\t\tif ( internalCache && internalCache.events && internalCache.events[ type ] ) {\n\t\t\t\t\t\t\tjQuery.event.trigger( event, data, internalCache.handle.elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle triggering a single element\n\n\t\t\t// don't do events on text and comment nodes\n\t\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\t// Clean up in case it is reused\n\t\t\tevent.result = undefined;\n\t\t\tevent.target = elem;\n\n\t\t\t// Clone the incoming data, if any\n\t\t\tdata = jQuery.makeArray( data );\n\t\t\tdata.unshift( event );\n\t\t}\n\n\t\tevent.currentTarget = elem;\n\n\t\t// Trigger the event, it is assumed that \"handle\" is a function\n\t\tvar handle = jQuery._data( elem, \"handle\" );\n\n\t\tif ( handle ) {\n\t\t\thandle.apply( elem, data );\n\t\t}\n\n\t\tvar parent = elem.parentNode || elem.ownerDocument;\n\n\t\t// Trigger an inline bound script\n\t\ttry {\n\t\t\tif ( !(elem && elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) ) {\n\t\t\t\tif ( elem[ \"on\" + type ] && elem[ \"on\" + type ].apply( elem, data ) === false ) {\n\t\t\t\t\tevent.result = false;\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\n\t\t// prevent IE from throwing an error for some elements with some event types, see #3533\n\t\t} catch (inlineError) {}\n\n\t\tif ( !event.isPropagationStopped() && parent ) {\n\t\t\tjQuery.event.trigger( event, data, parent, true );\n\n\t\t} else if ( !event.isDefaultPrevented() ) {\n\t\t\tvar old,\n\t\t\t\ttarget = event.target,\n\t\t\t\ttargetType = type.replace( rnamespaces, \"\" ),\n\t\t\t\tisClick = jQuery.nodeName( target, \"a\" ) && targetType === \"click\",\n\t\t\t\tspecial = jQuery.event.special[ targetType ] || {};\n\n\t\t\tif ( (!special._default || special._default.call( elem, event ) === false) &&\n\t\t\t\t!isClick && !(target && target.nodeName && jQuery.noData[target.nodeName.toLowerCase()]) ) {\n\n\t\t\t\ttry {\n\t\t\t\t\tif ( target[ targetType ] ) {\n\t\t\t\t\t\t// Make sure that we don't accidentally re-trigger the onFOO events\n\t\t\t\t\t\told = target[ \"on\" + targetType ];\n\n\t\t\t\t\t\tif ( old ) {\n\t\t\t\t\t\t\ttarget[ \"on\" + targetType ] = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tjQuery.event.triggered = true;\n\t\t\t\t\t\ttarget[ targetType ]();\n\t\t\t\t\t}\n\n\t\t\t\t// prevent IE from throwing an error for some elements with some event types, see #3533\n\t\t\t\t} catch (triggerError) {}\n\n\t\t\t\tif ( old ) {\n\t\t\t\t\ttarget[ \"on\" + targetType ] = old;\n\t\t\t\t}\n\n\t\t\t\tjQuery.event.triggered = false;\n\t\t\t}\n\t\t}\n\t},\n\n\thandle: function( event ) {\n\t\tvar all, handlers, namespaces, namespace_re, events,\n\t\t\tnamespace_sort = [],\n\t\t\targs = jQuery.makeArray( arguments );\n\n\t\tevent = args[0] = jQuery.event.fix( event || window.event );\n\t\tevent.currentTarget = this;\n\n\t\t// Namespaced event handlers\n\t\tall = event.type.indexOf(\".\") < 0 && !event.exclusive;\n\n\t\tif ( !all ) {\n\t\t\tnamespaces = event.type.split(\".\");\n\t\t\tevent.type = namespaces.shift();\n\t\t\tnamespace_sort = namespaces.slice(0).sort();\n\t\t\tnamespace_re = new RegExp(\"(^|\\\\.)\" + namespace_sort.join(\"\\\\.(?:.*\\\\.)?\") + \"(\\\\.|$)\");\n\t\t}\n\n\t\tevent.namespace = event.namespace || namespace_sort.join(\".\");\n\n\t\tevents = jQuery._data(this, \"events\");\n\n\t\thandlers = (events || {})[ event.type ];\n\n\t\tif ( events && handlers ) {\n\t\t\t// Clone the handlers to prevent manipulation\n\t\t\thandlers = handlers.slice(0);\n\n\t\t\tfor ( var j = 0, l = handlers.length; j < l; j++ ) {\n\t\t\t\tvar handleObj = handlers[ j ];\n\n\t\t\t\t// Filter the functions by class\n\t\t\t\tif ( all || namespace_re.test( handleObj.namespace ) ) {\n\t\t\t\t\t// Pass in a reference to the handler function itself\n\t\t\t\t\t// So that we can later remove it\n\t\t\t\t\tevent.handler = handleObj.handler;\n\t\t\t\t\tevent.data = handleObj.data;\n\t\t\t\t\tevent.handleObj = handleObj;\n\n\t\t\t\t\tvar ret = handleObj.handler.apply( this, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tevent.result = ret;\n\t\t\t\t\t\tif ( ret === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( event.isImmediatePropagationStopped() ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tprops: \"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which\".split(\" \"),\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// store a copy of the original event object\n\t\t// and \"clone\" to set read-only properties\n\t\tvar originalEvent = event;\n\t\tevent = jQuery.Event( originalEvent );\n\n\t\tfor ( var i = this.props.length, prop; i; ) {\n\t\t\tprop = this.props[ --i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Fix target property, if necessary\n\t\tif ( !event.target ) {\n\t\t\t// Fixes #1925 where srcElement might not be defined either\n\t\t\tevent.target = event.srcElement || document;\n\t\t}\n\n\t\t// check if target is a textnode (safari)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\t// Add relatedTarget, if necessary\n\t\tif ( !event.relatedTarget && event.fromElement ) {\n\t\t\tevent.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;\n\t\t}\n\n\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\tif ( event.pageX == null && event.clientX != null ) {\n\t\t\tvar doc = document.documentElement,\n\t\t\t\tbody = document.body;\n\n\t\t\tevent.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n\t\t\tevent.pageY = event.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);\n\t\t}\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && (event.charCode != null || event.keyCode != null) ) {\n\t\t\tevent.which = event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)\n\t\tif ( !event.metaKey && event.ctrlKey ) {\n\t\t\tevent.metaKey = event.ctrlKey;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t// Note: button is not normalized, so don't use it\n\t\tif ( !event.which && event.button !== undefined ) {\n\t\t\tevent.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));\n\t\t}\n\n\t\treturn event;\n\t},\n\n\t// Deprecated, use jQuery.guid instead\n\tguid: 1E8,\n\n\t// Deprecated, use jQuery.proxy instead\n\tproxy: jQuery.proxy,\n\n\tspecial: {\n\t\tready: {\n\t\t\t// Make sure the ready event is setup\n\t\t\tsetup: jQuery.bindReady,\n\t\t\tteardown: jQuery.noop\n\t\t},\n\n\t\tlive: {\n\t\t\tadd: function( handleObj ) {\n\t\t\t\tjQuery.event.add( this,\n\t\t\t\t\tliveConvert( handleObj.origType, handleObj.selector ),\n\t\t\t\t\tjQuery.extend({}, handleObj, {handler: liveHandler, guid: handleObj.handler.guid}) );\n\t\t\t},\n\n\t\t\tremove: function( handleObj ) {\n\t\t\t\tjQuery.event.remove( this, liveConvert( handleObj.origType, handleObj.selector ), handleObj );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tsetup: function( data, namespaces, eventHandle ) {\n\t\t\t\t// We only want to do this special case on windows\n\t\t\t\tif ( jQuery.isWindow( this ) ) {\n\t\t\t\t\tthis.onbeforeunload = eventHandle;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tteardown: function( namespaces, eventHandle ) {\n\t\t\t\tif ( this.onbeforeunload === eventHandle ) {\n\t\t\t\t\tthis.onbeforeunload = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = document.removeEventListener ?\n\tfunction( elem, type, handle ) {\n\t\tif ( elem.removeEventListener ) {\n\t\t\telem.removeEventListener( type, handle, false );\n\t\t}\n\t} :\n\tfunction( elem, type, handle ) {\n\t\tif ( elem.detachEvent ) {\n\t\t\telem.detachEvent( \"on\" + type, handle );\n\t\t}\n\t};\n\njQuery.Event = function( src ) {\n\t// Allow instantiation without the 'new' keyword\n\tif ( !this.preventDefault ) {\n\t\treturn new jQuery.Event( src );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false ||\n\t\t\tsrc.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// timeStamp is buggy for some events on Firefox(#3843)\n\t// So we won't rely on the native value\n\tthis.timeStamp = jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\nfunction returnFalse() {\n\treturn false;\n}\nfunction returnTrue() {\n\treturn true;\n}\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tpreventDefault: function() {\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tvar e = this.originalEvent;\n\t\tif ( !e ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// if preventDefault exists run it on the original event\n\t\tif ( e.preventDefault ) {\n\t\t\te.preventDefault();\n\n\t\t// otherwise set the returnValue property of the original event to false (IE)\n\t\t} else {\n\t\t\te.returnValue = false;\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tvar e = this.originalEvent;\n\t\tif ( !e ) {\n\t\t\treturn;\n\t\t}\n\t\t// if stopPropagation exists run it on the original event\n\t\tif ( e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t\t// otherwise set the cancelBubble property of the original event to true (IE)\n\t\te.cancelBubble = true;\n\t},\n\tstopImmediatePropagation: function() {\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\t\tthis.stopPropagation();\n\t},\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse\n};\n\n// Checks if an event happened on an element within another element\n// Used in jQuery.event.special.mouseenter and mouseleave handlers\nvar withinElement = function( event ) {\n\t// Check if mouse(over|out) are still within the same parent element\n\tvar parent = event.relatedTarget;\n\n\t// Firefox sometimes assigns relatedTarget a XUL element\n\t// which we cannot access the parentNode property of\n\ttry {\n\n\t\t// Chrome does something similar, the parentNode property\n\t\t// can be accessed but is null.\n\t\tif ( parent !== document && !parent.parentNode ) {\n\t\t\treturn;\n\t\t}\n\t\t// Traverse up the tree\n\t\twhile ( parent && parent !== this ) {\n\t\t\tparent = parent.parentNode;\n\t\t}\n\n\t\tif ( parent !== this ) {\n\t\t\t// set the correct event type\n\t\t\tevent.type = event.data;\n\n\t\t\t// handle event if we actually just moused on to a non sub-element\n\t\t\tjQuery.event.handle.apply( this, arguments );\n\t\t}\n\n\t// assuming we've left the element since we most likely mousedover a xul element\n\t} catch(e) { }\n},\n\n// In case of event delegation, we only need to rename the event.type,\n// liveHandler will take care of the rest.\ndelegate = function( event ) {\n\tevent.type = event.data;\n\tjQuery.event.handle.apply( this, arguments );\n};\n\n// Create mouseenter and mouseleave events\njQuery.each({\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tsetup: function( data ) {\n\t\t\tjQuery.event.add( this, fix, data && data.selector ? delegate : withinElement, orig );\n\t\t},\n\t\tteardown: function( data ) {\n\t\t\tjQuery.event.remove( this, fix, data && data.selector ? delegate : withinElement );\n\t\t}\n\t};\n});\n\n// submit delegation\nif ( !jQuery.support.submitBubbles ) {\n\n\tjQuery.event.special.submit = {\n\t\tsetup: function( data, namespaces ) {\n\t\t\tif ( this.nodeName && this.nodeName.toLowerCase() !== \"form\" ) {\n\t\t\t\tjQuery.event.add(this, \"click.specialSubmit\", function( e ) {\n\t\t\t\t\tvar elem = e.target,\n\t\t\t\t\t\ttype = elem.type;\n\n\t\t\t\t\tif ( (type === \"submit\" || type === \"image\") && jQuery( elem ).closest(\"form\").length ) {\n\t\t\t\t\t\ttrigger( \"submit\", this, arguments );\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tjQuery.event.add(this, \"keypress.specialSubmit\", function( e ) {\n\t\t\t\t\tvar elem = e.target,\n\t\t\t\t\t\ttype = elem.type;\n\n\t\t\t\t\tif ( (type === \"text\" || type === \"password\") && jQuery( elem ).closest(\"form\").length && e.keyCode === 13 ) {\n\t\t\t\t\t\ttrigger( \"submit\", this, arguments );\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\tteardown: function( namespaces ) {\n\t\t\tjQuery.event.remove( this, \".specialSubmit\" );\n\t\t}\n\t};\n\n}\n\n// change delegation, happens here so we have bind.\nif ( !jQuery.support.changeBubbles ) {\n\n\tvar changeFilters,\n\n\tgetVal = function( elem ) {\n\t\tvar type = elem.type, val = elem.value;\n\n\t\tif ( type === \"radio\" || type === \"checkbox\" ) {\n\t\t\tval = elem.checked;\n\n\t\t} else if ( type === \"select-multiple\" ) {\n\t\t\tval = elem.selectedIndex > -1 ?\n\t\t\t\tjQuery.map( elem.options, function( elem ) {\n\t\t\t\t\treturn elem.selected;\n\t\t\t\t}).join(\"-\") :\n\t\t\t\t\"\";\n\n\t\t} else if ( elem.nodeName.toLowerCase() === \"select\" ) {\n\t\t\tval = elem.selectedIndex;\n\t\t}\n\n\t\treturn val;\n\t},\n\n\ttestChange = function testChange( e ) {\n\t\tvar elem = e.target, data, val;\n\n\t\tif ( !rformElems.test( elem.nodeName ) || elem.readOnly ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdata = jQuery._data( elem, \"_change_data\" );\n\t\tval = getVal(elem);\n\n\t\t// the current data will be also retrieved by beforeactivate\n\t\tif ( e.type !== \"focusout\" || elem.type !== \"radio\" ) {\n\t\t\tjQuery._data( elem, \"_change_data\", val );\n\t\t}\n\n\t\tif ( data === undefined || val === data ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( data != null || val ) {\n\t\t\te.type = \"change\";\n\t\t\te.liveFired = undefined;\n\t\t\tjQuery.event.trigger( e, arguments[1], elem );\n\t\t}\n\t};\n\n\tjQuery.event.special.change = {\n\t\tfilters: {\n\t\t\tfocusout: testChange,\n\n\t\t\tbeforedeactivate: testChange,\n\n\t\t\tclick: function( e ) {\n\t\t\t\tvar elem = e.target, type = elem.type;\n\n\t\t\t\tif ( type === \"radio\" || type === \"checkbox\" || elem.nodeName.toLowerCase() === \"select\" ) {\n\t\t\t\t\ttestChange.call( this, e );\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Change has to be called before submit\n\t\t\t// Keydown will be called before keypress, which is used in submit-event delegation\n\t\t\tkeydown: function( e ) {\n\t\t\t\tvar elem = e.target, type = elem.type;\n\n\t\t\t\tif ( (e.keyCode === 13 && elem.nodeName.toLowerCase() !== \"textarea\") ||\n\t\t\t\t\t(e.keyCode === 32 && (type === \"checkbox\" || type === \"radio\")) ||\n\t\t\t\t\ttype === \"select-multiple\" ) {\n\t\t\t\t\ttestChange.call( this, e );\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Beforeactivate happens also before the previous element is blurred\n\t\t\t// with this event you can't trigger a change event, but you can store\n\t\t\t// information\n\t\t\tbeforeactivate: function( e ) {\n\t\t\t\tvar elem = e.target;\n\t\t\t\tjQuery._data( elem, \"_change_data\", getVal(elem) );\n\t\t\t}\n\t\t},\n\n\t\tsetup: function( data, namespaces ) {\n\t\t\tif ( this.type === \"file\" ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor ( var type in changeFilters ) {\n\t\t\t\tjQuery.event.add( this, type + \".specialChange\", changeFilters[type] );\n\t\t\t}\n\n\t\t\treturn rformElems.test( this.nodeName );\n\t\t},\n\n\t\tteardown: function( namespaces ) {\n\t\t\tjQuery.event.remove( this, \".specialChange\" );\n\n\t\t\treturn rformElems.test( this.nodeName );\n\t\t}\n\t};\n\n\tchangeFilters = jQuery.event.special.change.filters;\n\n\t// Handle when the input is .focus()'d\n\tchangeFilters.focus = changeFilters.beforeactivate;\n}\n\nfunction trigger( type, elem, args ) {\n\t// Piggyback on a donor event to simulate a different one.\n\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t// simulated event prevents default then we do the same on the donor.\n\t// Don't pass args or remember liveFired; they apply to the donor event.\n\tvar event = jQuery.extend( {}, args[ 0 ] );\n\tevent.type = type;\n\tevent.originalEvent = {};\n\tevent.liveFired = undefined;\n\tjQuery.event.handle.call( elem, event );\n\tif ( event.isDefaultPrevented() ) {\n\t\targs[ 0 ].preventDefault();\n\t}\n}\n\n// Create \"bubbling\" focus and blur events\nif ( document.addEventListener ) {\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tthis.addEventListener( orig, handler, true );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tthis.removeEventListener( orig, handler, true );\n\t\t\t}\n\t\t};\n\n\t\tfunction handler( e ) {\n\t\t\te = jQuery.event.fix( e );\n\t\t\te.type = fix;\n\t\t\treturn jQuery.event.handle.call( this, e );\n\t\t}\n\t});\n}\n\njQuery.each([\"bind\", \"one\"], function( i, name ) {\n\tjQuery.fn[ name ] = function( type, data, fn ) {\n\t\t// Handle object literals\n\t\tif ( typeof type === \"object\" ) {\n\t\t\tfor ( var key in type ) {\n\t\t\t\tthis[ name ](key, data, type[key], fn);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( jQuery.isFunction( data ) || data === false ) {\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\tvar handler = name === \"one\" ? jQuery.proxy( fn, function( event ) {\n\t\t\tjQuery( this ).unbind( event, handler );\n\t\t\treturn fn.apply( this, arguments );\n\t\t}) : fn;\n\n\t\tif ( type === \"unload\" && name !== \"one\" ) {\n\t\t\tthis.one( type, data, fn );\n\n\t\t} else {\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ) {\n\t\t\t\tjQuery.event.add( this[i], type, handler, data );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n});\n\njQuery.fn.extend({\n\tunbind: function( type, fn ) {\n\t\t// Handle object literals\n\t\tif ( typeof type === \"object\" && !type.preventDefault ) {\n\t\t\tfor ( var key in type ) {\n\t\t\t\tthis.unbind(key, type[key]);\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ) {\n\t\t\t\tjQuery.event.remove( this[i], type, fn );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.live( types, data, fn, selector );\n\t},\n\n\tundelegate: function( selector, types, fn ) {\n\t\tif ( arguments.length === 0 ) {\n\t\t\t\treturn this.unbind( \"live\" );\n\n\t\t} else {\n\t\t\treturn this.die( types, null, fn, selector );\n\t\t}\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\n\ttriggerHandler: function( type, data ) {\n\t\tif ( this[0] ) {\n\t\t\tvar event = jQuery.Event( type );\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t\tjQuery.event.trigger( event, data, this[0] );\n\t\t\treturn event.result;\n\t\t}\n\t},\n\n\ttoggle: function( fn ) {\n\t\t// Save reference to arguments for access in closure\n\t\tvar args = arguments,\n\t\t\ti = 1;\n\n\t\t// link all the functions, so any of them can unbind this click handler\n\t\twhile ( i < args.length ) {\n\t\t\tjQuery.proxy( fn, args[ i++ ] );\n\t\t}\n\n\t\treturn this.click( jQuery.proxy( fn, function( event ) {\n\t\t\t// Figure out which function to execute\n\t\t\tvar lastToggle = ( jQuery._data( this, \"lastToggle\" + fn.guid ) || 0 ) % i;\n\t\t\tjQuery._data( this, \"lastToggle\" + fn.guid, lastToggle + 1 );\n\n\t\t\t// Make sure that clicks stop\n\t\t\tevent.preventDefault();\n\n\t\t\t// and execute the function\n\t\t\treturn args[ lastToggle ].apply( this, arguments ) || false;\n\t\t}));\n\t},\n\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n});\n\nvar liveMap = {\n\tfocus: \"focusin\",\n\tblur: \"focusout\",\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\"\n};\n\njQuery.each([\"live\", \"die\"], function( i, name ) {\n\tjQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) {\n\t\tvar type, i = 0, match, namespaces, preType,\n\t\t\tselector = origSelector || this.selector,\n\t\t\tcontext = origSelector ? this : jQuery( this.context );\n\n\t\tif ( typeof types === \"object\" && !types.preventDefault ) {\n\t\t\tfor ( var key in types ) {\n\t\t\t\tcontext[ name ]( key, data, types[key], selector );\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\ttypes = (types || \"\").split(\" \");\n\n\t\twhile ( (type = types[ i++ ]) != null ) {\n\t\t\tmatch = rnamespaces.exec( type );\n\t\t\tnamespaces = \"\";\n\n\t\t\tif ( match )  {\n\t\t\t\tnamespaces = match[0];\n\t\t\t\ttype = type.replace( rnamespaces, \"\" );\n\t\t\t}\n\n\t\t\tif ( type === \"hover\" ) {\n\t\t\t\ttypes.push( \"mouseenter\" + namespaces, \"mouseleave\" + namespaces );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpreType = type;\n\n\t\t\tif ( type === \"focus\" || type === \"blur\" ) {\n\t\t\t\ttypes.push( liveMap[ type ] + namespaces );\n\t\t\t\ttype = type + namespaces;\n\n\t\t\t} else {\n\t\t\t\ttype = (liveMap[ type ] || type) + namespaces;\n\t\t\t}\n\n\t\t\tif ( name === \"live\" ) {\n\t\t\t\t// bind live handler\n\t\t\t\tfor ( var j = 0, l = context.length; j < l; j++ ) {\n\t\t\t\t\tjQuery.event.add( context[j], \"live.\" + liveConvert( type, selector ),\n\t\t\t\t\t\t{ data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType } );\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// unbind live handler\n\t\t\t\tcontext.unbind( \"live.\" + liveConvert( type, selector ), fn );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n});\n\nfunction liveHandler( event ) {\n\tvar stop, maxLevel, related, match, handleObj, elem, j, i, l, data, close, namespace, ret,\n\t\telems = [],\n\t\tselectors = [],\n\t\tevents = jQuery._data( this, \"events\" );\n\n\t// Make sure we avoid non-left-click bubbling in Firefox (#3861) and disabled elements in IE (#6911)\n\tif ( event.liveFired === this || !events || !events.live || event.target.disabled || event.button && event.type === \"click\" ) {\n\t\treturn;\n\t}\n\n\tif ( event.namespace ) {\n\t\tnamespace = new RegExp(\"(^|\\\\.)\" + event.namespace.split(\".\").join(\"\\\\.(?:.*\\\\.)?\") + \"(\\\\.|$)\");\n\t}\n\n\tevent.liveFired = this;\n\n\tvar live = events.live.slice(0);\n\n\tfor ( j = 0; j < live.length; j++ ) {\n\t\thandleObj = live[j];\n\n\t\tif ( handleObj.origType.replace( rnamespaces, \"\" ) === event.type ) {\n\t\t\tselectors.push( handleObj.selector );\n\n\t\t} else {\n\t\t\tlive.splice( j--, 1 );\n\t\t}\n\t}\n\n\tmatch = jQuery( event.target ).closest( selectors, event.currentTarget );\n\n\tfor ( i = 0, l = match.length; i < l; i++ ) {\n\t\tclose = match[i];\n\n\t\tfor ( j = 0; j < live.length; j++ ) {\n\t\t\thandleObj = live[j];\n\n\t\t\tif ( close.selector === handleObj.selector && (!namespace || namespace.test( handleObj.namespace )) && !close.elem.disabled ) {\n\t\t\t\telem = close.elem;\n\t\t\t\trelated = null;\n\n\t\t\t\t// Those two events require additional checking\n\t\t\t\tif ( handleObj.preType === \"mouseenter\" || handleObj.preType === \"mouseleave\" ) {\n\t\t\t\t\tevent.type = handleObj.preType;\n\t\t\t\t\trelated = jQuery( event.relatedTarget ).closest( handleObj.selector )[0];\n\t\t\t\t}\n\n\t\t\t\tif ( !related || related !== elem ) {\n\t\t\t\t\telems.push({ elem: elem, handleObj: handleObj, level: close.level });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor ( i = 0, l = elems.length; i < l; i++ ) {\n\t\tmatch = elems[i];\n\n\t\tif ( maxLevel && match.level > maxLevel ) {\n\t\t\tbreak;\n\t\t}\n\n\t\tevent.currentTarget = match.elem;\n\t\tevent.data = match.handleObj.data;\n\t\tevent.handleObj = match.handleObj;\n\n\t\tret = match.handleObj.origHandler.apply( match.elem, arguments );\n\n\t\tif ( ret === false || event.isPropagationStopped() ) {\n\t\t\tmaxLevel = match.level;\n\n\t\t\tif ( ret === false ) {\n\t\t\t\tstop = false;\n\t\t\t}\n\t\t\tif ( event.isImmediatePropagationStopped() ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn stop;\n}\n\nfunction liveConvert( type, selector ) {\n\treturn (type && type !== \"*\" ? type + \".\" : \"\") + selector.replace(rperiod, \"`\").replace(rspace, \"&\");\n}\n\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error\").split(\" \"), function( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\tif ( fn == null ) {\n\t\t\tfn = data;\n\t\t\tdata = null;\n\t\t}\n\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.bind( name, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n\n\tif ( jQuery.attrFn ) {\n\t\tjQuery.attrFn[ name ] = true;\n\t}\n});\n\n\n/*!\n * Sizzle CSS Selector Engine\n *  Copyright 2011, The Dojo Foundation\n *  Released under the MIT, BSD, and GPL Licenses.\n *  More information: http://sizzlejs.com/\n */\n(function(){\n\nvar chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^\\[\\]]*\\]|['\"][^'\"]*['\"]|[^\\[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g,\n\tdone = 0,\n\ttoString = Object.prototype.toString,\n\thasDuplicate = false,\n\tbaseHasDuplicate = true,\n\trBackslash = /\\\\/g,\n\trNonWord = /\\W/;\n\n// Here we check if the JavaScript engine is using some sort of\n// optimization where it does not always call our comparision\n// function. If that is the case, discard the hasDuplicate value.\n//   Thus far that includes Google Chrome.\n[0, 0].sort(function() {\n\tbaseHasDuplicate = false;\n\treturn 0;\n});\n\nvar Sizzle = function( selector, context, results, seed ) {\n\tresults = results || [];\n\tcontext = context || document;\n\n\tvar origContext = context;\n\n\tif ( context.nodeType !== 1 && context.nodeType !== 9 ) {\n\t\treturn [];\n\t}\n\t\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tvar m, set, checkSet, extra, ret, cur, pop, i,\n\t\tprune = true,\n\t\tcontextXML = Sizzle.isXML( context ),\n\t\tparts = [],\n\t\tsoFar = selector;\n\t\n\t// Reset the position of the chunker regexp (start from head)\n\tdo {\n\t\tchunker.exec( \"\" );\n\t\tm = chunker.exec( soFar );\n\n\t\tif ( m ) {\n\t\t\tsoFar = m[3];\n\t\t\n\t\t\tparts.push( m[1] );\n\t\t\n\t\t\tif ( m[2] ) {\n\t\t\t\textra = m[3];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while ( m );\n\n\tif ( parts.length > 1 && origPOS.exec( selector ) ) {\n\n\t\tif ( parts.length === 2 && Expr.relative[ parts[0] ] ) {\n\t\t\tset = posProcess( parts[0] + parts[1], context );\n\n\t\t} else {\n\t\t\tset = Expr.relative[ parts[0] ] ?\n\t\t\t\t[ context ] :\n\t\t\t\tSizzle( parts.shift(), context );\n\n\t\t\twhile ( parts.length ) {\n\t\t\t\tselector = parts.shift();\n\n\t\t\t\tif ( Expr.relative[ selector ] ) {\n\t\t\t\t\tselector += parts.shift();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tset = posProcess( selector, set );\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t// (but not if it'll be faster if the inner selector is an ID)\n\t\tif ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&\n\t\t\t\tExpr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {\n\n\t\t\tret = Sizzle.find( parts.shift(), context, contextXML );\n\t\t\tcontext = ret.expr ?\n\t\t\t\tSizzle.filter( ret.expr, ret.set )[0] :\n\t\t\t\tret.set[0];\n\t\t}\n\n\t\tif ( context ) {\n\t\t\tret = seed ?\n\t\t\t\t{ expr: parts.pop(), set: makeArray(seed) } :\n\t\t\t\tSizzle.find( parts.pop(), parts.length === 1 && (parts[0] === \"~\" || parts[0] === \"+\") && context.parentNode ? context.parentNode : context, contextXML );\n\n\t\t\tset = ret.expr ?\n\t\t\t\tSizzle.filter( ret.expr, ret.set ) :\n\t\t\t\tret.set;\n\n\t\t\tif ( parts.length > 0 ) {\n\t\t\t\tcheckSet = makeArray( set );\n\n\t\t\t} else {\n\t\t\t\tprune = false;\n\t\t\t}\n\n\t\t\twhile ( parts.length ) {\n\t\t\t\tcur = parts.pop();\n\t\t\t\tpop = cur;\n\n\t\t\t\tif ( !Expr.relative[ cur ] ) {\n\t\t\t\t\tcur = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tpop = parts.pop();\n\t\t\t\t}\n\n\t\t\t\tif ( pop == null ) {\n\t\t\t\t\tpop = context;\n\t\t\t\t}\n\n\t\t\t\tExpr.relative[ cur ]( checkSet, pop, contextXML );\n\t\t\t}\n\n\t\t} else {\n\t\t\tcheckSet = parts = [];\n\t\t}\n\t}\n\n\tif ( !checkSet ) {\n\t\tcheckSet = set;\n\t}\n\n\tif ( !checkSet ) {\n\t\tSizzle.error( cur || selector );\n\t}\n\n\tif ( toString.call(checkSet) === \"[object Array]\" ) {\n\t\tif ( !prune ) {\n\t\t\tresults.push.apply( results, checkSet );\n\n\t\t} else if ( context && context.nodeType === 1 ) {\n\t\t\tfor ( i = 0; checkSet[i] != null; i++ ) {\n\t\t\t\tif ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {\n\t\t\t\t\tresults.push( set[i] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor ( i = 0; checkSet[i] != null; i++ ) {\n\t\t\t\tif ( checkSet[i] && checkSet[i].nodeType === 1 ) {\n\t\t\t\t\tresults.push( set[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tmakeArray( checkSet, results );\n\t}\n\n\tif ( extra ) {\n\t\tSizzle( extra, origContext, results, seed );\n\t\tSizzle.uniqueSort( results );\n\t}\n\n\treturn results;\n};\n\nSizzle.uniqueSort = function( results ) {\n\tif ( sortOrder ) {\n\t\thasDuplicate = baseHasDuplicate;\n\t\tresults.sort( sortOrder );\n\n\t\tif ( hasDuplicate ) {\n\t\t\tfor ( var i = 1; i < results.length; i++ ) {\n\t\t\t\tif ( results[i] === results[ i - 1 ] ) {\n\t\t\t\t\tresults.splice( i--, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn results;\n};\n\nSizzle.matches = function( expr, set ) {\n\treturn Sizzle( expr, null, null, set );\n};\n\nSizzle.matchesSelector = function( node, expr ) {\n\treturn Sizzle( expr, null, null, [node] ).length > 0;\n};\n\nSizzle.find = function( expr, context, isXML ) {\n\tvar set;\n\n\tif ( !expr ) {\n\t\treturn [];\n\t}\n\n\tfor ( var i = 0, l = Expr.order.length; i < l; i++ ) {\n\t\tvar match,\n\t\t\ttype = Expr.order[i];\n\t\t\n\t\tif ( (match = Expr.leftMatch[ type ].exec( expr )) ) {\n\t\t\tvar left = match[1];\n\t\t\tmatch.splice( 1, 1 );\n\n\t\t\tif ( left.substr( left.length - 1 ) !== \"\\\\\" ) {\n\t\t\t\tmatch[1] = (match[1] || \"\").replace( rBackslash, \"\" );\n\t\t\t\tset = Expr.find[ type ]( match, context, isXML );\n\n\t\t\t\tif ( set != null ) {\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( !set ) {\n\t\tset = typeof context.getElementsByTagName !== \"undefined\" ?\n\t\t\tcontext.getElementsByTagName( \"*\" ) :\n\t\t\t[];\n\t}\n\n\treturn { set: set, expr: expr };\n};\n\nSizzle.filter = function( expr, set, inplace, not ) {\n\tvar match, anyFound,\n\t\told = expr,\n\t\tresult = [],\n\t\tcurLoop = set,\n\t\tisXMLFilter = set && set[0] && Sizzle.isXML( set[0] );\n\n\twhile ( expr && set.length ) {\n\t\tfor ( var type in Expr.filter ) {\n\t\t\tif ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {\n\t\t\t\tvar found, item,\n\t\t\t\t\tfilter = Expr.filter[ type ],\n\t\t\t\t\tleft = match[1];\n\n\t\t\t\tanyFound = false;\n\n\t\t\t\tmatch.splice(1,1);\n\n\t\t\t\tif ( left.substr( left.length - 1 ) === \"\\\\\" ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( curLoop === result ) {\n\t\t\t\t\tresult = [];\n\t\t\t\t}\n\n\t\t\t\tif ( Expr.preFilter[ type ] ) {\n\t\t\t\t\tmatch = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );\n\n\t\t\t\t\tif ( !match ) {\n\t\t\t\t\t\tanyFound = found = true;\n\n\t\t\t\t\t} else if ( match === true ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\tfor ( var i = 0; (item = curLoop[i]) != null; i++ ) {\n\t\t\t\t\t\tif ( item ) {\n\t\t\t\t\t\t\tfound = filter( item, match, i, curLoop );\n\t\t\t\t\t\t\tvar pass = not ^ !!found;\n\n\t\t\t\t\t\t\tif ( inplace && found != null ) {\n\t\t\t\t\t\t\t\tif ( pass ) {\n\t\t\t\t\t\t\t\t\tanyFound = true;\n\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcurLoop[i] = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else if ( pass ) {\n\t\t\t\t\t\t\t\tresult.push( item );\n\t\t\t\t\t\t\t\tanyFound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( found !== undefined ) {\n\t\t\t\t\tif ( !inplace ) {\n\t\t\t\t\t\tcurLoop = result;\n\t\t\t\t\t}\n\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\n\n\t\t\t\t\tif ( !anyFound ) {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Improper expression\n\t\tif ( expr === old ) {\n\t\t\tif ( anyFound == null ) {\n\t\t\t\tSizzle.error( expr );\n\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\told = expr;\n\t}\n\n\treturn curLoop;\n};\n\nSizzle.error = function( msg ) {\n\tthrow \"Syntax error, unrecognized expression: \" + msg;\n};\n\nvar Expr = Sizzle.selectors = {\n\torder: [ \"ID\", \"NAME\", \"TAG\" ],\n\n\tmatch: {\n\t\tID: /#((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,\n\t\tCLASS: /\\.((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,\n\t\tNAME: /\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)['\"]*\\]/,\n\t\tATTR: /\\[\\s*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(?:(['\"])(.*?)\\3|(#?(?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)*)|)|)\\s*\\]/,\n\t\tTAG: /^((?:[\\w\\u00c0-\\uFFFF\\*\\-]|\\\\.)+)/,\n\t\tCHILD: /:(only|nth|last|first)-child(?:\\(\\s*(even|odd|(?:[+\\-]?\\d+|(?:[+\\-]?\\d*)?n\\s*(?:[+\\-]\\s*\\d+)?))\\s*\\))?/,\n\t\tPOS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^\\-]|$)/,\n\t\tPSEUDO: /:((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)(?:\\((['\"]?)((?:\\([^\\)]+\\)|[^\\(\\)]*)+)\\2\\))?/\n\t},\n\n\tleftMatch: {},\n\n\tattrMap: {\n\t\t\"class\": \"className\",\n\t\t\"for\": \"htmlFor\"\n\t},\n\n\tattrHandle: {\n\t\thref: function( elem ) {\n\t\t\treturn elem.getAttribute( \"href\" );\n\t\t},\n\t\ttype: function( elem ) {\n\t\t\treturn elem.getAttribute( \"type\" );\n\t\t}\n\t},\n\n\trelative: {\n\t\t\"+\": function(checkSet, part){\n\t\t\tvar isPartStr = typeof part === \"string\",\n\t\t\t\tisTag = isPartStr && !rNonWord.test( part ),\n\t\t\t\tisPartStrNotTag = isPartStr && !isTag;\n\n\t\t\tif ( isTag ) {\n\t\t\t\tpart = part.toLowerCase();\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {\n\t\t\t\tif ( (elem = checkSet[i]) ) {\n\t\t\t\t\twhile ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}\n\n\t\t\t\t\tcheckSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?\n\t\t\t\t\t\telem || false :\n\t\t\t\t\t\telem === part;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( isPartStrNotTag ) {\n\t\t\t\tSizzle.filter( part, checkSet, true );\n\t\t\t}\n\t\t},\n\n\t\t\">\": function( checkSet, part ) {\n\t\t\tvar elem,\n\t\t\t\tisPartStr = typeof part === \"string\",\n\t\t\t\ti = 0,\n\t\t\t\tl = checkSet.length;\n\n\t\t\tif ( isPartStr && !rNonWord.test( part ) ) {\n\t\t\t\tpart = part.toLowerCase();\n\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\telem = checkSet[i];\n\n\t\t\t\t\tif ( elem ) {\n\t\t\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\t\t\tcheckSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\telem = checkSet[i];\n\n\t\t\t\t\tif ( elem ) {\n\t\t\t\t\t\tcheckSet[i] = isPartStr ?\n\t\t\t\t\t\t\telem.parentNode :\n\t\t\t\t\t\t\telem.parentNode === part;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( isPartStr ) {\n\t\t\t\t\tSizzle.filter( part, checkSet, true );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t\"\": function(checkSet, part, isXML){\n\t\t\tvar nodeCheck,\n\t\t\t\tdoneName = done++,\n\t\t\t\tcheckFn = dirCheck;\n\n\t\t\tif ( typeof part === \"string\" && !rNonWord.test( part ) ) {\n\t\t\t\tpart = part.toLowerCase();\n\t\t\t\tnodeCheck = part;\n\t\t\t\tcheckFn = dirNodeCheck;\n\t\t\t}\n\n\t\t\tcheckFn( \"parentNode\", part, doneName, checkSet, nodeCheck, isXML );\n\t\t},\n\n\t\t\"~\": function( checkSet, part, isXML ) {\n\t\t\tvar nodeCheck,\n\t\t\t\tdoneName = done++,\n\t\t\t\tcheckFn = dirCheck;\n\n\t\t\tif ( typeof part === \"string\" && !rNonWord.test( part ) ) {\n\t\t\t\tpart = part.toLowerCase();\n\t\t\t\tnodeCheck = part;\n\t\t\t\tcheckFn = dirNodeCheck;\n\t\t\t}\n\n\t\t\tcheckFn( \"previousSibling\", part, doneName, checkSet, nodeCheck, isXML );\n\t\t}\n\t},\n\n\tfind: {\n\t\tID: function( match, context, isXML ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\n\t\t\t\tvar m = context.getElementById(match[1]);\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\treturn m && m.parentNode ? [m] : [];\n\t\t\t}\n\t\t},\n\n\t\tNAME: function( match, context ) {\n\t\t\tif ( typeof context.getElementsByName !== \"undefined\" ) {\n\t\t\t\tvar ret = [],\n\t\t\t\t\tresults = context.getElementsByName( match[1] );\n\n\t\t\t\tfor ( var i = 0, l = results.length; i < l; i++ ) {\n\t\t\t\t\tif ( results[i].getAttribute(\"name\") === match[1] ) {\n\t\t\t\t\t\tret.push( results[i] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ret.length === 0 ? null : ret;\n\t\t\t}\n\t\t},\n\n\t\tTAG: function( match, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( match[1] );\n\t\t\t}\n\t\t}\n\t},\n\tpreFilter: {\n\t\tCLASS: function( match, curLoop, inplace, result, not, isXML ) {\n\t\t\tmatch = \" \" + match[1].replace( rBackslash, \"\" ) + \" \";\n\n\t\t\tif ( isXML ) {\n\t\t\t\treturn match;\n\t\t\t}\n\n\t\t\tfor ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {\n\t\t\t\tif ( elem ) {\n\t\t\t\t\tif ( not ^ (elem.className && (\" \" + elem.className + \" \").replace(/[\\t\\n\\r]/g, \" \").indexOf(match) >= 0) ) {\n\t\t\t\t\t\tif ( !inplace ) {\n\t\t\t\t\t\t\tresult.push( elem );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( inplace ) {\n\t\t\t\t\t\tcurLoop[i] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\tID: function( match ) {\n\t\t\treturn match[1].replace( rBackslash, \"\" );\n\t\t},\n\n\t\tTAG: function( match, curLoop ) {\n\t\t\treturn match[1].replace( rBackslash, \"\" ).toLowerCase();\n\t\t},\n\n\t\tCHILD: function( match ) {\n\t\t\tif ( match[1] === \"nth\" ) {\n\t\t\t\tif ( !match[2] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\tmatch[2] = match[2].replace(/^\\+|\\s*/g, '');\n\n\t\t\t\t// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'\n\t\t\t\tvar test = /(-?)(\\d*)(?:n([+\\-]?\\d*))?/.exec(\n\t\t\t\t\tmatch[2] === \"even\" && \"2n\" || match[2] === \"odd\" && \"2n+1\" ||\n\t\t\t\t\t!/\\D/.test( match[2] ) && \"0n+\" + match[2] || match[2]);\n\n\t\t\t\t// calculate the numbers (first)n+(last) including if they are negative\n\t\t\t\tmatch[2] = (test[1] + (test[2] || 1)) - 0;\n\t\t\t\tmatch[3] = test[3] - 0;\n\t\t\t}\n\t\t\telse if ( match[2] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\t// TODO: Move to normal caching system\n\t\t\tmatch[0] = done++;\n\n\t\t\treturn match;\n\t\t},\n\n\t\tATTR: function( match, curLoop, inplace, result, not, isXML ) {\n\t\t\tvar name = match[1] = match[1].replace( rBackslash, \"\" );\n\t\t\t\n\t\t\tif ( !isXML && Expr.attrMap[name] ) {\n\t\t\t\tmatch[1] = Expr.attrMap[name];\n\t\t\t}\n\n\t\t\t// Handle if an un-quoted value was used\n\t\t\tmatch[4] = ( match[4] || match[5] || \"\" ).replace( rBackslash, \"\" );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[4] = \" \" + match[4] + \" \";\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\tPSEUDO: function( match, curLoop, inplace, result, not ) {\n\t\t\tif ( match[1] === \"not\" ) {\n\t\t\t\t// If we're dealing with a complex expression, or a simple one\n\t\t\t\tif ( ( chunker.exec(match[3]) || \"\" ).length > 1 || /^\\w/.test(match[3]) ) {\n\t\t\t\t\tmatch[3] = Sizzle(match[3], null, null, curLoop);\n\n\t\t\t\t} else {\n\t\t\t\t\tvar ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);\n\n\t\t\t\t\tif ( !inplace ) {\n\t\t\t\t\t\tresult.push.apply( result, ret );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn match;\n\t\t},\n\n\t\tPOS: function( match ) {\n\t\t\tmatch.unshift( true );\n\n\t\t\treturn match;\n\t\t}\n\t},\n\t\n\tfilters: {\n\t\tenabled: function( elem ) {\n\t\t\treturn elem.disabled === false && elem.type !== \"hidden\";\n\t\t},\n\n\t\tdisabled: function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\tchecked: function( elem ) {\n\t\t\treturn elem.checked === true;\n\t\t},\n\t\t\n\t\tselected: function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\t\t\t\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\tparent: function( elem ) {\n\t\t\treturn !!elem.firstChild;\n\t\t},\n\n\t\tempty: function( elem ) {\n\t\t\treturn !elem.firstChild;\n\t\t},\n\n\t\thas: function( elem, i, match ) {\n\t\t\treturn !!Sizzle( match[3], elem ).length;\n\t\t},\n\n\t\theader: function( elem ) {\n\t\t\treturn (/h\\d/i).test( elem.nodeName );\n\t\t},\n\n\t\ttext: function( elem ) {\n\t\t\t// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) \n\t\t\t// use getAttribute instead to test this case\n\t\t\treturn \"text\" === elem.getAttribute( 'type' );\n\t\t},\n\t\tradio: function( elem ) {\n\t\t\treturn \"radio\" === elem.type;\n\t\t},\n\n\t\tcheckbox: function( elem ) {\n\t\t\treturn \"checkbox\" === elem.type;\n\t\t},\n\n\t\tfile: function( elem ) {\n\t\t\treturn \"file\" === elem.type;\n\t\t},\n\t\tpassword: function( elem ) {\n\t\t\treturn \"password\" === elem.type;\n\t\t},\n\n\t\tsubmit: function( elem ) {\n\t\t\treturn \"submit\" === elem.type;\n\t\t},\n\n\t\timage: function( elem ) {\n\t\t\treturn \"image\" === elem.type;\n\t\t},\n\n\t\treset: function( elem ) {\n\t\t\treturn \"reset\" === elem.type;\n\t\t},\n\n\t\tbutton: function( elem ) {\n\t\t\treturn \"button\" === elem.type || elem.nodeName.toLowerCase() === \"button\";\n\t\t},\n\n\t\tinput: function( elem ) {\n\t\t\treturn (/input|select|textarea|button/i).test( elem.nodeName );\n\t\t}\n\t},\n\tsetFilters: {\n\t\tfirst: function( elem, i ) {\n\t\t\treturn i === 0;\n\t\t},\n\n\t\tlast: function( elem, i, match, array ) {\n\t\t\treturn i === array.length - 1;\n\t\t},\n\n\t\teven: function( elem, i ) {\n\t\t\treturn i % 2 === 0;\n\t\t},\n\n\t\todd: function( elem, i ) {\n\t\t\treturn i % 2 === 1;\n\t\t},\n\n\t\tlt: function( elem, i, match ) {\n\t\t\treturn i < match[3] - 0;\n\t\t},\n\n\t\tgt: function( elem, i, match ) {\n\t\t\treturn i > match[3] - 0;\n\t\t},\n\n\t\tnth: function( elem, i, match ) {\n\t\t\treturn match[3] - 0 === i;\n\t\t},\n\n\t\teq: function( elem, i, match ) {\n\t\t\treturn match[3] - 0 === i;\n\t\t}\n\t},\n\tfilter: {\n\t\tPSEUDO: function( elem, match, i, array ) {\n\t\t\tvar name = match[1],\n\t\t\t\tfilter = Expr.filters[ name ];\n\n\t\t\tif ( filter ) {\n\t\t\t\treturn filter( elem, i, match, array );\n\n\t\t\t} else if ( name === \"contains\" ) {\n\t\t\t\treturn (elem.textContent || elem.innerText || Sizzle.getText([ elem ]) || \"\").indexOf(match[3]) >= 0;\n\n\t\t\t} else if ( name === \"not\" ) {\n\t\t\t\tvar not = match[3];\n\n\t\t\t\tfor ( var j = 0, l = not.length; j < l; j++ ) {\n\t\t\t\t\tif ( not[j] === elem ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\t\t\t\tSizzle.error( name );\n\t\t\t}\n\t\t},\n\n\t\tCHILD: function( elem, match ) {\n\t\t\tvar type = match[1],\n\t\t\t\tnode = elem;\n\n\t\t\tswitch ( type ) {\n\t\t\t\tcase \"only\":\n\t\t\t\tcase \"first\":\n\t\t\t\t\twhile ( (node = node.previousSibling) )\t {\n\t\t\t\t\t\tif ( node.nodeType === 1 ) { \n\t\t\t\t\t\t\treturn false; \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( type === \"first\" ) { \n\t\t\t\t\t\treturn true; \n\t\t\t\t\t}\n\n\t\t\t\t\tnode = elem;\n\n\t\t\t\tcase \"last\":\n\t\t\t\t\twhile ( (node = node.nextSibling) )\t {\n\t\t\t\t\t\tif ( node.nodeType === 1 ) { \n\t\t\t\t\t\t\treturn false; \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\tcase \"nth\":\n\t\t\t\t\tvar first = match[2],\n\t\t\t\t\t\tlast = match[3];\n\n\t\t\t\t\tif ( first === 1 && last === 0 ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar doneName = match[0],\n\t\t\t\t\t\tparent = elem.parentNode;\n\t\n\t\t\t\t\tif ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {\n\t\t\t\t\t\tvar count = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor ( node = parent.firstChild; node; node = node.nextSibling ) {\n\t\t\t\t\t\t\tif ( node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\tnode.nodeIndex = ++count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n\n\t\t\t\t\t\tparent.sizcache = doneName;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar diff = elem.nodeIndex - last;\n\n\t\t\t\t\tif ( first === 0 ) {\n\t\t\t\t\t\treturn diff === 0;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tID: function( elem, match ) {\n\t\t\treturn elem.nodeType === 1 && elem.getAttribute(\"id\") === match;\n\t\t},\n\n\t\tTAG: function( elem, match ) {\n\t\t\treturn (match === \"*\" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;\n\t\t},\n\t\t\n\t\tCLASS: function( elem, match ) {\n\t\t\treturn (\" \" + (elem.className || elem.getAttribute(\"class\")) + \" \")\n\t\t\t\t.indexOf( match ) > -1;\n\t\t},\n\n\t\tATTR: function( elem, match ) {\n\t\t\tvar name = match[1],\n\t\t\t\tresult = Expr.attrHandle[ name ] ?\n\t\t\t\t\tExpr.attrHandle[ name ]( elem ) :\n\t\t\t\t\telem[ name ] != null ?\n\t\t\t\t\t\telem[ name ] :\n\t\t\t\t\t\telem.getAttribute( name ),\n\t\t\t\tvalue = result + \"\",\n\t\t\t\ttype = match[2],\n\t\t\t\tcheck = match[4];\n\n\t\t\treturn result == null ?\n\t\t\t\ttype === \"!=\" :\n\t\t\t\ttype === \"=\" ?\n\t\t\t\tvalue === check :\n\t\t\t\ttype === \"*=\" ?\n\t\t\t\tvalue.indexOf(check) >= 0 :\n\t\t\t\ttype === \"~=\" ?\n\t\t\t\t(\" \" + value + \" \").indexOf(check) >= 0 :\n\t\t\t\t!check ?\n\t\t\t\tvalue && result !== false :\n\t\t\t\ttype === \"!=\" ?\n\t\t\t\tvalue !== check :\n\t\t\t\ttype === \"^=\" ?\n\t\t\t\tvalue.indexOf(check) === 0 :\n\t\t\t\ttype === \"$=\" ?\n\t\t\t\tvalue.substr(value.length - check.length) === check :\n\t\t\t\ttype === \"|=\" ?\n\t\t\t\tvalue === check || value.substr(0, check.length + 1) === check + \"-\" :\n\t\t\t\tfalse;\n\t\t},\n\n\t\tPOS: function( elem, match, i, array ) {\n\t\t\tvar name = match[2],\n\t\t\t\tfilter = Expr.setFilters[ name ];\n\n\t\t\tif ( filter ) {\n\t\t\t\treturn filter( elem, i, match, array );\n\t\t\t}\n\t\t}\n\t}\n};\n\nvar origPOS = Expr.match.POS,\n\tfescape = function(all, num){\n\t\treturn \"\\\\\" + (num - 0 + 1);\n\t};\n\nfor ( var type in Expr.match ) {\n\tExpr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\\[]*\\])(?![^\\(]*\\))/.source) );\n\tExpr.leftMatch[ type ] = new RegExp( /(^(?:.|\\r|\\n)*?)/.source + Expr.match[ type ].source.replace(/\\\\(\\d+)/g, fescape) );\n}\n\nvar makeArray = function( array, results ) {\n\tarray = Array.prototype.slice.call( array, 0 );\n\n\tif ( results ) {\n\t\tresults.push.apply( results, array );\n\t\treturn results;\n\t}\n\t\n\treturn array;\n};\n\n// Perform a simple check to determine if the browser is capable of\n// converting a NodeList to an array using builtin methods.\n// Also verifies that the returned array holds DOM nodes\n// (which is not the case in the Blackberry browser)\ntry {\n\tArray.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;\n\n// Provide a fallback method if it does not work\n} catch( e ) {\n\tmakeArray = function( array, results ) {\n\t\tvar i = 0,\n\t\t\tret = results || [];\n\n\t\tif ( toString.call(array) === \"[object Array]\" ) {\n\t\t\tArray.prototype.push.apply( ret, array );\n\n\t\t} else {\n\t\t\tif ( typeof array.length === \"number\" ) {\n\t\t\t\tfor ( var l = array.length; i < l; i++ ) {\n\t\t\t\t\tret.push( array[i] );\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor ( ; array[i]; i++ ) {\n\t\t\t\t\tret.push( array[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t};\n}\n\nvar sortOrder, siblingCheck;\n\nif ( document.documentElement.compareDocumentPosition ) {\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {\n\t\t\treturn a.compareDocumentPosition ? -1 : 1;\n\t\t}\n\n\t\treturn a.compareDocumentPosition(b) & 4 ? -1 : 1;\n\t};\n\n} else {\n\tsortOrder = function( a, b ) {\n\t\tvar al, bl,\n\t\t\tap = [],\n\t\t\tbp = [],\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tcur = aup;\n\n\t\t// The nodes are identical, we can exit early\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\n\t\t// If the nodes are siblings (or identical) we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\n\t\t// If no parents were found then the nodes are disconnected\n\t\t} else if ( !aup ) {\n\t\t\treturn -1;\n\n\t\t} else if ( !bup ) {\n\t\t\treturn 1;\n\t\t}\n\n\t\t// Otherwise they're somewhere else in the tree so we need\n\t\t// to build up a full list of the parentNodes for comparison\n\t\twhile ( cur ) {\n\t\t\tap.unshift( cur );\n\t\t\tcur = cur.parentNode;\n\t\t}\n\n\t\tcur = bup;\n\n\t\twhile ( cur ) {\n\t\t\tbp.unshift( cur );\n\t\t\tcur = cur.parentNode;\n\t\t}\n\n\t\tal = ap.length;\n\t\tbl = bp.length;\n\n\t\t// Start walking down the tree looking for a discrepancy\n\t\tfor ( var i = 0; i < al && i < bl; i++ ) {\n\t\t\tif ( ap[i] !== bp[i] ) {\n\t\t\t\treturn siblingCheck( ap[i], bp[i] );\n\t\t\t}\n\t\t}\n\n\t\t// We ended someplace up the tree so do a sibling check\n\t\treturn i === al ?\n\t\t\tsiblingCheck( a, bp[i], -1 ) :\n\t\t\tsiblingCheck( ap[i], b, 1 );\n\t};\n\n\tsiblingCheck = function( a, b, ret ) {\n\t\tif ( a === b ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tvar cur = a.nextSibling;\n\n\t\twhile ( cur ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tcur = cur.nextSibling;\n\t\t}\n\n\t\treturn 1;\n\t};\n}\n\n// Utility function for retreiving the text value of an array of DOM nodes\nSizzle.getText = function( elems ) {\n\tvar ret = \"\", elem;\n\n\tfor ( var i = 0; elems[i]; i++ ) {\n\t\telem = elems[i];\n\n\t\t// Get the text from text nodes and CDATA nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 4 ) {\n\t\t\tret += elem.nodeValue;\n\n\t\t// Traverse everything else, except comment nodes\n\t\t} else if ( elem.nodeType !== 8 ) {\n\t\t\tret += Sizzle.getText( elem.childNodes );\n\t\t}\n\t}\n\n\treturn ret;\n};\n\n// Check to see if the browser returns elements by name when\n// querying by getElementById (and provide a workaround)\n(function(){\n\t// We're going to inject a fake input element with a specified name\n\tvar form = document.createElement(\"div\"),\n\t\tid = \"script\" + (new Date()).getTime(),\n\t\troot = document.documentElement;\n\n\tform.innerHTML = \"<a name='\" + id + \"'/>\";\n\n\t// Inject it into the root element, check its status, and remove it quickly\n\troot.insertBefore( form, root.firstChild );\n\n\t// The workaround has to do additional checks after a getElementById\n\t// Which slows things down for other browsers (hence the branching)\n\tif ( document.getElementById( id ) ) {\n\t\tExpr.find.ID = function( match, context, isXML ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\n\t\t\t\tvar m = context.getElementById(match[1]);\n\n\t\t\t\treturn m ?\n\t\t\t\t\tm.id === match[1] || typeof m.getAttributeNode !== \"undefined\" && m.getAttributeNode(\"id\").nodeValue === match[1] ?\n\t\t\t\t\t\t[m] :\n\t\t\t\t\t\tundefined :\n\t\t\t\t\t[];\n\t\t\t}\n\t\t};\n\n\t\tExpr.filter.ID = function( elem, match ) {\n\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\n\t\t\treturn elem.nodeType === 1 && node && node.nodeValue === match;\n\t\t};\n\t}\n\n\troot.removeChild( form );\n\n\t// release memory in IE\n\troot = form = null;\n})();\n\n(function(){\n\t// Check to see if the browser returns only elements\n\t// when doing getElementsByTagName(\"*\")\n\n\t// Create a fake element\n\tvar div = document.createElement(\"div\");\n\tdiv.appendChild( document.createComment(\"\") );\n\n\t// Make sure no comments are found\n\tif ( div.getElementsByTagName(\"*\").length > 0 ) {\n\t\tExpr.find.TAG = function( match, context ) {\n\t\t\tvar results = context.getElementsByTagName( match[1] );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( match[1] === \"*\" ) {\n\t\t\t\tvar tmp = [];\n\n\t\t\t\tfor ( var i = 0; results[i]; i++ ) {\n\t\t\t\t\tif ( results[i].nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( results[i] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresults = tmp;\n\t\t\t}\n\n\t\t\treturn results;\n\t\t};\n\t}\n\n\t// Check to see if an attribute returns normalized href attributes\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\n\tif ( div.firstChild && typeof div.firstChild.getAttribute !== \"undefined\" &&\n\t\t\tdiv.firstChild.getAttribute(\"href\") !== \"#\" ) {\n\n\t\tExpr.attrHandle.href = function( elem ) {\n\t\t\treturn elem.getAttribute( \"href\", 2 );\n\t\t};\n\t}\n\n\t// release memory in IE\n\tdiv = null;\n})();\n\nif ( document.querySelectorAll ) {\n\t(function(){\n\t\tvar oldSizzle = Sizzle,\n\t\t\tdiv = document.createElement(\"div\"),\n\t\t\tid = \"__sizzle__\";\n\n\t\tdiv.innerHTML = \"<p class='TEST'></p>\";\n\n\t\t// Safari can't handle uppercase or unicode characters when\n\t\t// in quirks mode.\n\t\tif ( div.querySelectorAll && div.querySelectorAll(\".TEST\").length === 0 ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tSizzle = function( query, context, extra, seed ) {\n\t\t\tcontext = context || document;\n\n\t\t\t// Only use querySelectorAll on non-XML documents\n\t\t\t// (ID selectors don't work in non-HTML documents)\n\t\t\tif ( !seed && !Sizzle.isXML(context) ) {\n\t\t\t\t// See if we find a selector to speed up\n\t\t\t\tvar match = /^(\\w+$)|^\\.([\\w\\-]+$)|^#([\\w\\-]+$)/.exec( query );\n\t\t\t\t\n\t\t\t\tif ( match && (context.nodeType === 1 || context.nodeType === 9) ) {\n\t\t\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t\t\tif ( match[1] ) {\n\t\t\t\t\t\treturn makeArray( context.getElementsByTagName( query ), extra );\n\t\t\t\t\t\n\t\t\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t\t\t} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {\n\t\t\t\t\t\treturn makeArray( context.getElementsByClassName( match[2] ), extra );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( context.nodeType === 9 ) {\n\t\t\t\t\t// Speed-up: Sizzle(\"body\")\n\t\t\t\t\t// The body element only exists once, optimize finding it\n\t\t\t\t\tif ( query === \"body\" && context.body ) {\n\t\t\t\t\t\treturn makeArray( [ context.body ], extra );\n\t\t\t\t\t\t\n\t\t\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\t\t\t} else if ( match && match[3] ) {\n\t\t\t\t\t\tvar elem = context.getElementById( match[3] );\n\n\t\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t\t// Handle the case where IE and Opera return items\n\t\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === match[3] ) {\n\t\t\t\t\t\t\t\treturn makeArray( [ elem ], extra );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn makeArray( [], extra );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn makeArray( context.querySelectorAll(query), extra );\n\t\t\t\t\t} catch(qsaError) {}\n\n\t\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t\t// IE 8 doesn't work on object elements\n\t\t\t\t} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\t\tvar oldContext = context,\n\t\t\t\t\t\told = context.getAttribute( \"id\" ),\n\t\t\t\t\t\tnid = old || id,\n\t\t\t\t\t\thasParent = context.parentNode,\n\t\t\t\t\t\trelativeHierarchySelector = /^\\s*[+~]/.test( query );\n\n\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnid = nid.replace( /'/g, \"\\\\$&\" );\n\t\t\t\t\t}\n\t\t\t\t\tif ( relativeHierarchySelector && hasParent ) {\n\t\t\t\t\t\tcontext = context.parentNode;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif ( !relativeHierarchySelector || hasParent ) {\n\t\t\t\t\t\t\treturn makeArray( context.querySelectorAll( \"[id='\" + nid + \"'] \" + query ), extra );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} catch(pseudoError) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\t\toldContext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\treturn oldSizzle(query, context, extra, seed);\n\t\t};\n\n\t\tfor ( var prop in oldSizzle ) {\n\t\t\tSizzle[ prop ] = oldSizzle[ prop ];\n\t\t}\n\n\t\t// release memory in IE\n\t\tdiv = null;\n\t})();\n}\n\n(function(){\n\tvar html = document.documentElement,\n\t\tmatches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector,\n\t\tpseudoWorks = false;\n\n\ttry {\n\t\t// This should fail with an exception\n\t\t// Gecko does not error, returns false instead\n\t\tmatches.call( document.documentElement, \"[test!='']:sizzle\" );\n\t\n\t} catch( pseudoError ) {\n\t\tpseudoWorks = true;\n\t}\n\n\tif ( matches ) {\n\t\tSizzle.matchesSelector = function( node, expr ) {\n\t\t\t// Make sure that attribute selectors are quoted\n\t\t\texpr = expr.replace(/\\=\\s*([^'\"\\]]*)\\s*\\]/g, \"='$1']\");\n\n\t\t\tif ( !Sizzle.isXML( node ) ) {\n\t\t\t\ttry { \n\t\t\t\t\tif ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {\n\t\t\t\t\t\treturn matches.call( node, expr );\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\n\t\t\treturn Sizzle(expr, null, null, [node]).length > 0;\n\t\t};\n\t}\n})();\n\n(function(){\n\tvar div = document.createElement(\"div\");\n\n\tdiv.innerHTML = \"<div class='test e'></div><div class='test'></div>\";\n\n\t// Opera can't find a second classname (in 9.6)\n\t// Also, make sure that getElementsByClassName actually exists\n\tif ( !div.getElementsByClassName || div.getElementsByClassName(\"e\").length === 0 ) {\n\t\treturn;\n\t}\n\n\t// Safari caches class attributes, doesn't catch changes (in 3.2)\n\tdiv.lastChild.className = \"e\";\n\n\tif ( div.getElementsByClassName(\"e\").length === 1 ) {\n\t\treturn;\n\t}\n\t\n\tExpr.order.splice(1, 0, \"CLASS\");\n\tExpr.find.CLASS = function( match, context, isXML ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && !isXML ) {\n\t\t\treturn context.getElementsByClassName(match[1]);\n\t\t}\n\t};\n\n\t// release memory in IE\n\tdiv = null;\n})();\n\nfunction dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\tvar elem = checkSet[i];\n\n\t\tif ( elem ) {\n\t\t\tvar match = false;\n\n\t\t\telem = elem[dir];\n\n\t\t\twhile ( elem ) {\n\t\t\t\tif ( elem.sizcache === doneName ) {\n\t\t\t\t\tmatch = checkSet[elem.sizset];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeType === 1 && !isXML ){\n\t\t\t\t\telem.sizcache = doneName;\n\t\t\t\t\telem.sizset = i;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeName.toLowerCase() === cur ) {\n\t\t\t\t\tmatch = elem;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\telem = elem[dir];\n\t\t\t}\n\n\t\t\tcheckSet[i] = match;\n\t\t}\n\t}\n}\n\nfunction dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\tvar elem = checkSet[i];\n\n\t\tif ( elem ) {\n\t\t\tvar match = false;\n\t\t\t\n\t\t\telem = elem[dir];\n\n\t\t\twhile ( elem ) {\n\t\t\t\tif ( elem.sizcache === doneName ) {\n\t\t\t\t\tmatch = checkSet[elem.sizset];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\tif ( !isXML ) {\n\t\t\t\t\t\telem.sizcache = doneName;\n\t\t\t\t\t\telem.sizset = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( typeof cur !== \"string\" ) {\n\t\t\t\t\t\tif ( elem === cur ) {\n\t\t\t\t\t\t\tmatch = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {\n\t\t\t\t\t\tmatch = elem;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telem = elem[dir];\n\t\t\t}\n\n\t\t\tcheckSet[i] = match;\n\t\t}\n\t}\n}\n\nif ( document.documentElement.contains ) {\n\tSizzle.contains = function( a, b ) {\n\t\treturn a !== b && (a.contains ? a.contains(b) : true);\n\t};\n\n} else if ( document.documentElement.compareDocumentPosition ) {\n\tSizzle.contains = function( a, b ) {\n\t\treturn !!(a.compareDocumentPosition(b) & 16);\n\t};\n\n} else {\n\tSizzle.contains = function() {\n\t\treturn false;\n\t};\n}\n\nSizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833) \n\tvar documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;\n\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\nvar posProcess = function( selector, context ) {\n\tvar match,\n\t\ttmpSet = [],\n\t\tlater = \"\",\n\t\troot = context.nodeType ? [context] : context;\n\n\t// Position selectors must be done after the filter\n\t// And so must :not(positional) so we move all PSEUDOs to the end\n\twhile ( (match = Expr.match.PSEUDO.exec( selector )) ) {\n\t\tlater += match[0];\n\t\tselector = selector.replace( Expr.match.PSEUDO, \"\" );\n\t}\n\n\tselector = Expr.relative[selector] ? selector + \"*\" : selector;\n\n\tfor ( var i = 0, l = root.length; i < l; i++ ) {\n\t\tSizzle( selector, root[i], tmpSet );\n\t}\n\n\treturn Sizzle.filter( later, tmpSet );\n};\n\n// EXPOSE\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.filters;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n})();\n\n\nvar runtil = /Until$/,\n\trparentsprev = /^(?:parents|prevUntil|prevAll)/,\n\t// Note: This RegExp should be improved, or likely pulled from Sizzle\n\trmultiselector = /,/,\n\tisSimple = /^.[^:#\\[\\.,]*$/,\n\tslice = Array.prototype.slice,\n\tPOS = jQuery.expr.match.POS,\n\t// methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend({\n\tfind: function( selector ) {\n\t\tvar ret = this.pushStack( \"\", \"find\", selector ),\n\t\t\tlength = 0;\n\n\t\tfor ( var i = 0, l = this.length; i < l; i++ ) {\n\t\t\tlength = ret.length;\n\t\t\tjQuery.find( selector, this[i], ret );\n\n\t\t\tif ( i > 0 ) {\n\t\t\t\t// Make sure that the results are unique\n\t\t\t\tfor ( var n = length; n < ret.length; n++ ) {\n\t\t\t\t\tfor ( var r = 0; r < length; r++ ) {\n\t\t\t\t\t\tif ( ret[r] === ret[n] ) {\n\t\t\t\t\t\t\tret.splice(n--, 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\thas: function( target ) {\n\t\tvar targets = jQuery( target );\n\t\treturn this.filter(function() {\n\t\t\tfor ( var i = 0, l = targets.length; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector, false), \"not\", selector);\n\t},\n\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector, true), \"filter\", selector );\n\t},\n\n\tis: function( selector ) {\n\t\treturn !!selector && jQuery.filter( selector, this ).length > 0;\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar ret = [], i, l, cur = this[0];\n\n\t\tif ( jQuery.isArray( selectors ) ) {\n\t\t\tvar match, selector,\n\t\t\t\tmatches = {},\n\t\t\t\tlevel = 1;\n\n\t\t\tif ( cur && selectors.length ) {\n\t\t\t\tfor ( i = 0, l = selectors.length; i < l; i++ ) {\n\t\t\t\t\tselector = selectors[i];\n\n\t\t\t\t\tif ( !matches[selector] ) {\n\t\t\t\t\t\tmatches[selector] = jQuery.expr.match.POS.test( selector ) ?\n\t\t\t\t\t\t\tjQuery( selector, context || this.context ) :\n\t\t\t\t\t\t\tselector;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile ( cur && cur.ownerDocument && cur !== context ) {\n\t\t\t\t\tfor ( selector in matches ) {\n\t\t\t\t\t\tmatch = matches[selector];\n\n\t\t\t\t\t\tif ( match.jquery ? match.index(cur) > -1 : jQuery(cur).is(match) ) {\n\t\t\t\t\t\t\tret.push({ selector: selector, elem: cur, level: level });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcur = cur.parentNode;\n\t\t\t\t\tlevel++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tvar pos = POS.test( selectors ) ?\n\t\t\tjQuery( selectors, context || this.context ) : null;\n\n\t\tfor ( i = 0, l = this.length; i < l; i++ ) {\n\t\t\tcur = this[i];\n\n\t\t\twhile ( cur ) {\n\t\t\t\tif ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {\n\t\t\t\t\tret.push( cur );\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else {\n\t\t\t\t\tcur = cur.parentNode;\n\t\t\t\t\tif ( !cur || !cur.ownerDocument || cur === context ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tret = ret.length > 1 ? jQuery.unique(ret) : ret;\n\n\t\treturn this.pushStack( ret, \"closest\", selectors );\n\t},\n\n\t// Determine the position of an element within\n\t// the matched set of elements\n\tindex: function( elem ) {\n\t\tif ( !elem || typeof elem === \"string\" ) {\n\t\t\treturn jQuery.inArray( this[0],\n\t\t\t\t// If it receives a string, the selector is used\n\t\t\t\t// If it receives nothing, the siblings are used\n\t\t\t\telem ? jQuery( elem ) : this.parent().children() );\n\t\t}\n\t\t// Locate the position of the desired element\n\t\treturn jQuery.inArray(\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[0] : elem, this );\n\t},\n\n\tadd: function( selector, context ) {\n\t\tvar set = typeof selector === \"string\" ?\n\t\t\t\tjQuery( selector, context ) :\n\t\t\t\tjQuery.makeArray( selector ),\n\t\t\tall = jQuery.merge( this.get(), set );\n\n\t\treturn this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?\n\t\t\tall :\n\t\t\tjQuery.unique( all ) );\n\t},\n\n\tandSelf: function() {\n\t\treturn this.add( this.prevObject );\n\t}\n});\n\n// A painfully simple check to see if an element is disconnected\n// from a document (should be improved, where feasible).\nfunction isDisconnected( node ) {\n\treturn !node || !node.parentNode || node.parentNode.nodeType === 11;\n}\n\njQuery.each({\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn jQuery.nth( elem, 2, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn jQuery.nth( elem, 2, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn jQuery.sibling( elem.parentNode.firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn jQuery.sibling( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn jQuery.nodeName( elem, \"iframe\" ) ?\n\t\t\telem.contentDocument || elem.contentWindow.document :\n\t\t\tjQuery.makeArray( elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until ),\n\t\t\t// The variable 'args' was introduced in\n\t\t\t// https://github.com/jquery/jquery/commit/52a0238\n\t\t\t// to work around a bug in Chrome 10 (Dev) and should be removed when the bug is fixed.\n\t\t\t// http://code.google.com/p/v8/issues/detail?id=1050\n\t\t\targs = slice.call(arguments);\n\n\t\tif ( !runtil.test( name ) ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;\n\n\t\tif ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {\n\t\t\tret = ret.reverse();\n\t\t}\n\n\t\treturn this.pushStack( ret, name, args.join(\",\") );\n\t};\n});\n\njQuery.extend({\n\tfilter: function( expr, elems, not ) {\n\t\tif ( not ) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\n\t\treturn elems.length === 1 ?\n\t\t\tjQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :\n\t\t\tjQuery.find.matches(expr, elems);\n\t},\n\n\tdir: function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\tcur = elem[ dir ];\n\n\t\twhile ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {\n\t\t\tif ( cur.nodeType === 1 ) {\n\t\t\t\tmatched.push( cur );\n\t\t\t}\n\t\t\tcur = cur[dir];\n\t\t}\n\t\treturn matched;\n\t},\n\n\tnth: function( cur, result, dir, elem ) {\n\t\tresult = result || 1;\n\t\tvar num = 0;\n\n\t\tfor ( ; cur; cur = cur[dir] ) {\n\t\t\tif ( cur.nodeType === 1 && ++num === result ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn cur;\n\t},\n\n\tsibling: function( n, elem ) {\n\t\tvar r = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tr.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn r;\n\t}\n});\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, keep ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep(elements, function( elem, i ) {\n\t\t\tvar retVal = !!qualifier.call( elem, i, elem );\n\t\t\treturn retVal === keep;\n\t\t});\n\n\t} else if ( qualifier.nodeType ) {\n\t\treturn jQuery.grep(elements, function( elem, i ) {\n\t\t\treturn (elem === qualifier) === keep;\n\t\t});\n\n\t} else if ( typeof qualifier === \"string\" ) {\n\t\tvar filtered = jQuery.grep(elements, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t});\n\n\t\tif ( isSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter(qualifier, filtered, !keep);\n\t\t} else {\n\t\t\tqualifier = jQuery.filter( qualifier, filtered );\n\t\t}\n\t}\n\n\treturn jQuery.grep(elements, function( elem, i ) {\n\t\treturn (jQuery.inArray( elem, qualifier ) >= 0) === keep;\n\t});\n}\n\n\n\n\nvar rinlinejQuery = / jQuery\\d+=\"(?:\\d+|null)\"/g,\n\trleadingWhitespace = /^\\s+/,\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,\n\trtagName = /<([\\w:]+)/,\n\trtbody = /<tbody/i,\n\trhtml = /<|&#?\\w+;/,\n\trnocache = /<(?:script|object|embed|option|style)/i,\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\twrapMap = {\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\t\tlegend: [ 1, \"<fieldset>\", \"</fieldset>\" ],\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\t\tcol: [ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ],\n\t\tarea: [ 1, \"<map>\", \"</map>\" ],\n\t\t_default: [ 0, \"\", \"\" ]\n\t};\n\nwrapMap.optgroup = wrapMap.option;\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n// IE can't serialize <link> and <script> tags normally\nif ( !jQuery.support.htmlSerialize ) {\n\twrapMap._default = [ 1, \"div<div>\", \"</div>\" ];\n}\n\njQuery.fn.extend({\n\ttext: function( text ) {\n\t\tif ( jQuery.isFunction(text) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tvar self = jQuery( this );\n\n\t\t\t\tself.text( text.call(this, i, self.text()) );\n\t\t\t});\n\t\t}\n\n\t\tif ( typeof text !== \"object\" && text !== undefined ) {\n\t\t\treturn this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );\n\t\t}\n\n\t\treturn jQuery.text( this );\n\t},\n\n\twrapAll: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tjQuery(this).wrapAll( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[0] ) {\n\t\t\t// The elements to wrap the target around\n\t\t\tvar wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);\n\n\t\t\tif ( this[0].parentNode ) {\n\t\t\t\twrap.insertBefore( this[0] );\n\t\t\t}\n\n\t\t\twrap.map(function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstChild && elem.firstChild.nodeType === 1 ) {\n\t\t\t\t\telem = elem.firstChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append(this);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tjQuery(this).wrapInner( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery( this ).wrapAll( html );\n\t\t});\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each(function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip(arguments, true, function( elem ) {\n\t\t\tif ( this.nodeType === 1 ) {\n\t\t\t\tthis.appendChild( elem );\n\t\t\t}\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip(arguments, true, function( elem ) {\n\t\t\tif ( this.nodeType === 1 ) {\n\t\t\t\tthis.insertBefore( elem, this.firstChild );\n\t\t\t}\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\tif ( this[0] && this[0].parentNode ) {\n\t\t\treturn this.domManip(arguments, false, function( elem ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t});\n\t\t} else if ( arguments.length ) {\n\t\t\tvar set = jQuery(arguments[0]);\n\t\t\tset.push.apply( set, this.toArray() );\n\t\t\treturn this.pushStack( set, \"before\", arguments );\n\t\t}\n\t},\n\n\tafter: function() {\n\t\tif ( this[0] && this[0].parentNode ) {\n\t\t\treturn this.domManip(arguments, false, function( elem ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t});\n\t\t} else if ( arguments.length ) {\n\t\t\tvar set = this.pushStack( this, \"after\", arguments );\n\t\t\tset.push.apply( set, jQuery(arguments[0]).toArray() );\n\t\t\treturn set;\n\t\t}\n\t},\n\n\t// keepData is for internal use only--do not document\n\tremove: function( selector, keepData ) {\n\t\tfor ( var i = 0, elem; (elem = this[i]) != null; i++ ) {\n\t\t\tif ( !selector || jQuery.filter( selector, [ elem ] ).length ) {\n\t\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\t\tjQuery.cleanData( elem.getElementsByTagName(\"*\") );\n\t\t\t\t\tjQuery.cleanData( [ elem ] );\n\t\t\t\t}\n\n\t\t\t\tif ( elem.parentNode ) {\n\t\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tempty: function() {\n\t\tfor ( var i = 0, elem; (elem = this[i]) != null; i++ ) {\n\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( elem.getElementsByTagName(\"*\") );\n\t\t\t}\n\n\t\t\t// Remove any remaining nodes\n\t\t\twhile ( elem.firstChild ) {\n\t\t\t\telem.removeChild( elem.firstChild );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function () {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\tif ( value === undefined ) {\n\t\t\treturn this[0] && this[0].nodeType === 1 ?\n\t\t\t\tthis[0].innerHTML.replace(rinlinejQuery, \"\") :\n\t\t\t\tnull;\n\n\t\t// See if we can take a shortcut and just use innerHTML\n\t\t} else if ( typeof value === \"string\" && !rnocache.test( value ) &&\n\t\t\t(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&\n\t\t\t!wrapMap[ (rtagName.exec( value ) || [\"\", \"\"])[1].toLowerCase() ] ) {\n\n\t\t\tvalue = value.replace(rxhtmlTag, \"<$1></$2>\");\n\n\t\t\ttry {\n\t\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ) {\n\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\tif ( this[i].nodeType === 1 ) {\n\t\t\t\t\t\tjQuery.cleanData( this[i].getElementsByTagName(\"*\") );\n\t\t\t\t\t\tthis[i].innerHTML = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t} catch(e) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\n\t\t} else if ( jQuery.isFunction( value ) ) {\n\t\t\tthis.each(function(i){\n\t\t\t\tvar self = jQuery( this );\n\n\t\t\t\tself.html( value.call(this, i, self.html()) );\n\t\t\t});\n\n\t\t} else {\n\t\t\tthis.empty().append( value );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\treplaceWith: function( value ) {\n\t\tif ( this[0] && this[0].parentNode ) {\n\t\t\t// Make sure that the elements are removed from the DOM before they are inserted\n\t\t\t// this can help fix replacing a parent with child elements\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each(function(i) {\n\t\t\t\t\tvar self = jQuery(this), old = self.html();\n\t\t\t\t\tself.replaceWith( value.call( this, i, old ) );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( typeof value !== \"string\" ) {\n\t\t\t\tvalue = jQuery( value ).detach();\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\tvar next = this.nextSibling,\n\t\t\t\t\tparent = this.parentNode;\n\n\t\t\t\tjQuery( this ).remove();\n\n\t\t\t\tif ( next ) {\n\t\t\t\t\tjQuery(next).before( value );\n\t\t\t\t} else {\n\t\t\t\t\tjQuery(parent).append( value );\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\treturn this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), \"replaceWith\", value );\n\t\t}\n\t},\n\n\tdetach: function( selector ) {\n\t\treturn this.remove( selector, true );\n\t},\n\n\tdomManip: function( args, table, callback ) {\n\t\tvar results, first, fragment, parent,\n\t\t\tvalue = args[0],\n\t\t\tscripts = [];\n\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === \"string\" && rchecked.test( value ) ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery(this).domManip( args, table, callback, true );\n\t\t\t});\n\t\t}\n\n\t\tif ( jQuery.isFunction(value) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tvar self = jQuery(this);\n\t\t\t\targs[0] = value.call(this, i, table ? self.html() : undefined);\n\t\t\t\tself.domManip( args, table, callback );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[0] ) {\n\t\t\tparent = value && value.parentNode;\n\n\t\t\t// If we're in a fragment, just use that instead of building a new one\n\t\t\tif ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {\n\t\t\t\tresults = { fragment: parent };\n\n\t\t\t} else {\n\t\t\t\tresults = jQuery.buildFragment( args, this, scripts );\n\t\t\t}\n\n\t\t\tfragment = results.fragment;\n\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfirst = fragment = fragment.firstChild;\n\t\t\t} else {\n\t\t\t\tfirst = fragment.firstChild;\n\t\t\t}\n\n\t\t\tif ( first ) {\n\t\t\t\ttable = table && jQuery.nodeName( first, \"tr\" );\n\n\t\t\t\tfor ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {\n\t\t\t\t\tcallback.call(\n\t\t\t\t\t\ttable ?\n\t\t\t\t\t\t\troot(this[i], first) :\n\t\t\t\t\t\t\tthis[i],\n\t\t\t\t\t\t// Make sure that we do not leak memory by inadvertently discarding\n\t\t\t\t\t\t// the original fragment (which might have attached data) instead of\n\t\t\t\t\t\t// using it; in addition, use the original fragment object for the last\n\t\t\t\t\t\t// item instead of first because it can end up being emptied incorrectly\n\t\t\t\t\t\t// in certain situations (Bug #8070).\n\t\t\t\t\t\t// Fragments from the fragment cache must always be cloned and never used\n\t\t\t\t\t\t// in place.\n\t\t\t\t\t\tresults.cacheable || (l > 1 && i < lastIndex) ?\n\t\t\t\t\t\t\tjQuery.clone( fragment, true, true ) :\n\t\t\t\t\t\t\tfragment\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( scripts.length ) {\n\t\t\t\tjQuery.each( scripts, evalScript );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\nfunction root( elem, cur ) {\n\treturn jQuery.nodeName(elem, \"table\") ?\n\t\t(elem.getElementsByTagName(\"tbody\")[0] ||\n\t\telem.appendChild(elem.ownerDocument.createElement(\"tbody\"))) :\n\t\telem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\n\tif ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {\n\t\treturn;\n\t}\n\n\tvar internalKey = jQuery.expando,\n\t\toldData = jQuery.data( src ),\n\t\tcurData = jQuery.data( dest, oldData );\n\n\t// Switch to use the internal data object, if it exists, for the next\n\t// stage of data copying\n\tif ( (oldData = oldData[ internalKey ]) ) {\n\t\tvar events = oldData.events;\n\t\t\t\tcurData = curData[ internalKey ] = jQuery.extend({}, oldData);\n\n\t\tif ( events ) {\n\t\t\tdelete curData.handle;\n\t\t\tcurData.events = {};\n\n\t\t\tfor ( var type in events ) {\n\t\t\t\tfor ( var i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? \".\" : \"\" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction cloneFixAttributes(src, dest) {\n\t// We do not need to do anything for non-Elements\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// clearAttributes removes the attributes, which we don't want,\n\t// but also removes the attachEvent events, which we *do* want\n\tdest.clearAttributes();\n\n\t// mergeAttributes, in contrast, only merges back on the\n\t// original attributes, not the events\n\tdest.mergeAttributes(src);\n\n\t// IE6-8 fail to clone children inside object elements that use\n\t// the proprietary classid attribute value (rather than the type\n\t// attribute) to identify the type of content to display\n\tif ( nodeName === \"object\" ) {\n\t\tdest.outerHTML = src.outerHTML;\n\n\t} else if ( nodeName === \"input\" && (src.type === \"checkbox\" || src.type === \"radio\") ) {\n\t\t// IE6-8 fails to persist the checked state of a cloned checkbox\n\t\t// or radio button. Worse, IE6-7 fail to give the cloned element\n\t\t// a checked appearance if the defaultChecked value isn't also set\n\t\tif ( src.checked ) {\n\t\t\tdest.defaultChecked = dest.checked = src.checked;\n\t\t}\n\n\t\t// IE6-7 get confused and end up setting the value of a cloned\n\t\t// checkbox/radio button to an empty string instead of \"on\"\n\t\tif ( dest.value !== src.value ) {\n\t\t\tdest.value = src.value;\n\t\t}\n\n\t// IE6-8 fails to return the selected option to the default selected\n\t// state when cloning options\n\t} else if ( nodeName === \"option\" ) {\n\t\tdest.selected = src.defaultSelected;\n\n\t// IE6-8 fails to set the defaultValue to the correct value when\n\t// cloning other types of input fields\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n\n\t// Event data gets referenced instead of copied if the expando\n\t// gets copied too\n\tdest.removeAttribute( jQuery.expando );\n}\n\njQuery.buildFragment = function( args, nodes, scripts ) {\n\tvar fragment, cacheable, cacheresults,\n\t\tdoc = (nodes && nodes[0] ? nodes[0].ownerDocument || nodes[0] : document);\n\n\t// Only cache \"small\" (1/2 KB) HTML strings that are associated with the main document\n\t// Cloning options loses the selected state, so don't cache them\n\t// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment\n\t// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache\n\tif ( args.length === 1 && typeof args[0] === \"string\" && args[0].length < 512 && doc === document &&\n\t\targs[0].charAt(0) === \"<\" && !rnocache.test( args[0] ) && (jQuery.support.checkClone || !rchecked.test( args[0] )) ) {\n\n\t\tcacheable = true;\n\t\tcacheresults = jQuery.fragments[ args[0] ];\n\t\tif ( cacheresults ) {\n\t\t\tif ( cacheresults !== 1 ) {\n\t\t\t\tfragment = cacheresults;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( !fragment ) {\n\t\tfragment = doc.createDocumentFragment();\n\t\tjQuery.clean( args, doc, fragment, scripts );\n\t}\n\n\tif ( cacheable ) {\n\t\tjQuery.fragments[ args[0] ] = cacheresults ? fragment : 1;\n\t}\n\n\treturn { fragment: fragment, cacheable: cacheable };\n};\n\njQuery.fragments = {};\n\njQuery.each({\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar ret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tparent = this.length === 1 && this[0].parentNode;\n\n\t\tif ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {\n\t\t\tinsert[ original ]( this[0] );\n\t\t\treturn this;\n\n\t\t} else {\n\t\t\tfor ( var i = 0, l = insert.length; i < l; i++ ) {\n\t\t\t\tvar elems = (i > 0 ? this.clone(true) : this).get();\n\t\t\t\tjQuery( insert[i] )[ original ]( elems );\n\t\t\t\tret = ret.concat( elems );\n\t\t\t}\n\n\t\t\treturn this.pushStack( ret, name, insert.selector );\n\t\t}\n\t};\n});\n\nfunction getAll( elem ) {\n\tif ( \"getElementsByTagName\" in elem ) {\n\t\treturn elem.getElementsByTagName( \"*\" );\n\t\n\t} else if ( \"querySelectorAll\" in elem ) {\n\t\treturn elem.querySelectorAll( \"*\" );\n\n\t} else {\n\t\treturn [];\n\t}\n}\n\njQuery.extend({\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar clone = elem.cloneNode(true),\n\t\t\t\tsrcElements,\n\t\t\t\tdestElements,\n\t\t\t\ti;\n\n\t\tif ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&\n\t\t\t\t(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {\n\t\t\t// IE copies events bound via attachEvent when using cloneNode.\n\t\t\t// Calling detachEvent on the clone will also remove the events\n\t\t\t// from the original. In order to get around this, we use some\n\t\t\t// proprietary methods to clear the events. Thanks to MooTools\n\t\t\t// guys for this hotness.\n\n\t\t\tcloneFixAttributes( elem, clone );\n\n\t\t\t// Using Sizzle here is crazy slow, so we use getElementsByTagName\n\t\t\t// instead\n\t\t\tsrcElements = getAll( elem );\n\t\t\tdestElements = getAll( clone );\n\n\t\t\t// Weird iteration because IE will replace the length property\n\t\t\t// with an element if you are cloning the body and one of the\n\t\t\t// elements on the page has a name or id of \"length\"\n\t\t\tfor ( i = 0; srcElements[i]; ++i ) {\n\t\t\t\tcloneFixAttributes( srcElements[i], destElements[i] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tcloneCopyEvent( elem, clone );\n\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = getAll( elem );\n\t\t\t\tdestElements = getAll( clone );\n\n\t\t\t\tfor ( i = 0; srcElements[i]; ++i ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[i], destElements[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n},\n\tclean: function( elems, context, fragment, scripts ) {\n\t\tcontext = context || document;\n\n\t\t// !context.createElement fails in IE with an error but returns typeof 'object'\n\t\tif ( typeof context.createElement === \"undefined\" ) {\n\t\t\tcontext = context.ownerDocument || context[0] && context[0].ownerDocument || document;\n\t\t}\n\n\t\tvar ret = [];\n\n\t\tfor ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( typeof elem === \"number\" ) {\n\t\t\t\telem += \"\";\n\t\t\t}\n\n\t\t\tif ( !elem ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Convert html string into DOM nodes\n\t\t\tif ( typeof elem === \"string\" && !rhtml.test( elem ) ) {\n\t\t\t\telem = context.createTextNode( elem );\n\n\t\t\t} else if ( typeof elem === \"string\" ) {\n\t\t\t\t// Fix \"XHTML\"-style tags in all browsers\n\t\t\t\telem = elem.replace(rxhtmlTag, \"<$1></$2>\");\n\n\t\t\t\t// Trim whitespace, otherwise indexOf won't work as expected\n\t\t\t\tvar tag = (rtagName.exec( elem ) || [\"\", \"\"])[1].toLowerCase(),\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default,\n\t\t\t\t\tdepth = wrap[0],\n\t\t\t\t\tdiv = context.createElement(\"div\");\n\n\t\t\t\t// Go to html and back, then peel off extra wrappers\n\t\t\t\tdiv.innerHTML = wrap[1] + elem + wrap[2];\n\n\t\t\t\t// Move to the right depth\n\t\t\t\twhile ( depth-- ) {\n\t\t\t\t\tdiv = div.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Remove IE's autoinserted <tbody> from table fragments\n\t\t\t\tif ( !jQuery.support.tbody ) {\n\n\t\t\t\t\t// String was a <table>, *may* have spurious <tbody>\n\t\t\t\t\tvar hasBody = rtbody.test(elem),\n\t\t\t\t\t\ttbody = tag === \"table\" && !hasBody ?\n\t\t\t\t\t\t\tdiv.firstChild && div.firstChild.childNodes :\n\n\t\t\t\t\t\t\t// String was a bare <thead> or <tfoot>\n\t\t\t\t\t\t\twrap[1] === \"<table>\" && !hasBody ?\n\t\t\t\t\t\t\t\tdiv.childNodes :\n\t\t\t\t\t\t\t\t[];\n\n\t\t\t\t\tfor ( var j = tbody.length - 1; j >= 0 ; --j ) {\n\t\t\t\t\t\tif ( jQuery.nodeName( tbody[ j ], \"tbody\" ) && !tbody[ j ].childNodes.length ) {\n\t\t\t\t\t\t\ttbody[ j ].parentNode.removeChild( tbody[ j ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// IE completely kills leading whitespace when innerHTML is used\n\t\t\t\tif ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {\n\t\t\t\t\tdiv.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );\n\t\t\t\t}\n\n\t\t\t\telem = div.childNodes;\n\t\t\t}\n\n\t\t\tif ( elem.nodeType ) {\n\t\t\t\tret.push( elem );\n\t\t\t} else {\n\t\t\t\tret = jQuery.merge( ret, elem );\n\t\t\t}\n\t\t}\n\n\t\tif ( fragment ) {\n\t\t\tfor ( i = 0; ret[i]; i++ ) {\n\t\t\t\tif ( scripts && jQuery.nodeName( ret[i], \"script\" ) && (!ret[i].type || ret[i].type.toLowerCase() === \"text/javascript\") ) {\n\t\t\t\t\tscripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );\n\n\t\t\t\t} else {\n\t\t\t\t\tif ( ret[i].nodeType === 1 ) {\n\t\t\t\t\t\tret.splice.apply( ret, [i + 1, 0].concat(jQuery.makeArray(ret[i].getElementsByTagName(\"script\"))) );\n\t\t\t\t\t}\n\t\t\t\t\tfragment.appendChild( ret[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, id, cache = jQuery.cache, internalKey = jQuery.expando, special = jQuery.event.special,\n\t\t\tdeleteExpando = jQuery.support.deleteExpando;\n\n\t\tfor ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tid = elem[ jQuery.expando ];\n\n\t\t\tif ( id ) {\n\t\t\t\tdata = cache[ id ] && cache[ id ][ internalKey ];\n\n\t\t\t\tif ( data && data.events ) {\n\t\t\t\t\tfor ( var type in data.events ) {\n\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Null the DOM reference to avoid IE6/7/8 leak (#7054)\n\t\t\t\t\tif ( data.handle ) {\n\t\t\t\t\t\tdata.handle.elem = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( deleteExpando ) {\n\t\t\t\t\tdelete elem[ jQuery.expando ];\n\n\t\t\t\t} else if ( elem.removeAttribute ) {\n\t\t\t\t\telem.removeAttribute( jQuery.expando );\n\t\t\t\t}\n\n\t\t\t\tdelete cache[ id ];\n\t\t\t}\n\t\t}\n\t}\n});\n\nfunction evalScript( i, elem ) {\n\tif ( elem.src ) {\n\t\tjQuery.ajax({\n\t\t\turl: elem.src,\n\t\t\tasync: false,\n\t\t\tdataType: \"script\"\n\t\t});\n\t} else {\n\t\tjQuery.globalEval( elem.text || elem.textContent || elem.innerHTML || \"\" );\n\t}\n\n\tif ( elem.parentNode ) {\n\t\telem.parentNode.removeChild( elem );\n\t}\n}\n\n\n\n\nvar ralpha = /alpha\\([^)]*\\)/i,\n\tropacity = /opacity=([^)]*)/,\n\trdashAlpha = /-([a-z])/ig,\n\trupper = /([A-Z])/g,\n\trnumpx = /^-?\\d+(?:px)?$/i,\n\trnum = /^-?\\d/,\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssWidth = [ \"Left\", \"Right\" ],\n\tcssHeight = [ \"Top\", \"Bottom\" ],\n\tcurCSS,\n\n\tgetComputedStyle,\n\tcurrentStyle,\n\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn.css = function( name, value ) {\n\t// Setting 'undefined' is a no-op\n\tif ( arguments.length === 2 && value === undefined ) {\n\t\treturn this;\n\t}\n\n\treturn jQuery.access( this, name, value, true, function( elem, name, value ) {\n\t\treturn value !== undefined ?\n\t\t\tjQuery.style( elem, name, value ) :\n\t\t\tjQuery.css( elem, name );\n\t});\n};\n\njQuery.extend({\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\", \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\n\t\t\t\t} else {\n\t\t\t\t\treturn elem.style.opacity;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Exclude the following css properties to add px\n\tcssNumber: {\n\t\t\"zIndex\": true,\n\t\t\"fontWeight\": true,\n\t\t\"opacity\": true,\n\t\t\"zoom\": true,\n\t\t\"lineHeight\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t// normalize float css property\n\t\t\"float\": jQuery.support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, origName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style, hooks = jQuery.cssHooks[ origName ];\n\n\t\tname = jQuery.cssProps[ origName ] || origName;\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\t// Make sure that NaN and null values aren't set. See: #7116\n\t\t\tif ( typeof value === \"number\" && isNaN( value ) || value == null ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\n\t\t\tif ( typeof value === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\tvalue += \"px\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {\n\t\t\t\t// Wrapped to prevent IE from throwing errors when 'invalid' values are provided\n\t\t\t\t// Fixes bug #5509\n\t\t\t\ttry {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\n\t\t} else {\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra ) {\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, origName = jQuery.camelCase( name ),\n\t\t\thooks = jQuery.cssHooks[ origName ];\n\n\t\tname = jQuery.cssProps[ origName ] || origName;\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {\n\t\t\treturn ret;\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\t} else if ( curCSS ) {\n\t\t\treturn curCSS( elem, name, origName );\n\t\t}\n\t},\n\n\t// A method for quickly swapping in/out CSS properties to get correct calculations\n\tswap: function( elem, options, callback ) {\n\t\tvar old = {};\n\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( var name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\n\t\tcallback.call( elem );\n\n\t\t// Revert the old values\n\t\tfor ( name in options ) {\n\t\t\telem.style[ name ] = old[ name ];\n\t\t}\n\t},\n\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rdashAlpha, fcamelCase );\n\t}\n});\n\n// DEPRECATED, Use jQuery.css() instead\njQuery.curCSS = jQuery.css;\n\njQuery.each([\"height\", \"width\"], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tvar val;\n\n\t\t\tif ( computed ) {\n\t\t\t\tif ( elem.offsetWidth !== 0 ) {\n\t\t\t\t\tval = getWH( elem, name, extra );\n\n\t\t\t\t} else {\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\tval = getWH( elem, name, extra );\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif ( val <= 0 ) {\n\t\t\t\t\tval = curCSS( elem, name, name );\n\n\t\t\t\t\tif ( val === \"0px\" && currentStyle ) {\n\t\t\t\t\t\tval = currentStyle( elem, name, name );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( val != null ) {\n\t\t\t\t\t\t// Should return \"auto\" instead of 0, use 0 for\n\t\t\t\t\t\t// temporary backwards-compat\n\t\t\t\t\t\treturn val === \"\" || val === \"auto\" ? \"0px\" : val;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( val < 0 || val == null ) {\n\t\t\t\t\tval = elem.style[ name ];\n\n\t\t\t\t\t// Should return \"auto\" instead of 0, use 0 for\n\t\t\t\t\t// temporary backwards-compat\n\t\t\t\t\treturn val === \"\" || val === \"auto\" ? \"0px\" : val;\n\t\t\t\t}\n\n\t\t\t\treturn typeof val === \"string\" ? val : val + \"px\";\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value ) {\n\t\t\tif ( rnumpx.test( value ) ) {\n\t\t\t\t// ignore negative width and height values #1599\n\t\t\t\tvalue = parseFloat(value);\n\n\t\t\t\tif ( value >= 0 ) {\n\t\t\t\t\treturn value + \"px\";\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t};\n});\n\nif ( !jQuery.support.opacity ) {\n\tjQuery.cssHooks.opacity = {\n\t\tget: function( elem, computed ) {\n\t\t\t// IE uses filters for opacity\n\t\t\treturn ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || \"\") ?\n\t\t\t\t(parseFloat(RegExp.$1) / 100) + \"\" :\n\t\t\t\tcomputed ? \"1\" : \"\";\n\t\t},\n\n\t\tset: function( elem, value ) {\n\t\t\tvar style = elem.style;\n\n\t\t\t// IE has trouble with opacity if it does not have layout\n\t\t\t// Force it by setting the zoom level\n\t\t\tstyle.zoom = 1;\n\n\t\t\t// Set the alpha filter to set the opacity\n\t\t\tvar opacity = jQuery.isNaN(value) ?\n\t\t\t\t\"\" :\n\t\t\t\t\"alpha(opacity=\" + value * 100 + \")\",\n\t\t\t\tfilter = style.filter || \"\";\n\n\t\t\tstyle.filter = ralpha.test(filter) ?\n\t\t\t\tfilter.replace(ralpha, opacity) :\n\t\t\t\tstyle.filter + ' ' + opacity;\n\t\t}\n\t};\n}\n\nif ( document.defaultView && document.defaultView.getComputedStyle ) {\n\tgetComputedStyle = function( elem, newName, name ) {\n\t\tvar ret, defaultView, computedStyle;\n\n\t\tname = name.replace( rupper, \"-$1\" ).toLowerCase();\n\n\t\tif ( !(defaultView = elem.ownerDocument.defaultView) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif ( (computedStyle = defaultView.getComputedStyle( elem, null )) ) {\n\t\t\tret = computedStyle.getPropertyValue( name );\n\t\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {\n\t\t\t\tret = jQuery.style( elem, name );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t};\n}\n\nif ( document.documentElement.currentStyle ) {\n\tcurrentStyle = function( elem, name ) {\n\t\tvar left,\n\t\t\tret = elem.currentStyle && elem.currentStyle[ name ],\n\t\t\trsLeft = elem.runtimeStyle && elem.runtimeStyle[ name ],\n\t\t\tstyle = elem.style;\n\n\t\t// From the awesome hack by Dean Edwards\n\t\t// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n\t\t// If we're not dealing with a regular pixel number\n\t\t// but a number that has a weird ending, we need to convert it to pixels\n\t\tif ( !rnumpx.test( ret ) && rnum.test( ret ) ) {\n\t\t\t// Remember the original values\n\t\t\tleft = style.left;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tif ( rsLeft ) {\n\t\t\t\telem.runtimeStyle.left = elem.currentStyle.left;\n\t\t\t}\n\t\t\tstyle.left = name === \"fontSize\" ? \"1em\" : (ret || 0);\n\t\t\tret = style.pixelLeft + \"px\";\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.left = left;\n\t\t\tif ( rsLeft ) {\n\t\t\t\telem.runtimeStyle.left = rsLeft;\n\t\t\t}\n\t\t}\n\n\t\treturn ret === \"\" ? \"auto\" : ret;\n\t};\n}\n\ncurCSS = getComputedStyle || currentStyle;\n\nfunction getWH( elem, name, extra ) {\n\tvar which = name === \"width\" ? cssWidth : cssHeight,\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight;\n\n\tif ( extra === \"border\" ) {\n\t\treturn val;\n\t}\n\n\tjQuery.each( which, function() {\n\t\tif ( !extra ) {\n\t\t\tval -= parseFloat(jQuery.css( elem, \"padding\" + this )) || 0;\n\t\t}\n\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += parseFloat(jQuery.css( elem, \"margin\" + this )) || 0;\n\n\t\t} else {\n\t\t\tval -= parseFloat(jQuery.css( elem, \"border\" + this + \"Width\" )) || 0;\n\t\t}\n\t});\n\n\treturn val;\n}\n\nif ( jQuery.expr && jQuery.expr.filters ) {\n\tjQuery.expr.filters.hidden = function( elem ) {\n\t\tvar width = elem.offsetWidth,\n\t\t\theight = elem.offsetHeight;\n\n\t\treturn (width === 0 && height === 0) || (!jQuery.support.reliableHiddenOffsets && (elem.style.display || jQuery.css( elem, \"display\" )) === \"none\");\n\t};\n\n\tjQuery.expr.filters.visible = function( elem ) {\n\t\treturn !jQuery.expr.filters.hidden( elem );\n\t};\n}\n\n\n\n\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trhash = /#.*$/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg, // IE leaves an \\r character at EOL\n\trinput = /^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /(?:^file|^widget|\\-extension):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trquery = /\\?/,\n\trscript = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n\trselectTextarea = /^(?:select|textarea)/i,\n\trspacesAjax = /\\s+/,\n\trts = /([?&])_=[^&]*/,\n\trucHeaders = /(^|\\-)([a-z])/g,\n\trucHeadersFunc = function( _, $1, $2 ) {\n\t\treturn $1 + $2.toUpperCase();\n\t},\n\trurl = /^([\\w\\+\\.\\-]+:)\\/\\/([^\\/?#:]*)(?::(\\d+))?/,\n\n\t// Keep a copy of the old load method\n\t_load = jQuery.fn.load,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Document location\n\tajaxLocation,\n\n\t// Document location segments\n\tajaxLocParts;\n\n// #8138, IE may throw an exception when accessing\n// a field from document.location if document.domain has been set\ntry {\n\tajaxLocation = document.location.href;\n} catch( e ) {\n\t// Use the href attribute of an A element\n\t// since IE will modify it given document.location\n\tajaxLocation = document.createElement( \"a\" );\n\tajaxLocation.href = \"\";\n\tajaxLocation = ajaxLocation.href;\n}\n\n// Segment location into parts\najaxLocParts = rurl.exec( ajaxLocation.toLowerCase() );\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\tvar dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),\n\t\t\t\ti = 0,\n\t\t\t\tlength = dataTypes.length,\n\t\t\t\tdataType,\n\t\t\t\tlist,\n\t\t\t\tplaceBefore;\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\tfor(; i < length; i++ ) {\n\t\t\t\tdataType = dataTypes[ i ];\n\t\t\t\t// We control if we're asked to add before\n\t\t\t\t// any existing element\n\t\t\t\tplaceBefore = /^\\+/.test( dataType );\n\t\t\t\tif ( placeBefore ) {\n\t\t\t\t\tdataType = dataType.substr( 1 ) || \"*\";\n\t\t\t\t}\n\t\t\t\tlist = structure[ dataType ] = structure[ dataType ] || [];\n\t\t\t\t// then we add to the structure accordingly\n\t\t\t\tlist[ placeBefore ? \"unshift\" : \"push\" ]( func );\n\t\t\t}\n\t\t}\n\t};\n}\n\n//Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,\n\t\tdataType /* internal */, inspected /* internal */ ) {\n\n\tdataType = dataType || options.dataTypes[ 0 ];\n\tinspected = inspected || {};\n\n\tinspected[ dataType ] = true;\n\n\tvar list = structure[ dataType ],\n\t\ti = 0,\n\t\tlength = list ? list.length : 0,\n\t\texecuteOnly = ( structure === prefilters ),\n\t\tselection;\n\n\tfor(; i < length && ( executeOnly || !selection ); i++ ) {\n\t\tselection = list[ i ]( options, originalOptions, jqXHR );\n\t\t// If we got redirected to another dataType\n\t\t// we try there if executing only and not done already\n\t\tif ( typeof selection === \"string\" ) {\n\t\t\tif ( !executeOnly || inspected[ selection ] ) {\n\t\t\t\tselection = undefined;\n\t\t\t} else {\n\t\t\t\toptions.dataTypes.unshift( selection );\n\t\t\t\tselection = inspectPrefiltersOrTransports(\n\t\t\t\t\t\tstructure, options, originalOptions, jqXHR, selection, inspected );\n\t\t\t}\n\t\t}\n\t}\n\t// If we're only executing or nothing was selected\n\t// we try the catchall dataType if not done already\n\tif ( ( executeOnly || !selection ) && !inspected[ \"*\" ] ) {\n\t\tselection = inspectPrefiltersOrTransports(\n\t\t\t\tstructure, options, originalOptions, jqXHR, \"*\", inspected );\n\t}\n\t// unnecessary when only executing (prefilters)\n\t// but it'll be ignored by the caller in that case\n\treturn selection;\n}\n\njQuery.fn.extend({\n\tload: function( url, params, callback ) {\n\t\tif ( typeof url !== \"string\" && _load ) {\n\t\t\treturn _load.apply( this, arguments );\n\n\t\t// Don't do a request if no elements are being requested\n\t\t} else if ( !this.length ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tvar off = url.indexOf( \" \" );\n\t\tif ( off >= 0 ) {\n\t\t\tvar selector = url.slice( off, url.length );\n\t\t\turl = url.slice( 0, off );\n\t\t}\n\n\t\t// Default to a GET request\n\t\tvar type = \"GET\";\n\n\t\t// If the second parameter was provided\n\t\tif ( params ) {\n\t\t\t// If it's a function\n\t\t\tif ( jQuery.isFunction( params ) ) {\n\t\t\t\t// We assume that it's the callback\n\t\t\t\tcallback = params;\n\t\t\t\tparams = undefined;\n\n\t\t\t// Otherwise, build a param string\n\t\t\t} else if ( typeof params === \"object\" ) {\n\t\t\t\tparams = jQuery.param( params, jQuery.ajaxSettings.traditional );\n\t\t\t\ttype = \"POST\";\n\t\t\t}\n\t\t}\n\n\t\tvar self = this;\n\n\t\t// Request the remote document\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params,\n\t\t\t// Complete callback (responseText is used internally)\n\t\t\tcomplete: function( jqXHR, status, responseText ) {\n\t\t\t\t// Store the response as specified by the jqXHR object\n\t\t\t\tresponseText = jqXHR.responseText;\n\t\t\t\t// If successful, inject the HTML into all the matched elements\n\t\t\t\tif ( jqXHR.isResolved() ) {\n\t\t\t\t\t// #4825: Get the actual response in case\n\t\t\t\t\t// a dataFilter is present in ajaxSettings\n\t\t\t\t\tjqXHR.done(function( r ) {\n\t\t\t\t\t\tresponseText = r;\n\t\t\t\t\t});\n\t\t\t\t\t// See if a selector was specified\n\t\t\t\t\tself.html( selector ?\n\t\t\t\t\t\t// Create a dummy div to hold the results\n\t\t\t\t\t\tjQuery(\"<div>\")\n\t\t\t\t\t\t\t// inject the contents of the document in, removing the scripts\n\t\t\t\t\t\t\t// to avoid any 'Permission Denied' errors in IE\n\t\t\t\t\t\t\t.append(responseText.replace(rscript, \"\"))\n\n\t\t\t\t\t\t\t// Locate the specified elements\n\t\t\t\t\t\t\t.find(selector) :\n\n\t\t\t\t\t\t// If not, just inject the full result\n\t\t\t\t\t\tresponseText );\n\t\t\t\t}\n\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tself.each( callback, [ responseText, status, jqXHR ] );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t},\n\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\n\tserializeArray: function() {\n\t\treturn this.map(function(){\n\t\t\treturn this.elements ? jQuery.makeArray( this.elements ) : this;\n\t\t})\n\t\t.filter(function(){\n\t\t\treturn this.name && !this.disabled &&\n\t\t\t\t( this.checked || rselectTextarea.test( this.nodeName ) ||\n\t\t\t\t\trinput.test( this.type ) );\n\t\t})\n\t\t.map(function( i, elem ){\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val, i ){\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t}) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t}).get();\n\t}\n});\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( \"ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend\".split( \" \" ), function( i, o ){\n\tjQuery.fn[ o ] = function( f ){\n\t\treturn this.bind( o, f );\n\t};\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\ttype: method,\n\t\t\turl: url,\n\t\t\tdata: data,\n\t\t\tsuccess: callback,\n\t\t\tdataType: type\n\t\t});\n\t};\n} );\n\njQuery.extend({\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function ( target, settings ) {\n\t\tif ( !settings ) {\n\t\t\t// Only one parameter, we extend ajaxSettings\n\t\t\tsettings = target;\n\t\t\ttarget = jQuery.extend( true, jQuery.ajaxSettings, settings );\n\t\t} else {\n\t\t\t// target was provided, we extend into it\n\t\t\tjQuery.extend( true, target, jQuery.ajaxSettings, settings );\n\t\t}\n\t\t// Flatten fields we don't want deep extended\n\t\tfor( var field in { context: 1, url: 1 } ) {\n\t\t\tif ( field in settings ) {\n\t\t\t\ttarget[ field ] = settings[ field ];\n\t\t\t} else if( field in jQuery.ajaxSettings ) {\n\t\t\t\ttarget[ field ] = jQuery.ajaxSettings[ field ];\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\ttype: \"GET\",\n\t\tcontentType: \"application/x-www-form-urlencoded\",\n\t\tprocessData: true,\n\t\tasync: true,\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\tcrossDomain: null,\n\t\t*/\n\n\t\taccepts: {\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\thtml: \"text/html\",\n\t\t\ttext: \"text/plain\",\n\t\t\tjson: \"application/json, text/javascript\",\n\t\t\t\"*\": \"*/*\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\"\n\t\t},\n\n\t\t// List of data converters\n\t\t// 1) key format is \"source_type destination_type\" (a single space in-between)\n\t\t// 2) the catchall symbol \"*\" can be used for source_type\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": window.String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t}\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar // Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events\n\t\t\t// It's the callbackContext if one was provided in the options\n\t\t\t// and if it's a DOM node or a jQuery collection\n\t\t\tglobalEventContext = callbackContext !== s &&\n\t\t\t\t( callbackContext.nodeType || callbackContext instanceof jQuery ) ?\n\t\t\t\t\t\tjQuery( callbackContext ) : jQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery._Deferred(),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// ifModified key\n\t\t\tifModifiedKey,\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\t\t\t// transport\n\t\t\ttransport,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\t\t\t// Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\trequestHeaders[ name.toLowerCase().replace( rucHeaders, rucHeadersFunc ) ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match === undefined ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tstatusText = statusText || \"abort\";\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( statusText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, statusText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Callback for when everything is done\n\t\t// It is defined here because jslint complains if it is declared\n\t\t// at the end of the function (which would be more logical and readable)\n\t\tfunction done( status, statusText, responses, headers ) {\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status ? 4 : 0;\n\n\t\t\tvar isSuccess,\n\t\t\t\tsuccess,\n\t\t\t\terror,\n\t\t\t\tresponse = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,\n\t\t\t\tlastModified,\n\t\t\t\tetag;\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( status >= 200 && status < 300 || status === 304 ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\n\t\t\t\t\tif ( ( lastModified = jqXHR.getResponseHeader( \"Last-Modified\" ) ) ) {\n\t\t\t\t\t\tjQuery.lastModified[ ifModifiedKey ] = lastModified;\n\t\t\t\t\t}\n\t\t\t\t\tif ( ( etag = jqXHR.getResponseHeader( \"Etag\" ) ) ) {\n\t\t\t\t\t\tjQuery.etag[ ifModifiedKey ] = etag;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If not modified\n\t\t\t\tif ( status === 304 ) {\n\n\t\t\t\t\tstatusText = \"notmodified\";\n\t\t\t\t\tisSuccess = true;\n\n\t\t\t\t// If we have data\n\t\t\t\t} else {\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsuccess = ajaxConvert( s, response );\n\t\t\t\t\t\tstatusText = \"success\";\n\t\t\t\t\t\tisSuccess = true;\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t// We have a parsererror\n\t\t\t\t\t\tstatusText = \"parsererror\";\n\t\t\t\t\t\terror = e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We extract error from statusText\n\t\t\t\t// then normalize statusText and status for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif( !statusText || status ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = statusText;\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajax\" + ( isSuccess ? \"Success\" : \"Error\" ),\n\t\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.resolveWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\t\tjqXHR.complete = completeDeferred.done;\n\n\t\t// Status-dependent callbacks\n\t\tjqXHR.statusCode = function( map ) {\n\t\t\tif ( map ) {\n\t\t\t\tvar tmp;\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tfor( tmp in map ) {\n\t\t\t\t\t\tstatusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttmp = map[ jqXHR.status ];\n\t\t\t\t\tjqXHR.then( tmp, tmp );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t};\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url ) + \"\" ).replace( rhash, \"\" ).replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().split( rspacesAjax );\n\n\t\t// Determine if a cross-domain request is in order\n\t\tif ( !s.crossDomain ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? 80 : 443 ) ) !=\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? 80 : 443 ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefiler, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\tfireGlobals = s.global;\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.data;\n\t\t\t}\n\n\t\t\t// Get ifModifiedKey before adding the anti-cache parameter\n\t\t\tifModifiedKey = s.url;\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\n\t\t\t\tvar ts = jQuery.now(),\n\t\t\t\t\t// try replacing _= if it is there\n\t\t\t\t\tret = s.url.replace( rts, \"$1_=\" + ts );\n\n\t\t\t\t// if nothing was replaced, add timestamp to the end\n\t\t\t\ts.url = ret + ( (ret === s.url ) ? ( rquery.test( s.url ) ? \"&\" : \"?\" ) + \"_=\" + ts : \"\" );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\trequestHeaders[ \"Content-Type\" ] = s.contentType;\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tifModifiedKey = ifModifiedKey || s.url;\n\t\t\tif ( jQuery.lastModified[ ifModifiedKey ] ) {\n\t\t\t\trequestHeaders[ \"If-Modified-Since\" ] = jQuery.lastModified[ ifModifiedKey ];\n\t\t\t}\n\t\t\tif ( jQuery.etag[ ifModifiedKey ] ) {\n\t\t\t\trequestHeaders[ \"If-None-Match\" ] = jQuery.etag[ ifModifiedKey ];\n\t\t\t}\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\trequestHeaders.Accept = s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", */*; q=0.01\" : \"\" ) :\n\t\t\ts.accepts[ \"*\" ];\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t\t// Abort if not done already\n\t\t\t\tjqXHR.abort();\n\t\t\t\treturn false;\n\n\t\t}\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout( function(){\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch (e) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( status < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tjQuery.error( e );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\t// Serialize an array of form elements or a set of\n\t// key/values into a query string\n\tparam: function( a, traditional ) {\n\t\tvar s = [],\n\t\t\tadd = function( key, value ) {\n\t\t\t\t// If value is a function, invoke it and return its value\n\t\t\t\tvalue = jQuery.isFunction( value ) ? value() : value;\n\t\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t\t};\n\n\t\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\t\tif ( traditional === undefined ) {\n\t\t\ttraditional = jQuery.ajaxSettings.traditional;\n\t\t}\n\n\t\t// If an array was passed in, assume that it is an array of form elements.\n\t\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t\t// Serialize the form elements\n\t\t\tjQuery.each( a, function() {\n\t\t\t\tadd( this.name, this.value );\n\t\t\t} );\n\n\t\t} else {\n\t\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t\t// did it), otherwise encode params recursively.\n\t\t\tfor ( var prefix in a ) {\n\t\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t\t}\n\t\t}\n\n\t\t// Return the resulting serialization\n\t\treturn s.join( \"&\" ).replace( r20, \"+\" );\n\t}\n});\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tif ( jQuery.isArray( obj ) && obj.length ) {\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\t\t\t\t// If array item is non-scalar (array or object), encode its\n\t\t\t\t// numeric index to resolve deserialization ambiguity issues.\n\t\t\t\t// Note that rack (as of 1.0.0) can't currently deserialize\n\t\t\t\t// nested arrays properly, and attempting to do so may cause\n\t\t\t\t// a server error. Possible fixes are to modify rack's\n\t\t\t\t// deserialization algorithm or to provide an option or flag\n\t\t\t\t// to force array serialization to be shallow.\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" || jQuery.isArray(v) ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t}\n\t\t});\n\n\t} else if ( !traditional && obj != null && typeof obj === \"object\" ) {\n\t\t// If we see an array here, it is empty and should be treated as an empty\n\t\t// object\n\t\tif ( jQuery.isArray( obj ) || jQuery.isEmptyObject( obj ) ) {\n\t\t\tadd( prefix, \"\" );\n\n\t\t// Serialize object item.\n\t\t} else {\n\t\t\tfor ( var name in obj ) {\n\t\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// This is still on the jQuery object... for now\n// Want to move this to jQuery.ajax some day\njQuery.extend({\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {}\n\n});\n\n/* Handles responses to an ajax request:\n * - sets all responseXXX fields accordingly\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar contents = s.contents,\n\t\tdataTypes = s.dataTypes,\n\t\tresponseFields = s.responseFields,\n\t\tct,\n\t\ttype,\n\t\tfinalDataType,\n\t\tfirstDataType;\n\n\t// Fill responseXXX fields\n\tfor( type in responseFields ) {\n\t\tif ( type in responses ) {\n\t\t\tjqXHR[ responseFields[type] ] = responses[ type ];\n\t\t}\n\t}\n\n\t// Remove auto dataType and get content-type in the process\n\twhile( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"content-type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n// Chain conversions given the request and the original response\nfunction ajaxConvert( s, response ) {\n\n\t// Apply the dataFilter if provided\n\tif ( s.dataFilter ) {\n\t\tresponse = s.dataFilter( response, s.dataType );\n\t}\n\n\tvar dataTypes = s.dataTypes,\n\t\tconverters = {},\n\t\ti,\n\t\tkey,\n\t\tlength = dataTypes.length,\n\t\ttmp,\n\t\t// Current and previous dataTypes\n\t\tcurrent = dataTypes[ 0 ],\n\t\tprev,\n\t\t// Conversion expression\n\t\tconversion,\n\t\t// Conversion function\n\t\tconv,\n\t\t// Conversion functions (transitive conversion)\n\t\tconv1,\n\t\tconv2;\n\n\t// For each dataType in the chain\n\tfor( i = 1; i < length; i++ ) {\n\n\t\t// Create converters map\n\t\t// with lowercased keys\n\t\tif ( i === 1 ) {\n\t\t\tfor( key in s.converters ) {\n\t\t\t\tif( typeof key === \"string\" ) {\n\t\t\t\t\tconverters[ key.toLowerCase() ] = s.converters[ key ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Get the dataTypes\n\t\tprev = current;\n\t\tcurrent = dataTypes[ i ];\n\n\t\t// If current is auto dataType, update it to prev\n\t\tif( current === \"*\" ) {\n\t\t\tcurrent = prev;\n\t\t// If no auto and dataTypes are actually different\n\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t// Get the converter\n\t\t\tconversion = prev + \" \" + current;\n\t\t\tconv = converters[ conversion ] || converters[ \"* \" + current ];\n\n\t\t\t// If there is no direct converter, search transitively\n\t\t\tif ( !conv ) {\n\t\t\t\tconv2 = undefined;\n\t\t\t\tfor( conv1 in converters ) {\n\t\t\t\t\ttmp = conv1.split( \" \" );\n\t\t\t\t\tif ( tmp[ 0 ] === prev || tmp[ 0 ] === \"*\" ) {\n\t\t\t\t\t\tconv2 = converters[ tmp[1] + \" \" + current ];\n\t\t\t\t\t\tif ( conv2 ) {\n\t\t\t\t\t\t\tconv1 = converters[ conv1 ];\n\t\t\t\t\t\t\tif ( conv1 === true ) {\n\t\t\t\t\t\t\t\tconv = conv2;\n\t\t\t\t\t\t\t} else if ( conv2 === true ) {\n\t\t\t\t\t\t\t\tconv = conv1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If we found no converter, dispatch an error\n\t\t\tif ( !( conv || conv2 ) ) {\n\t\t\t\tjQuery.error( \"No conversion from \" + conversion.replace(\" \",\" to \") );\n\t\t\t}\n\t\t\t// If found converter is not an equivalence\n\t\t\tif ( conv !== true ) {\n\t\t\t\t// Convert with 1 or 2 converters accordingly\n\t\t\t\tresponse = conv ? conv( response ) : conv2( conv1(response) );\n\t\t\t}\n\t\t}\n\t}\n\treturn response;\n}\n\n\n\n\nvar jsc = jQuery.now(),\n\tjsre = /(\\=)\\?(&|$)|()\\?\\?()/i;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\treturn jQuery.expando + \"_\" + ( jsc++ );\n\t}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar dataIsString = ( typeof s.data === \"string\" );\n\n\tif ( s.dataTypes[ 0 ] === \"jsonp\" ||\n\t\toriginalSettings.jsonpCallback ||\n\t\toriginalSettings.jsonp != null ||\n\t\ts.jsonp !== false && ( jsre.test( s.url ) ||\n\t\t\t\tdataIsString && jsre.test( s.data ) ) ) {\n\n\t\tvar responseContainer,\n\t\t\tjsonpCallback = s.jsonpCallback =\n\t\t\t\tjQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,\n\t\t\tprevious = window[ jsonpCallback ],\n\t\t\turl = s.url,\n\t\t\tdata = s.data,\n\t\t\treplace = \"$1\" + jsonpCallback + \"$2\",\n\t\t\tcleanUp = function() {\n\t\t\t\t// Set callback back to previous value\n\t\t\t\twindow[ jsonpCallback ] = previous;\n\t\t\t\t// Call if it was a function and we have a response\n\t\t\t\tif ( responseContainer && jQuery.isFunction( previous ) ) {\n\t\t\t\t\twindow[ jsonpCallback ]( responseContainer[ 0 ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( s.jsonp !== false ) {\n\t\t\turl = url.replace( jsre, replace );\n\t\t\tif ( s.url === url ) {\n\t\t\t\tif ( dataIsString ) {\n\t\t\t\t\tdata = data.replace( jsre, replace );\n\t\t\t\t}\n\t\t\t\tif ( s.data === data ) {\n\t\t\t\t\t// Add callback manually\n\t\t\t\t\turl += (/\\?/.test( url ) ? \"&\" : \"?\") + s.jsonp + \"=\" + jsonpCallback;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ts.url = url;\n\t\ts.data = data;\n\n\t\t// Install callback\n\t\twindow[ jsonpCallback ] = function( response ) {\n\t\t\tresponseContainer = [ response ];\n\t\t};\n\n\t\t// Install cleanUp function\n\t\tjqXHR.then( cleanUp, cleanUp );\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[\"script json\"] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( jsonpCallback + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Install script dataType\njQuery.ajaxSetup({\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /javascript|ecmascript/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n});\n\n// Handle cache's special case and global\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t\ts.global = false;\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function(s) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\n\t\tvar script,\n\t\t\thead = document.head || document.getElementsByTagName( \"head\" )[0] || document.documentElement;\n\n\t\treturn {\n\n\t\t\tsend: function( _, callback ) {\n\n\t\t\t\tscript = document.createElement( \"script\" );\n\n\t\t\t\tscript.async = \"async\";\n\n\t\t\t\tif ( s.scriptCharset ) {\n\t\t\t\t\tscript.charset = s.scriptCharset;\n\t\t\t\t}\n\n\t\t\t\tscript.src = s.url;\n\n\t\t\t\t// Attach handlers for all browsers\n\t\t\t\tscript.onload = script.onreadystatechange = function( _, isAbort ) {\n\n\t\t\t\t\tif ( !script.readyState || /loaded|complete/.test( script.readyState ) ) {\n\n\t\t\t\t\t\t// Handle memory leak in IE\n\t\t\t\t\t\tscript.onload = script.onreadystatechange = null;\n\n\t\t\t\t\t\t// Remove the script\n\t\t\t\t\t\tif ( head && script.parentNode ) {\n\t\t\t\t\t\t\thead.removeChild( script );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Dereference the script\n\t\t\t\t\t\tscript = undefined;\n\n\t\t\t\t\t\t// Callback if not abort\n\t\t\t\t\t\tif ( !isAbort ) {\n\t\t\t\t\t\t\tcallback( 200, \"success\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t// Use insertBefore instead of appendChild  to circumvent an IE6 bug.\n\t\t\t\t// This arises when a base node is used (#2709 and #4378).\n\t\t\t\thead.insertBefore( script, head.firstChild );\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( script ) {\n\t\t\t\t\tscript.onload( 0, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar // #5280: next active xhr id and list of active xhrs' callbacks\n\txhrId = jQuery.now(),\n\txhrCallbacks,\n\n\t// XHR used to determine supports properties\n\ttestXHR;\n\n// #5280: Internet Explorer will keep connections alive if we don't abort on unload\nfunction xhrOnUnloadAbort() {\n\tjQuery( window ).unload(function() {\n\t\t// Abort all pending requests\n\t\tfor ( var key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]( 0, 1 );\n\t\t}\n\t});\n}\n\n// Functions to create xhrs\nfunction createStandardXHR() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch( e ) {}\n}\n\nfunction createActiveXHR() {\n\ttry {\n\t\treturn new window.ActiveXObject( \"Microsoft.XMLHTTP\" );\n\t} catch( e ) {}\n}\n\n// Create the request object\n// (This is still attached to ajaxSettings for backward compatibility)\njQuery.ajaxSettings.xhr = window.ActiveXObject ?\n\t/* Microsoft failed to properly\n\t * implement the XMLHttpRequest in IE7 (can't request local files),\n\t * so we use the ActiveXObject when it is available\n\t * Additionally XMLHttpRequest can be disabled in IE7/IE8 so\n\t * we need a fallback.\n\t */\n\tfunction() {\n\t\treturn !this.isLocal && createStandardXHR() || createActiveXHR();\n\t} :\n\t// For all other browsers, use the standard XMLHttpRequest object\n\tcreateStandardXHR;\n\n// Test if we can create an xhr object\ntestXHR = jQuery.ajaxSettings.xhr();\njQuery.support.ajax = !!testXHR;\n\n// Does this browser support crossDomain XHR requests\njQuery.support.cors = testXHR && ( \"withCredentials\" in testXHR );\n\n// No need for the temporary xhr anymore\ntestXHR = undefined;\n\n// Create transport if the browser can provide an xhr\nif ( jQuery.support.ajax ) {\n\n\tjQuery.ajaxTransport(function( s ) {\n\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\tif ( !s.crossDomain || jQuery.support.cors ) {\n\n\t\t\tvar callback;\n\n\t\t\treturn {\n\t\t\t\tsend: function( headers, complete ) {\n\n\t\t\t\t\t// Get a new xhr\n\t\t\t\t\tvar xhr = s.xhr(),\n\t\t\t\t\t\thandle,\n\t\t\t\t\t\ti;\n\n\t\t\t\t\t// Open the socket\n\t\t\t\t\t// Passing null username, generates a login popup on Opera (#2865)\n\t\t\t\t\tif ( s.username ) {\n\t\t\t\t\t\txhr.open( s.type, s.url, s.async, s.username, s.password );\n\t\t\t\t\t} else {\n\t\t\t\t\t\txhr.open( s.type, s.url, s.async );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\tif ( s.xhrFields ) {\n\t\t\t\t\t\tfor ( i in s.xhrFields ) {\n\t\t\t\t\t\t\txhr[ i ] = s.xhrFields[ i ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\tif ( s.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\t\txhr.overrideMimeType( s.mimeType );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Requested-With header\n\t\t\t\t\t// Not set for crossDomain requests with no content\n\t\t\t\t\t// (see why at http://trac.dojotoolkit.org/ticket/9486)\n\t\t\t\t\t// Won't change header if already provided\n\t\t\t\t\tif ( !( s.crossDomain && !s.hasContent ) && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Need an extra try/catch for cross domain requests in Firefox 3\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch( _ ) {}\n\n\t\t\t\t\t// Do send the request\n\t\t\t\t\t// This may raise an exception which is actually\n\t\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\n\t\t\t\t\txhr.send( ( s.hasContent && s.data ) || null );\n\n\t\t\t\t\t// Listener\n\t\t\t\t\tcallback = function( _, isAbort ) {\n\n\t\t\t\t\t\tvar status,\n\t\t\t\t\t\t\tstatusText,\n\t\t\t\t\t\t\tresponseHeaders,\n\t\t\t\t\t\t\tresponses,\n\t\t\t\t\t\t\txml;\n\n\t\t\t\t\t\t// Firefox throws exceptions when accessing properties\n\t\t\t\t\t\t// of an xhr when a network error occured\n\t\t\t\t\t\t// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\t// Was never called and is aborted or complete\n\t\t\t\t\t\t\tif ( callback && ( isAbort || xhr.readyState === 4 ) ) {\n\n\t\t\t\t\t\t\t\t// Only called once\n\t\t\t\t\t\t\t\tcallback = undefined;\n\n\t\t\t\t\t\t\t\t// Do not keep as active anymore\n\t\t\t\t\t\t\t\tif ( handle ) {\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = jQuery.noop;\n\t\t\t\t\t\t\t\t\tdelete xhrCallbacks[ handle ];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// If it's an abort\n\t\t\t\t\t\t\t\tif ( isAbort ) {\n\t\t\t\t\t\t\t\t\t// Abort it manually if needed\n\t\t\t\t\t\t\t\t\tif ( xhr.readyState !== 4 ) {\n\t\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tstatus = xhr.status;\n\t\t\t\t\t\t\t\t\tresponseHeaders = xhr.getAllResponseHeaders();\n\t\t\t\t\t\t\t\t\tresponses = {};\n\t\t\t\t\t\t\t\t\txml = xhr.responseXML;\n\n\t\t\t\t\t\t\t\t\t// Construct response list\n\t\t\t\t\t\t\t\t\tif ( xml && xml.documentElement /* #4958 */ ) {\n\t\t\t\t\t\t\t\t\t\tresponses.xml = xml;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tresponses.text = xhr.responseText;\n\n\t\t\t\t\t\t\t\t\t// Firefox throws an exception when accessing\n\t\t\t\t\t\t\t\t\t// statusText for faulty cross-domain requests\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tstatusText = xhr.statusText;\n\t\t\t\t\t\t\t\t\t} catch( e ) {\n\t\t\t\t\t\t\t\t\t\t// We normalize with Webkit giving an empty statusText\n\t\t\t\t\t\t\t\t\t\tstatusText = \"\";\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Filter status for non standard behaviors\n\n\t\t\t\t\t\t\t\t\t// If the request is local and we have data: assume a success\n\t\t\t\t\t\t\t\t\t// (success with no data won't get notified, that's the best we\n\t\t\t\t\t\t\t\t\t// can do given current implementations)\n\t\t\t\t\t\t\t\t\tif ( !status && s.isLocal && !s.crossDomain ) {\n\t\t\t\t\t\t\t\t\t\tstatus = responses.text ? 200 : 404;\n\t\t\t\t\t\t\t\t\t// IE - #1450: sometimes returns 1223 when it should be 204\n\t\t\t\t\t\t\t\t\t} else if ( status === 1223 ) {\n\t\t\t\t\t\t\t\t\t\tstatus = 204;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch( firefoxAccessException ) {\n\t\t\t\t\t\t\tif ( !isAbort ) {\n\t\t\t\t\t\t\t\tcomplete( -1, firefoxAccessException );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Call complete if needed\n\t\t\t\t\t\tif ( responses ) {\n\t\t\t\t\t\t\tcomplete( status, statusText, responses, responseHeaders );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// if we're in sync mode or it's in cache\n\t\t\t\t\t// and has been retrieved directly (IE6 & IE7)\n\t\t\t\t\t// we need to manually fire the callback\n\t\t\t\t\tif ( !s.async || xhr.readyState === 4 ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Create the active xhrs callbacks list if needed\n\t\t\t\t\t\t// and attach the unload handler\n\t\t\t\t\t\tif ( !xhrCallbacks ) {\n\t\t\t\t\t\t\txhrCallbacks = {};\n\t\t\t\t\t\t\txhrOnUnloadAbort();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Add to list of active xhrs callbacks\n\t\t\t\t\t\thandle = xhrId++;\n\t\t\t\t\t\txhr.onreadystatechange = xhrCallbacks[ handle ] = callback;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback(0,1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n}\n\n\n\n\nvar elemdisplay = {},\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trfxnum = /^([+\\-]=)?([\\d+.\\-]+)([a-z%]*)$/i,\n\ttimerId,\n\tfxAttrs = [\n\t\t// height animations\n\t\t[ \"height\", \"marginTop\", \"marginBottom\", \"paddingTop\", \"paddingBottom\" ],\n\t\t// width animations\n\t\t[ \"width\", \"marginLeft\", \"marginRight\", \"paddingLeft\", \"paddingRight\" ],\n\t\t// opacity animations\n\t\t[ \"opacity\" ]\n\t];\n\njQuery.fn.extend({\n\tshow: function( speed, easing, callback ) {\n\t\tvar elem, display;\n\n\t\tif ( speed || speed === 0 ) {\n\t\t\treturn this.animate( genFx(\"show\", 3), speed, easing, callback);\n\n\t\t} else {\n\t\t\tfor ( var i = 0, j = this.length; i < j; i++ ) {\n\t\t\t\telem = this[i];\n\t\t\t\tdisplay = elem.style.display;\n\n\t\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t\t// being hidden by cascaded rules or not\n\t\t\t\tif ( !jQuery._data(elem, \"olddisplay\") && display === \"none\" ) {\n\t\t\t\t\tdisplay = elem.style.display = \"\";\n\t\t\t\t}\n\n\t\t\t\t// Set elements which have been overridden with display: none\n\t\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t\t// for such an element\n\t\t\t\tif ( display === \"\" && jQuery.css( elem, \"display\" ) === \"none\" ) {\n\t\t\t\t\tjQuery._data(elem, \"olddisplay\", defaultDisplay(elem.nodeName));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the display of most of the elements in a second loop\n\t\t\t// to avoid the constant reflow\n\t\t\tfor ( i = 0; i < j; i++ ) {\n\t\t\t\telem = this[i];\n\t\t\t\tdisplay = elem.style.display;\n\n\t\t\t\tif ( display === \"\" || display === \"none\" ) {\n\t\t\t\t\telem.style.display = jQuery._data(elem, \"olddisplay\") || \"\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t},\n\n\thide: function( speed, easing, callback ) {\n\t\tif ( speed || speed === 0 ) {\n\t\t\treturn this.animate( genFx(\"hide\", 3), speed, easing, callback);\n\n\t\t} else {\n\t\t\tfor ( var i = 0, j = this.length; i < j; i++ ) {\n\t\t\t\tvar display = jQuery.css( this[i], \"display\" );\n\n\t\t\t\tif ( display !== \"none\" && !jQuery._data( this[i], \"olddisplay\" ) ) {\n\t\t\t\t\tjQuery._data( this[i], \"olddisplay\", display );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the display of the elements in a second loop\n\t\t\t// to avoid the constant reflow\n\t\t\tfor ( i = 0; i < j; i++ ) {\n\t\t\t\tthis[i].style.display = \"none\";\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t},\n\n\t// Save the old toggle function\n\t_toggle: jQuery.fn.toggle,\n\n\ttoggle: function( fn, fn2, callback ) {\n\t\tvar bool = typeof fn === \"boolean\";\n\n\t\tif ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {\n\t\t\tthis._toggle.apply( this, arguments );\n\n\t\t} else if ( fn == null || bool ) {\n\t\t\tthis.each(function() {\n\t\t\t\tvar state = bool ? fn : jQuery(this).is(\":hidden\");\n\t\t\t\tjQuery(this)[ state ? \"show\" : \"hide\" ]();\n\t\t\t});\n\n\t\t} else {\n\t\t\tthis.animate(genFx(\"toggle\", 3), fn, fn2, callback);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tfadeTo: function( speed, to, easing, callback ) {\n\t\treturn this.filter(\":hidden\").css(\"opacity\", 0).show().end()\n\t\t\t\t\t.animate({opacity: to}, speed, easing, callback);\n\t},\n\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar optall = jQuery.speed(speed, easing, callback);\n\n\t\tif ( jQuery.isEmptyObject( prop ) ) {\n\t\t\treturn this.each( optall.complete );\n\t\t}\n\n\t\treturn this[ optall.queue === false ? \"each\" : \"queue\" ](function() {\n\t\t\t// XXX 'this' does not always have a nodeName when running the\n\t\t\t// test suite\n\n\t\t\tvar opt = jQuery.extend({}, optall), p,\n\t\t\t\tisElement = this.nodeType === 1,\n\t\t\t\thidden = isElement && jQuery(this).is(\":hidden\"),\n\t\t\t\tself = this;\n\n\t\t\tfor ( p in prop ) {\n\t\t\t\tvar name = jQuery.camelCase( p );\n\n\t\t\t\tif ( p !== name ) {\n\t\t\t\t\tprop[ name ] = prop[ p ];\n\t\t\t\t\tdelete prop[ p ];\n\t\t\t\t\tp = name;\n\t\t\t\t}\n\n\t\t\t\tif ( prop[p] === \"hide\" && hidden || prop[p] === \"show\" && !hidden ) {\n\t\t\t\t\treturn opt.complete.call(this);\n\t\t\t\t}\n\n\t\t\t\tif ( isElement && ( p === \"height\" || p === \"width\" ) ) {\n\t\t\t\t\t// Make sure that nothing sneaks out\n\t\t\t\t\t// Record all 3 overflow attributes because IE does not\n\t\t\t\t\t// change the overflow attribute when overflowX and\n\t\t\t\t\t// overflowY are set to the same value\n\t\t\t\t\topt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];\n\n\t\t\t\t\t// Set display property to inline-block for height/width\n\t\t\t\t\t// animations on inline elements that are having width/height\n\t\t\t\t\t// animated\n\t\t\t\t\tif ( jQuery.css( this, \"display\" ) === \"inline\" &&\n\t\t\t\t\t\t\tjQuery.css( this, \"float\" ) === \"none\" ) {\n\t\t\t\t\t\tif ( !jQuery.support.inlineBlockNeedsLayout ) {\n\t\t\t\t\t\t\tthis.style.display = \"inline-block\";\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar display = defaultDisplay(this.nodeName);\n\n\t\t\t\t\t\t\t// inline-level elements accept inline-block;\n\t\t\t\t\t\t\t// block-level elements need to be inline with layout\n\t\t\t\t\t\t\tif ( display === \"inline\" ) {\n\t\t\t\t\t\t\t\tthis.style.display = \"inline-block\";\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.style.display = \"inline\";\n\t\t\t\t\t\t\t\tthis.style.zoom = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( jQuery.isArray( prop[p] ) ) {\n\t\t\t\t\t// Create (if needed) and add to specialEasing\n\t\t\t\t\t(opt.specialEasing = opt.specialEasing || {})[p] = prop[p][1];\n\t\t\t\t\tprop[p] = prop[p][0];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( opt.overflow != null ) {\n\t\t\t\tthis.style.overflow = \"hidden\";\n\t\t\t}\n\n\t\t\topt.curAnim = jQuery.extend({}, prop);\n\n\t\t\tjQuery.each( prop, function( name, val ) {\n\t\t\t\tvar e = new jQuery.fx( self, opt, name );\n\n\t\t\t\tif ( rfxtypes.test(val) ) {\n\t\t\t\t\te[ val === \"toggle\" ? hidden ? \"show\" : \"hide\" : val ]( prop );\n\n\t\t\t\t} else {\n\t\t\t\t\tvar parts = rfxnum.exec(val),\n\t\t\t\t\t\tstart = e.cur();\n\n\t\t\t\t\tif ( parts ) {\n\t\t\t\t\t\tvar end = parseFloat( parts[2] ),\n\t\t\t\t\t\t\tunit = parts[3] || ( jQuery.cssNumber[ name ] ? \"\" : \"px\" );\n\n\t\t\t\t\t\t// We need to compute starting value\n\t\t\t\t\t\tif ( unit !== \"px\" ) {\n\t\t\t\t\t\t\tjQuery.style( self, name, (end || 1) + unit);\n\t\t\t\t\t\t\tstart = ((end || 1) / e.cur()) * start;\n\t\t\t\t\t\t\tjQuery.style( self, name, start + unit);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\t\t\tif ( parts[1] ) {\n\t\t\t\t\t\t\tend = ((parts[1] === \"-=\" ? -1 : 1) * end) + start;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\te.custom( start, end, unit );\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\te.custom( start, val, \"\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// For JS strict compliance\n\t\t\treturn true;\n\t\t});\n\t},\n\n\tstop: function( clearQueue, gotoEnd ) {\n\t\tvar timers = jQuery.timers;\n\n\t\tif ( clearQueue ) {\n\t\t\tthis.queue([]);\n\t\t}\n\n\t\tthis.each(function() {\n\t\t\t// go in reverse order so anything added to the queue during the loop is ignored\n\t\t\tfor ( var i = timers.length - 1; i >= 0; i-- ) {\n\t\t\t\tif ( timers[i].elem === this ) {\n\t\t\t\t\tif (gotoEnd) {\n\t\t\t\t\t\t// force the next step to be the last\n\t\t\t\t\t\ttimers[i](true);\n\t\t\t\t\t}\n\n\t\t\t\t\ttimers.splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// start the next in the queue if the last step wasn't forced\n\t\tif ( !gotoEnd ) {\n\t\t\tthis.dequeue();\n\t\t}\n\n\t\treturn this;\n\t}\n\n});\n\nfunction genFx( type, num ) {\n\tvar obj = {};\n\n\tjQuery.each( fxAttrs.concat.apply([], fxAttrs.slice(0,num)), function() {\n\t\tobj[ this ] = type;\n\t});\n\n\treturn obj;\n}\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx(\"show\", 1),\n\tslideUp: genFx(\"hide\", 1),\n\tslideToggle: genFx(\"toggle\", 1),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n});\n\njQuery.extend({\n\tspeed: function( speed, easing, fn ) {\n\t\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend({}, speed) : {\n\t\t\tcomplete: fn || !fn && easing ||\n\t\t\t\tjQuery.isFunction( speed ) && speed,\n\t\t\tduration: speed,\n\t\t\teasing: fn && easing || easing && !jQuery.isFunction(easing) && easing\n\t\t};\n\n\t\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;\n\n\t\t// Queueing\n\t\topt.old = opt.complete;\n\t\topt.complete = function() {\n\t\t\tif ( opt.queue !== false ) {\n\t\t\t\tjQuery(this).dequeue();\n\t\t\t}\n\t\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\t\topt.old.call( this );\n\t\t\t}\n\t\t};\n\n\t\treturn opt;\n\t},\n\n\teasing: {\n\t\tlinear: function( p, n, firstNum, diff ) {\n\t\t\treturn firstNum + diff * p;\n\t\t},\n\t\tswing: function( p, n, firstNum, diff ) {\n\t\t\treturn ((-Math.cos(p*Math.PI)/2) + 0.5) * diff + firstNum;\n\t\t}\n\t},\n\n\ttimers: [],\n\n\tfx: function( elem, options, prop ) {\n\t\tthis.options = options;\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\n\t\tif ( !options.orig ) {\n\t\t\toptions.orig = {};\n\t\t}\n\t}\n\n});\n\njQuery.fx.prototype = {\n\t// Simple function for setting a style value\n\tupdate: function() {\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\t(jQuery.fx.step[this.prop] || jQuery.fx.step._default)( this );\n\t},\n\n\t// Get the current size\n\tcur: function() {\n\t\tif ( this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null) ) {\n\t\t\treturn this.elem[ this.prop ];\n\t\t}\n\n\t\tvar parsed,\n\t\t\tr = jQuery.css( this.elem, this.prop );\n\t\t// Empty strings, null, undefined and \"auto\" are converted to 0,\n\t\t// complex values such as \"rotate(1rad)\" are returned as is,\n\t\t// simple values such as \"10px\" are parsed to Float.\n\t\treturn isNaN( parsed = parseFloat( r ) ) ? !r || r === \"auto\" ? 0 : r : parsed;\n\t},\n\n\t// Start an animation from one number to another\n\tcustom: function( from, to, unit ) {\n\t\tvar self = this,\n\t\t\tfx = jQuery.fx;\n\n\t\tthis.startTime = jQuery.now();\n\t\tthis.start = from;\n\t\tthis.end = to;\n\t\tthis.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? \"\" : \"px\" );\n\t\tthis.now = this.start;\n\t\tthis.pos = this.state = 0;\n\n\t\tfunction t( gotoEnd ) {\n\t\t\treturn self.step(gotoEnd);\n\t\t}\n\n\t\tt.elem = this.elem;\n\n\t\tif ( t() && jQuery.timers.push(t) && !timerId ) {\n\t\t\ttimerId = setInterval(fx.tick, fx.interval);\n\t\t}\n\t},\n\n\t// Simple 'show' function\n\tshow: function() {\n\t\t// Remember where we started, so that we can go back to it later\n\t\tthis.options.orig[this.prop] = jQuery.style( this.elem, this.prop );\n\t\tthis.options.show = true;\n\n\t\t// Begin the animation\n\t\t// Make sure that we start at a small width/height to avoid any\n\t\t// flash of content\n\t\tthis.custom(this.prop === \"width\" || this.prop === \"height\" ? 1 : 0, this.cur());\n\n\t\t// Start by showing the element\n\t\tjQuery( this.elem ).show();\n\t},\n\n\t// Simple 'hide' function\n\thide: function() {\n\t\t// Remember where we started, so that we can go back to it later\n\t\tthis.options.orig[this.prop] = jQuery.style( this.elem, this.prop );\n\t\tthis.options.hide = true;\n\n\t\t// Begin the animation\n\t\tthis.custom(this.cur(), 0);\n\t},\n\n\t// Each step of an animation\n\tstep: function( gotoEnd ) {\n\t\tvar t = jQuery.now(), done = true;\n\n\t\tif ( gotoEnd || t >= this.options.duration + this.startTime ) {\n\t\t\tthis.now = this.end;\n\t\t\tthis.pos = this.state = 1;\n\t\t\tthis.update();\n\n\t\t\tthis.options.curAnim[ this.prop ] = true;\n\n\t\t\tfor ( var i in this.options.curAnim ) {\n\t\t\t\tif ( this.options.curAnim[i] !== true ) {\n\t\t\t\t\tdone = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( done ) {\n\t\t\t\t// Reset the overflow\n\t\t\t\tif ( this.options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {\n\t\t\t\t\tvar elem = this.elem,\n\t\t\t\t\t\toptions = this.options;\n\n\t\t\t\t\tjQuery.each( [ \"\", \"X\", \"Y\" ], function (index, value) {\n\t\t\t\t\t\telem.style[ \"overflow\" + value ] = options.overflow[index];\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\t// Hide the element if the \"hide\" operation was done\n\t\t\t\tif ( this.options.hide ) {\n\t\t\t\t\tjQuery(this.elem).hide();\n\t\t\t\t}\n\n\t\t\t\t// Reset the properties, if the item has been hidden or shown\n\t\t\t\tif ( this.options.hide || this.options.show ) {\n\t\t\t\t\tfor ( var p in this.options.curAnim ) {\n\t\t\t\t\t\tjQuery.style( this.elem, p, this.options.orig[p] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Execute the complete function\n\t\t\t\tthis.options.complete.call( this.elem );\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t} else {\n\t\t\tvar n = t - this.startTime;\n\t\t\tthis.state = n / this.options.duration;\n\n\t\t\t// Perform the easing function, defaults to swing\n\t\t\tvar specialEasing = this.options.specialEasing && this.options.specialEasing[this.prop];\n\t\t\tvar defaultEasing = this.options.easing || (jQuery.easing.swing ? \"swing\" : \"linear\");\n\t\t\tthis.pos = jQuery.easing[specialEasing || defaultEasing](this.state, n, 0, 1, this.options.duration);\n\t\t\tthis.now = this.start + ((this.end - this.start) * this.pos);\n\n\t\t\t// Perform the next step of the animation\n\t\t\tthis.update();\n\t\t}\n\n\t\treturn true;\n\t}\n};\n\njQuery.extend( jQuery.fx, {\n\ttick: function() {\n\t\tvar timers = jQuery.timers;\n\n\t\tfor ( var i = 0; i < timers.length; i++ ) {\n\t\t\tif ( !timers[i]() ) {\n\t\t\t\ttimers.splice(i--, 1);\n\t\t\t}\n\t\t}\n\n\t\tif ( !timers.length ) {\n\t\t\tjQuery.fx.stop();\n\t\t}\n\t},\n\n\tinterval: 13,\n\n\tstop: function() {\n\t\tclearInterval( timerId );\n\t\ttimerId = null;\n\t},\n\n\tspeeds: {\n\t\tslow: 600,\n\t\tfast: 200,\n\t\t// Default speed\n\t\t_default: 400\n\t},\n\n\tstep: {\n\t\topacity: function( fx ) {\n\t\t\tjQuery.style( fx.elem, \"opacity\", fx.now );\n\t\t},\n\n\t\t_default: function( fx ) {\n\t\t\tif ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {\n\t\t\t\tfx.elem.style[ fx.prop ] = (fx.prop === \"width\" || fx.prop === \"height\" ? Math.max(0, fx.now) : fx.now) + fx.unit;\n\t\t\t} else {\n\t\t\t\tfx.elem[ fx.prop ] = fx.now;\n\t\t\t}\n\t\t}\n\t}\n});\n\nif ( jQuery.expr && jQuery.expr.filters ) {\n\tjQuery.expr.filters.animated = function( elem ) {\n\t\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\t\treturn elem === fn.elem;\n\t\t}).length;\n\t};\n}\n\nfunction defaultDisplay( nodeName ) {\n\tif ( !elemdisplay[ nodeName ] ) {\n\t\tvar elem = jQuery(\"<\" + nodeName + \">\").appendTo(\"body\"),\n\t\t\tdisplay = elem.css(\"display\");\n\n\t\telem.remove();\n\n\t\tif ( display === \"none\" || display === \"\" ) {\n\t\t\tdisplay = \"block\";\n\t\t}\n\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn elemdisplay[ nodeName ];\n}\n\n\n\n\nvar rtable = /^t(?:able|d|h)$/i,\n\trroot = /^(?:body|html)$/i;\n\nif ( \"getBoundingClientRect\" in document.documentElement ) {\n\tjQuery.fn.offset = function( options ) {\n\t\tvar elem = this[0], box;\n\n\t\tif ( options ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t});\n\t\t}\n\n\t\tif ( !elem || !elem.ownerDocument ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( elem === elem.ownerDocument.body ) {\n\t\t\treturn jQuery.offset.bodyOffset( elem );\n\t\t}\n\n\t\ttry {\n\t\t\tbox = elem.getBoundingClientRect();\n\t\t} catch(e) {}\n\n\t\tvar doc = elem.ownerDocument,\n\t\t\tdocElem = doc.documentElement;\n\n\t\t// Make sure we're not dealing with a disconnected DOM node\n\t\tif ( !box || !jQuery.contains( docElem, elem ) ) {\n\t\t\treturn box ? { top: box.top, left: box.left } : { top: 0, left: 0 };\n\t\t}\n\n\t\tvar body = doc.body,\n\t\t\twin = getWindow(doc),\n\t\t\tclientTop  = docElem.clientTop  || body.clientTop  || 0,\n\t\t\tclientLeft = docElem.clientLeft || body.clientLeft || 0,\n\t\t\tscrollTop  = (win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop ),\n\t\t\tscrollLeft = (win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft),\n\t\t\ttop  = box.top  + scrollTop  - clientTop,\n\t\t\tleft = box.left + scrollLeft - clientLeft;\n\n\t\treturn { top: top, left: left };\n\t};\n\n} else {\n\tjQuery.fn.offset = function( options ) {\n\t\tvar elem = this[0];\n\n\t\tif ( options ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t});\n\t\t}\n\n\t\tif ( !elem || !elem.ownerDocument ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( elem === elem.ownerDocument.body ) {\n\t\t\treturn jQuery.offset.bodyOffset( elem );\n\t\t}\n\n\t\tjQuery.offset.initialize();\n\n\t\tvar computedStyle,\n\t\t\toffsetParent = elem.offsetParent,\n\t\t\tprevOffsetParent = elem,\n\t\t\tdoc = elem.ownerDocument,\n\t\t\tdocElem = doc.documentElement,\n\t\t\tbody = doc.body,\n\t\t\tdefaultView = doc.defaultView,\n\t\t\tprevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,\n\t\t\ttop = elem.offsetTop,\n\t\t\tleft = elem.offsetLeft;\n\n\t\twhile ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {\n\t\t\tif ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === \"fixed\" ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcomputedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;\n\t\t\ttop  -= elem.scrollTop;\n\t\t\tleft -= elem.scrollLeft;\n\n\t\t\tif ( elem === offsetParent ) {\n\t\t\t\ttop  += elem.offsetTop;\n\t\t\t\tleft += elem.offsetLeft;\n\n\t\t\t\tif ( jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {\n\t\t\t\t\ttop  += parseFloat( computedStyle.borderTopWidth  ) || 0;\n\t\t\t\t\tleft += parseFloat( computedStyle.borderLeftWidth ) || 0;\n\t\t\t\t}\n\n\t\t\t\tprevOffsetParent = offsetParent;\n\t\t\t\toffsetParent = elem.offsetParent;\n\t\t\t}\n\n\t\t\tif ( jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== \"visible\" ) {\n\t\t\t\ttop  += parseFloat( computedStyle.borderTopWidth  ) || 0;\n\t\t\t\tleft += parseFloat( computedStyle.borderLeftWidth ) || 0;\n\t\t\t}\n\n\t\t\tprevComputedStyle = computedStyle;\n\t\t}\n\n\t\tif ( prevComputedStyle.position === \"relative\" || prevComputedStyle.position === \"static\" ) {\n\t\t\ttop  += body.offsetTop;\n\t\t\tleft += body.offsetLeft;\n\t\t}\n\n\t\tif ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === \"fixed\" ) {\n\t\t\ttop  += Math.max( docElem.scrollTop, body.scrollTop );\n\t\t\tleft += Math.max( docElem.scrollLeft, body.scrollLeft );\n\t\t}\n\n\t\treturn { top: top, left: left };\n\t};\n}\n\njQuery.offset = {\n\tinitialize: function() {\n\t\tvar body = document.body, container = document.createElement(\"div\"), innerDiv, checkDiv, table, td, bodyMarginTop = parseFloat( jQuery.css(body, \"marginTop\") ) || 0,\n\t\t\thtml = \"<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>\";\n\n\t\tjQuery.extend( container.style, { position: \"absolute\", top: 0, left: 0, margin: 0, border: 0, width: \"1px\", height: \"1px\", visibility: \"hidden\" } );\n\n\t\tcontainer.innerHTML = html;\n\t\tbody.insertBefore( container, body.firstChild );\n\t\tinnerDiv = container.firstChild;\n\t\tcheckDiv = innerDiv.firstChild;\n\t\ttd = innerDiv.nextSibling.firstChild.firstChild;\n\n\t\tthis.doesNotAddBorder = (checkDiv.offsetTop !== 5);\n\t\tthis.doesAddBorderForTableAndCells = (td.offsetTop === 5);\n\n\t\tcheckDiv.style.position = \"fixed\";\n\t\tcheckDiv.style.top = \"20px\";\n\n\t\t// safari subtracts parent border width here which is 5px\n\t\tthis.supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15);\n\t\tcheckDiv.style.position = checkDiv.style.top = \"\";\n\n\t\tinnerDiv.style.overflow = \"hidden\";\n\t\tinnerDiv.style.position = \"relative\";\n\n\t\tthis.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);\n\n\t\tthis.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop);\n\n\t\tbody.removeChild( container );\n\t\tbody = container = innerDiv = checkDiv = table = td = null;\n\t\tjQuery.offset.initialize = jQuery.noop;\n\t},\n\n\tbodyOffset: function( body ) {\n\t\tvar top = body.offsetTop,\n\t\t\tleft = body.offsetLeft;\n\n\t\tjQuery.offset.initialize();\n\n\t\tif ( jQuery.offset.doesNotIncludeMarginInBodyOffset ) {\n\t\t\ttop  += parseFloat( jQuery.css(body, \"marginTop\") ) || 0;\n\t\t\tleft += parseFloat( jQuery.css(body, \"marginLeft\") ) || 0;\n\t\t}\n\n\t\treturn { top: top, left: left };\n\t},\n\n\tsetOffset: function( elem, options, i ) {\n\t\tvar position = jQuery.css( elem, \"position\" );\n\n\t\t// set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tvar curElem = jQuery( elem ),\n\t\t\tcurOffset = curElem.offset(),\n\t\t\tcurCSSTop = jQuery.css( elem, \"top\" ),\n\t\t\tcurCSSLeft = jQuery.css( elem, \"left\" ),\n\t\t\tcalculatePosition = (position === \"absolute\" && jQuery.inArray('auto', [curCSSTop, curCSSLeft]) > -1),\n\t\t\tprops = {}, curPosition = {}, curTop, curLeft;\n\n\t\t// need to be able to calculate position if either top or left is auto and position is absolute\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t}\n\n\t\tcurTop  = calculatePosition ? curPosition.top  : parseInt( curCSSTop,  10 ) || 0;\n\t\tcurLeft = calculatePosition ? curPosition.left : parseInt( curCSSLeft, 10 ) || 0;\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\toptions = options.call( elem, i, curOffset );\n\t\t}\n\n\t\tif (options.top != null) {\n\t\t\tprops.top = (options.top - curOffset.top) + curTop;\n\t\t}\n\t\tif (options.left != null) {\n\t\t\tprops.left = (options.left - curOffset.left) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\n\njQuery.fn.extend({\n\tposition: function() {\n\t\tif ( !this[0] ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar elem = this[0],\n\n\t\t// Get *real* offsetParent\n\t\toffsetParent = this.offsetParent(),\n\n\t\t// Get correct offsets\n\t\toffset       = this.offset(),\n\t\tparentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();\n\n\t\t// Subtract element margins\n\t\t// note: when an element has margin: auto the offsetLeft and marginLeft\n\t\t// are the same in Safari causing offset.left to incorrectly be 0\n\t\toffset.top  -= parseFloat( jQuery.css(elem, \"marginTop\") ) || 0;\n\t\toffset.left -= parseFloat( jQuery.css(elem, \"marginLeft\") ) || 0;\n\n\t\t// Add offsetParent borders\n\t\tparentOffset.top  += parseFloat( jQuery.css(offsetParent[0], \"borderTopWidth\") ) || 0;\n\t\tparentOffset.left += parseFloat( jQuery.css(offsetParent[0], \"borderLeftWidth\") ) || 0;\n\n\t\t// Subtract the two offsets\n\t\treturn {\n\t\t\ttop:  offset.top  - parentOffset.top,\n\t\t\tleft: offset.left - parentOffset.left\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map(function() {\n\t\t\tvar offsetParent = this.offsetParent || document.body;\n\t\t\twhile ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, \"position\") === \"static\") ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\t\t\treturn offsetParent;\n\t\t});\n\t}\n});\n\n\n// Create scrollLeft and scrollTop methods\njQuery.each( [\"Left\", \"Top\"], function( i, name ) {\n\tvar method = \"scroll\" + name;\n\n\tjQuery.fn[ method ] = function(val) {\n\t\tvar elem = this[0], win;\n\n\t\tif ( !elem ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( val !== undefined ) {\n\t\t\t// Set the scroll offset\n\t\t\treturn this.each(function() {\n\t\t\t\twin = getWindow( this );\n\n\t\t\t\tif ( win ) {\n\t\t\t\t\twin.scrollTo(\n\t\t\t\t\t\t!i ? val : jQuery(win).scrollLeft(),\n\t\t\t\t\t\ti ? val : jQuery(win).scrollTop()\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\t\t\t\t\tthis[ method ] = val;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\twin = getWindow( elem );\n\n\t\t\t// Return the scroll offset\n\t\t\treturn win ? (\"pageXOffset\" in win) ? win[ i ? \"pageYOffset\" : \"pageXOffset\" ] :\n\t\t\t\tjQuery.support.boxModel && win.document.documentElement[ method ] ||\n\t\t\t\t\twin.document.body[ method ] :\n\t\t\t\telem[ method ];\n\t\t}\n\t};\n});\n\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ?\n\t\telem :\n\t\telem.nodeType === 9 ?\n\t\t\telem.defaultView || elem.parentWindow :\n\t\t\tfalse;\n}\n\n\n\n\n// Create innerHeight, innerWidth, outerHeight and outerWidth methods\njQuery.each([ \"Height\", \"Width\" ], function( i, name ) {\n\n\tvar type = name.toLowerCase();\n\n\t// innerHeight and innerWidth\n\tjQuery.fn[\"inner\" + name] = function() {\n\t\treturn this[0] ?\n\t\t\tparseFloat( jQuery.css( this[0], type, \"padding\" ) ) :\n\t\t\tnull;\n\t};\n\n\t// outerHeight and outerWidth\n\tjQuery.fn[\"outer\" + name] = function( margin ) {\n\t\treturn this[0] ?\n\t\t\tparseFloat( jQuery.css( this[0], type, margin ? \"margin\" : \"border\" ) ) :\n\t\t\tnull;\n\t};\n\n\tjQuery.fn[ type ] = function( size ) {\n\t\t// Get window width or height\n\t\tvar elem = this[0];\n\t\tif ( !elem ) {\n\t\t\treturn size == null ? null : this;\n\t\t}\n\n\t\tif ( jQuery.isFunction( size ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tvar self = jQuery( this );\n\t\t\t\tself[ type ]( size.call( this, i, self[ type ]() ) );\n\t\t\t});\n\t\t}\n\n\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode\n\t\t\t// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat\n\t\t\tvar docElemProp = elem.document.documentElement[ \"client\" + name ];\n\t\t\treturn elem.document.compatMode === \"CSS1Compat\" && docElemProp ||\n\t\t\t\telem.document.body[ \"client\" + name ] || docElemProp;\n\n\t\t// Get document width or height\n\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t// Either scroll[Width/Height] or offset[Width/Height], whichever is greater\n\t\t\treturn Math.max(\n\t\t\t\telem.documentElement[\"client\" + name],\n\t\t\t\telem.body[\"scroll\" + name], elem.documentElement[\"scroll\" + name],\n\t\t\t\telem.body[\"offset\" + name], elem.documentElement[\"offset\" + name]\n\t\t\t);\n\n\t\t// Get or set width or height on the element\n\t\t} else if ( size === undefined ) {\n\t\t\tvar orig = jQuery.css( elem, type ),\n\t\t\t\tret = parseFloat( orig );\n\n\t\t\treturn jQuery.isNaN( ret ) ? orig : ret;\n\n\t\t// Set the width or height on the element (default to pixels if value is unitless)\n\t\t} else {\n\t\t\treturn this.css( type, typeof size === \"string\" ? size : size + \"px\" );\n\t\t}\n\t};\n\n});\n\n\nwindow.jQuery = window.$ = jQuery;\n})(window);\n"
          },
          "redirectURL": "",
          "headersSize": 361,
          "bodySize": 216840
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "connect": 0,
          "send": 0,
          "wait": 60,
          "receive": 1049
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:17.161+01:00",
        "time": 949,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/scripts/requirejs/require.js",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 302,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:48 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:46 GMT"
            },
            {
              "name": "Etag",
              "value": "\"12eb8f1-13177-4d7330a7b4f80\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "78199"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=30"
            },
            {
              "name": "Expires",
              "value": "Wed, 06 Mar 2013 07:12:18 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=50"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "application/javascript"
            }
          ],
          "content": {
            "mimeType": "application/javascript",
            "size": 78199,
            "text": "/** vim: et:ts=4:sw=4:sts=4\n * @license RequireJS 0.24.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n/*jslint strict: false, plusplus: false */\n/*global window: false, navigator: false, document: false, importScripts: false,\n  jQuery: false, clearInterval: false, setInterval: false, self: false,\n  setTimeout: false, opera: false */\n\nvar require, define;\n(function () {\n    //Change this version number for each release.\n    var version = \"0.24.0\",\n        commentRegExp = /(\\/\\*([\\s\\S]*?)\\*\\/|\\/\\/(.*)$)/mg,\n        cjsRequireRegExp = /require\\([\"']([^'\"\\s]+)[\"']\\)/g,\n        currDirRegExp = /^\\.\\//,\n        jsSuffixRegExp = /\\.js$/,\n        ostring = Object.prototype.toString,\n        ap = Array.prototype,\n        aps = ap.slice,\n        apsp = ap.splice,\n        isBrowser = !!(typeof window !== \"undefined\" && navigator && document),\n        isWebWorker = !isBrowser && typeof importScripts !== \"undefined\",\n        //PS3 indicates loaded and complete, but need to wait for complete\n        //specifically. Sequence is \"loading\", \"loaded\", execution,\n        // then \"complete\". The UA check is unfortunate, but not sure how\n        //to feature test w/o causing perf issues.\n        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?\n                      /^complete$/ : /^(complete|loaded)$/,\n        defContextName = \"_\",\n        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.\n        isOpera = typeof opera !== \"undefined\" && opera.toString() === \"[object Opera]\",\n        reqWaitIdPrefix = \"_r@@\",\n        empty = {},\n        contexts = {},\n        globalDefQueue = [],\n        interactiveScript = null,\n        isDone = false,\n        useInteractive = false,\n        req, cfg = {}, currentlyAddingScript, s, head, baseElement, scripts, script,\n        src, subPath, mainScript, dataMain, i, scrollIntervalId, setReadyState, ctx;\n\n    function isFunction(it) {\n        return ostring.call(it) === \"[object Function]\";\n    }\n\n    function isArray(it) {\n        return ostring.call(it) === \"[object Array]\";\n    }\n\n    /**\n     * Simple function to mix in properties from source into target,\n     * but only if target does not already have a property of the same name.\n     * This is not robust in IE for transferring methods that match\n     * Object.prototype names, but the uses of mixin here seem unlikely to\n     * trigger a problem related to that.\n     */\n    function mixin(target, source, force) {\n        for (var prop in source) {\n            if (!(prop in empty) && (!(prop in target) || force)) {\n                target[prop] = source[prop];\n            }\n        }\n        return req;\n    }\n\n    /**\n     * Used to set up package paths from a packagePaths or packages config object.\n     * @param {Object} pkgs the object to store the new package config\n     * @param {Array} currentPackages an array of packages to configure\n     * @param {String} [dir] a prefix dir to use.\n     */\n    function configurePackageDir(pkgs, currentPackages, dir) {\n        var i, location, pkgObj;\n\n        for (i = 0; (pkgObj = currentPackages[i]); i++) {\n            pkgObj = typeof pkgObj === \"string\" ? { name: pkgObj } : pkgObj;\n            location = pkgObj.location;\n\n            //Add dir to the path, but avoid paths that start with a slash\n            //or have a colon (indicates a protocol)\n            if (dir && (!location || (location.indexOf(\"/\") !== 0 && location.indexOf(\":\") === -1))) {\n                location = dir + \"/\" + (location || pkgObj.name);\n            }\n\n            //Create a brand new object on pkgs, since currentPackages can\n            //be passed in again, and config.pkgs is the internal transformed\n            //state for all package configs.\n            pkgs[pkgObj.name] = {\n                name: pkgObj.name,\n                location: location || pkgObj.name,\n                lib: pkgObj.lib || \"lib\",\n                //Remove leading dot in main, so main paths are normalized,\n                //and remove any trailing .js, since different package\n                //envs have different conventions: some use a module name,\n                //some use a file name.\n                main: (pkgObj.main || \"lib/main\")\n                      .replace(currDirRegExp, '')\n                      .replace(jsSuffixRegExp, '')\n            };\n        }\n    }\n\n    //Check for an existing version of require. If so, then exit out. Only allow\n    //one version of require to be active in a page. However, allow for a require\n    //config object, just exit quickly if require is an actual function.\n    if (typeof require !== \"undefined\") {\n        if (isFunction(require)) {\n            return;\n        } else {\n            //assume it is a config object.\n            cfg = require;\n        }\n    }\n\n    /**\n     * Creates a new context for use in require and define calls.\n     * Handle most of the heavy lifting. Do not want to use an object\n     * with prototype here to avoid using \"this\" in require, in case it\n     * needs to be used in more super secure envs that do not want this.\n     * Also there should not be that many contexts in the page. Usually just\n     * one for the default context, but could be extra for multiversion cases\n     * or if a package needs a special context for a dependency that conflicts\n     * with the standard context.\n     */\n    function newContext(contextName) {\n        var context, resume,\n            config = {\n                waitSeconds: 7,\n                baseUrl: s.baseUrl || \"./\",\n                paths: {},\n                pkgs: {}\n            },\n            defQueue = [],\n            specified = {\n                \"require\": true,\n                \"exports\": true,\n                \"module\": true\n            },\n            urlMap = {},\n            defined = {},\n            loaded = {},\n            waiting = {},\n            waitAry = [],\n            waitIdCounter = 0,\n            managerCallbacks = {},\n            plugins = {},\n            pluginsQueue = {},\n            resumeDepth = 0,\n            normalizedWaiting = {};\n\n        /**\n         * Trims the . and .. from an array of path segments.\n         * It will keep a leading path segment if a .. will become\n         * the first path segment, to help with module name lookups,\n         * which act like paths, but can be remapped. But the end result,\n         * all paths that use this function should look normalized.\n         * NOTE: this method MODIFIES the input array.\n         * @param {Array} ary the array of path segments.\n         */\n        function trimDots(ary) {\n            var i, part;\n            for (i = 0; (part = ary[i]); i++) {\n                if (part === \".\") {\n                    ary.splice(i, 1);\n                    i -= 1;\n                } else if (part === \"..\") {\n                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {\n                        //End of the line. Keep at least one non-dot\n                        //path segment at the front so it can be mapped\n                        //correctly to disk. Otherwise, there is likely\n                        //no path mapping for a path starting with '..'.\n                        //This can still fail, but catches the most reasonable\n                        //uses of ..\n                        break;\n                    } else if (i > 0) {\n                        ary.splice(i - 1, 2);\n                        i -= 2;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Given a relative module name, like ./something, normalize it to\n         * a real name that can be mapped to a path.\n         * @param {String} name the relative name\n         * @param {String} baseName a real name that the name arg is relative\n         * to.\n         * @returns {String} normalized name\n         */\n        function normalize(name, baseName) {\n            var pkgName, pkgConfig;\n\n            //Adjust any relative paths.\n            if (name.charAt(0) === \".\") {\n                //If have a base name, try to normalize against it,\n                //otherwise, assume it is a top-level require that will\n                //be relative to baseUrl in the end.\n                if (baseName) {\n                    if (config.pkgs[baseName]) {\n                        //If the baseName is a package name, then just treat it as one\n                        //name to concat the name with.\n                        baseName = [baseName];\n                    } else {\n                        //Convert baseName to array, and lop off the last part,\n                        //so that . matches that \"directory\" and not name of the baseName's\n                        //module. For instance, baseName of \"one/two/three\", maps to\n                        //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                        //this normalization.\n                        baseName = baseName.split(\"/\");\n                        baseName = baseName.slice(0, baseName.length - 1);\n                    }\n\n                    name = baseName.concat(name.split(\"/\"));\n                    trimDots(name);\n\n                    //Some use of packages may use a . path to reference the\n                    //\"main\" module name, so normalize for that.\n                    pkgConfig = config.pkgs[(pkgName = name[0])];\n                    name = name.join(\"/\");\n                    if (pkgConfig && name === pkgName + '/' + pkgConfig.main) {\n                        name = pkgName;\n                    }\n                }\n            }\n            return name;\n        }\n\n        /**\n         * Creates a module mapping that includes plugin prefix, module\n         * name, and path. If parentModuleMap is provided it will\n         * also normalize the name via require.normalize()\n         *\n         * @param {String} name the module name\n         * @param {String} [parentModuleMap] parent module map\n         * for the module name, used to resolve relative names.\n         *\n         * @returns {Object}\n         */\n        function makeModuleMap(name, parentModuleMap) {\n            var index = name ? name.indexOf(\"!\") : -1,\n                prefix = null,\n                parentName = parentModuleMap ? parentModuleMap.name : null,\n                originalName = name,\n                normalizedName, url, pluginModule;\n\n            if (index !== -1) {\n                prefix = name.substring(0, index);\n                name = name.substring(index + 1, name.length);\n            }\n\n            if (prefix) {\n                prefix = normalize(prefix, parentName);\n            }\n\n            //Account for relative paths if there is a base name.\n            if (name) {\n                if (prefix) {\n                    pluginModule = defined[prefix];\n                    if (pluginModule) {\n                        //Plugin is loaded, use its normalize method, otherwise,\n                        //normalize name as usual.\n                        if (pluginModule.normalize) {\n                            normalizedName = pluginModule.normalize(name, function (name) {\n                                return normalize(name, parentName);\n                            });\n                        } else {\n                            normalizedName = normalize(name, parentName);\n                        }\n                    } else {\n                        //Plugin is not loaded yet, so do not normalize\n                        //the name, wait for plugin to load to see if\n                        //it has a normalize method. To avoid possible\n                        //ambiguity with relative names loaded from another\n                        //plugin, use the parent's name as part of this name.\n                        normalizedName = '__$p' + parentName + '@' + name;\n                    }\n                } else {\n                    normalizedName = normalize(name, parentName);\n                }\n\n                url = urlMap[normalizedName];\n                if (!url) {\n                    //Calculate url for the module, if it has a name.\n                    if (req.toModuleUrl) {\n                        //Special logic required for a particular engine,\n                        //like Node.\n                        url = req.toModuleUrl(context, name, parentModuleMap);\n                    } else {\n                        url = context.nameToUrl(name, null, parentModuleMap);\n                    }\n\n                    //Store the URL mapping for later.\n                    urlMap[normalizedName] = url;\n                }\n            }\n\n            return {\n                prefix: prefix,\n                name: normalizedName,\n                parentMap: parentModuleMap,\n                url: url,\n                originalName: originalName,\n                fullName: prefix ? prefix + \"!\" + normalizedName : normalizedName\n            };\n        }\n\n        /**\n         * Determine if priority loading is done. If so clear the priorityWait\n         */\n        function isPriorityDone() {\n            var priorityDone = true,\n                priorityWait = config.priorityWait,\n                priorityName, i;\n            if (priorityWait) {\n                for (i = 0; (priorityName = priorityWait[i]); i++) {\n                    if (!loaded[priorityName]) {\n                        priorityDone = false;\n                        break;\n                    }\n                }\n                if (priorityDone) {\n                    delete config.priorityWait;\n                }\n            }\n            return priorityDone;\n        }\n\n        /**\n         * Helper function that creates a setExports function for a \"module\"\n         * CommonJS dependency. Do this here to avoid creating a closure that\n         * is part of a loop.\n         */\n        function makeSetExports(moduleObj) {\n            return function (exports) {\n                moduleObj.exports = exports;\n            };\n        }\n\n        function makeContextModuleFunc(func, relModuleMap, enableBuildCallback) {\n            return function () {\n                //A version of a require function that passes a moduleName\n                //value for items that may need to\n                //look up paths relative to the moduleName\n                var args = [].concat(aps.call(arguments, 0)), lastArg;\n                if (enableBuildCallback &&\n                    isFunction((lastArg = args[args.length - 1]))) {\n                    lastArg.__requireJsBuild = true;\n                }\n                args.push(relModuleMap);\n                return func.apply(null, args);\n            };\n        }\n\n        /**\n         * Helper function that creates a require function object to give to\n         * modules that ask for it as a dependency. It needs to be specific\n         * per module because of the implication of path mappings that may\n         * need to be relative to the module name.\n         */\n        function makeRequire(relModuleMap, enableBuildCallback) {\n            var modRequire = makeContextModuleFunc(context.require, relModuleMap, enableBuildCallback);\n\n            mixin(modRequire, {\n                nameToUrl: makeContextModuleFunc(context.nameToUrl, relModuleMap),\n                toUrl: makeContextModuleFunc(context.toUrl, relModuleMap),\n                isDefined: makeContextModuleFunc(context.isDefined, relModuleMap),\n                ready: req.ready,\n                isBrowser: req.isBrowser\n            });\n            //Something used by node.\n            if (req.paths) {\n                modRequire.paths = req.paths;\n            }\n            return modRequire;\n        }\n\n        /**\n         * Used to update the normalized name for plugin-based dependencies\n         * after a plugin loads, since it can have its own normalization structure.\n         * @param {String} pluginName the normalized plugin module name.\n         */\n        function updateNormalizedNames(pluginName) {\n\n            var oldFullName, oldModuleMap, moduleMap, fullName, callbacks,\n                i, j, k, depArray, existingCallbacks,\n                maps = normalizedWaiting[pluginName];\n\n            if (maps) {\n                for (i = 0; (oldModuleMap = maps[i]); i++) {\n                    oldFullName = oldModuleMap.fullName;\n                    moduleMap = makeModuleMap(oldModuleMap.originalName, oldModuleMap.parentMap);\n                    fullName = moduleMap.fullName;\n                    //Callbacks could be undefined if the same plugin!name was\n                    //required twice in a row, so use empty array in that case.\n                    callbacks = managerCallbacks[oldFullName] || [];\n                    existingCallbacks = managerCallbacks[fullName];\n\n                    if (fullName !== oldFullName) {\n                        //Update the specified object, but only if it is already\n                        //in there. In sync environments, it may not be yet.\n                        if (oldFullName in specified) {\n                            delete specified[oldFullName];\n                            specified[fullName] = true;\n                        }\n\n                        //Update managerCallbacks to use the correct normalized name.\n                        //If there are already callbacks for the normalized name,\n                        //just add to them.\n                        if (existingCallbacks) {\n                            managerCallbacks[fullName] = existingCallbacks.concat(callbacks);\n                        } else {\n                            managerCallbacks[fullName] = callbacks;\n                        }\n                        delete managerCallbacks[oldFullName];\n\n                        //In each manager callback, update the normalized name in the depArray.\n                        for (j = 0; j < callbacks.length; j++) {\n                            depArray = callbacks[j].depArray;\n                            for (k = 0; k < depArray.length; k++) {\n                                if (depArray[k] === oldFullName) {\n                                    depArray[k] = fullName;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            delete normalizedWaiting[pluginName];\n        }\n\n        /*\n         * Queues a dependency for checking after the loader is out of a\n         * \"paused\" state, for example while a script file is being loaded\n         * in the browser, where it may have many modules defined in it.\n         *\n         * depName will be fully qualified, no relative . or .. path.\n         */\n        function queueDependency(dep) {\n            //Make sure to load any plugin and associate the dependency\n            //with that plugin.\n            var prefix = dep.prefix,\n                fullName = dep.fullName;\n\n            //Do not bother if the depName is already in transit\n            if (specified[fullName] || fullName in defined) {\n                return;\n            }\n\n            if (prefix && !plugins[prefix]) {\n                //Queue up loading of the dependency, track it\n                //via context.plugins. Mark it as a plugin so\n                //that the build system will know to treat it\n                //special.\n                plugins[prefix] = undefined;\n\n                //Remember this dep that needs to have normaliztion done\n                //after the plugin loads.\n                (normalizedWaiting[prefix] || (normalizedWaiting[prefix] = []))\n                    .push(dep);\n\n                //Register an action to do once the plugin loads, to update\n                //all managerCallbacks to use a properly normalized module\n                //name.\n                (managerCallbacks[prefix] ||\n                (managerCallbacks[prefix] = [])).push({\n                    onDep: function (name, value) {\n                        if (name === prefix) {\n                            updateNormalizedNames(prefix);\n                        }\n                    }\n                });\n\n                queueDependency(makeModuleMap(prefix));\n            }\n\n            context.paused.push(dep);\n        }\n\n        function execManager(manager) {\n            var i, ret, waitingCallbacks,\n                cb = manager.callback,\n                fullName = manager.fullName,\n                args = [],\n                ary = manager.depArray;\n\n            //Call the callback to define the module, if necessary.\n            if (cb && isFunction(cb)) {\n                //Pull out the defined dependencies and pass the ordered\n                //values to the callback.\n                if (ary) {\n                    for (i = 0; i < ary.length; i++) {\n                        args.push(manager.deps[ary[i]]);\n                    }\n                }\n\n                ret = req.execCb(fullName, manager.callback, args);\n\n                if (fullName) {\n                    //If using exports and the function did not return a value,\n                    //and the \"module\" object for this definition function did not\n                    //define an exported value, then use the exports object.\n                    if (manager.usingExports && ret === undefined && (!manager.cjsModule || !(\"exports\" in manager.cjsModule))) {\n                        ret = defined[fullName];\n                    } else {\n                        if (manager.cjsModule && \"exports\" in manager.cjsModule) {\n                            ret = defined[fullName] = manager.cjsModule.exports;\n                        } else {\n                            if (fullName in defined && !manager.usingExports) {\n                                return req.onError(new Error(fullName + \" has already been defined\"));\n                            }\n                            defined[fullName] = ret;\n                        }\n                    }\n                }\n            } else if (fullName) {\n                //May just be an object definition for the module. Only\n                //worry about defining if have a module name.\n                ret = defined[fullName] = cb;\n            }\n\n            if (fullName) {\n                //If anything was waiting for this module to be defined,\n                //notify them now.\n                waitingCallbacks = managerCallbacks[fullName];\n                if (waitingCallbacks) {\n                    for (i = 0; i < waitingCallbacks.length; i++) {\n                        waitingCallbacks[i].onDep(fullName, ret);\n                    }\n                    delete managerCallbacks[fullName];\n                }\n            }\n\n            //Clean up waiting.\n            if (waiting[manager.waitId]) {\n                delete waiting[manager.waitId];\n                manager.isDone = true;\n                context.waitCount -= 1;\n                if (context.waitCount === 0) {\n                    //Clear the wait array used for cycles.\n                    waitAry = [];\n                }\n            }\n\n            return undefined;\n        }\n\n        function main(inName, depArray, callback, relModuleMap) {\n            var moduleMap = makeModuleMap(inName, relModuleMap),\n                name = moduleMap.name,\n                fullName = moduleMap.fullName,\n                uniques = {},\n                manager = {\n                    //Use a wait ID because some entries are anon\n                    //async require calls.\n                    waitId: name || reqWaitIdPrefix + (waitIdCounter++),\n                    depCount: 0,\n                    depMax: 0,\n                    prefix: moduleMap.prefix,\n                    name: name,\n                    fullName: fullName,\n                    deps: {},\n                    depArray: depArray,\n                    callback: callback,\n                    onDep: function (depName, value) {\n                        if (!(depName in manager.deps)) {\n                            manager.deps[depName] = value;\n                            manager.depCount += 1;\n                            if (manager.depCount === manager.depMax) {\n                                //All done, execute!\n                                execManager(manager);\n                            }\n                        }\n                    }\n                },\n                i, depArg, depName, cjsMod;\n\n            if (fullName) {\n                //If module already defined for context, or already loaded,\n                //then leave.\n                if (fullName in defined || loaded[fullName] === true) {\n                    return;\n                }\n\n                //Set specified/loaded here for modules that are also loaded\n                //as part of a layer, where onScriptLoad is not fired\n                //for those cases. Do this after the inline define and\n                //dependency tracing is done.\n                //Also check if auto-registry of jQuery needs to be skipped.\n                specified[fullName] = true;\n                loaded[fullName] = true;\n                context.jQueryDef = (fullName === \"jquery\");\n            }\n\n            //Add the dependencies to the deps field, and register for callbacks\n            //on the dependencies.\n            for (i = 0; i < depArray.length; i++) {\n                depArg = depArray[i];\n                //There could be cases like in IE, where a trailing comma will\n                //introduce a null dependency, so only treat a real dependency\n                //value as a dependency.\n                if (depArg) {\n                    //Split the dependency name into plugin and name parts\n                    depArg = makeModuleMap(depArg, (name ? moduleMap : relModuleMap));\n                    depName = depArg.fullName;\n\n                    //Fix the name in depArray to be just the name, since\n                    //that is how it will be called back later.\n                    depArray[i] = depName;\n\n                    //Fast path CommonJS standard dependencies.\n                    if (depName === \"require\") {\n                        manager.deps[depName] = makeRequire(moduleMap);\n                    } else if (depName === \"exports\") {\n                        //CommonJS module spec 1.1\n                        manager.deps[depName] = defined[fullName] = {};\n                        manager.usingExports = true;\n                    } else if (depName === \"module\") {\n                        //CommonJS module spec 1.1\n                        manager.cjsModule = cjsMod = manager.deps[depName] = {\n                            id: name,\n                            uri: name ? context.nameToUrl(name, null, relModuleMap) : undefined\n                        };\n                        cjsMod.setExports = makeSetExports(cjsMod);\n                    } else if (depName in defined && !(depName in waiting)) {\n                        //Module already defined, no need to wait for it.\n                        manager.deps[depName] = defined[depName];\n                    } else if (!uniques[depName]) {\n\n                        //A dynamic dependency.\n                        manager.depMax += 1;\n\n                        queueDependency(depArg);\n\n                        //Register to get notification when dependency loads.\n                        (managerCallbacks[depName] ||\n                        (managerCallbacks[depName] = [])).push(manager);\n\n                        uniques[depName] = true;\n                    }\n                }\n            }\n\n            //Do not bother tracking the manager if it is all done.\n            if (manager.depCount === manager.depMax) {\n                //All done, execute!\n                execManager(manager);\n            } else {\n                waiting[manager.waitId] = manager;\n                waitAry.push(manager);\n                context.waitCount += 1;\n            }\n        }\n\n        /**\n         * Convenience method to call main for a require.def call that was put on\n         * hold in the defQueue.\n         */\n        function callDefMain(args) {\n            main.apply(null, args);\n            //Mark the module loaded. Must do it here in addition\n            //to doing it in require.def in case a script does\n            //not call require.def\n            loaded[args[0]] = true;\n        }\n\n        /**\n         * As of jQuery 1.4.3, it supports a readyWait property that will hold off\n         * calling jQuery ready callbacks until all scripts are loaded. Be sure\n         * to track it if readyWait is available. Also, since jQuery 1.4.3 does\n         * not register as a module, need to do some global inference checking.\n         * Even if it does register as a module, not guaranteed to be the precise\n         * name of the global. If a jQuery is tracked for this context, then go\n         * ahead and register it as a module too, if not already in process.\n         */\n        function jQueryCheck(jqCandidate) {\n            if (!context.jQuery) {\n                var $ = jqCandidate || (typeof jQuery !== \"undefined\" ? jQuery : null);\n                if ($ && \"readyWait\" in $) {\n                    context.jQuery = $;\n\n                    //Manually create a \"jquery\" module entry if not one already\n                    //or in process.\n                    callDefMain([\"jquery\", [], function () {\n                        return jQuery;\n                    }]);\n\n                    //Increment jQuery readyWait if ncecessary.\n                    if (context.scriptCount) {\n                        $.readyWait += 1;\n                        context.jQueryIncremented = true;\n                    }\n                }\n            }\n        }\n\n        function forceExec(manager, traced) {\n            if (manager.isDone) {\n                return undefined;\n            }\n\n            var fullName = manager.fullName,\n                depArray = manager.depArray,\n                depName, i;\n            if (fullName) {\n                if (traced[fullName]) {\n                    return defined[fullName];\n                }\n\n                traced[fullName] = true;\n            }\n\n            //forceExec all of its dependencies.\n            for (i = 0; i < depArray.length; i++) {\n                //Some array members may be null, like if a trailing comma\n                //IE, so do the explicit [i] access and check if it has a value.\n                depName = depArray[i];\n                if (depName) {\n                    if (!manager.deps[depName] && waiting[depName]) {\n                        manager.onDep(depName, forceExec(waiting[depName], traced));\n                    }\n                }\n            }\n\n            return fullName ? defined[fullName] : undefined;\n        }\n\n        /**\n         * Checks if all modules for a context are loaded, and if so, evaluates the\n         * new ones in right dependency order.\n         *\n         * @private\n         */\n        function checkLoaded() {\n            var waitInterval = config.waitSeconds * 1000,\n                //It is possible to disable the wait interval by using waitSeconds of 0.\n                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),\n                noLoads = \"\", hasLoadedProp = false, stillLoading = false, prop,\n                err, manager;\n\n            //If there are items still in the paused queue processing wait.\n            //This is particularly important in the sync case where each paused\n            //item is processed right away but there may be more waiting.\n            if (context.pausedCount > 0) {\n                return undefined;\n            }\n\n            //Determine if priority loading is done. If so clear the priority. If\n            //not, then do not check\n            if (config.priorityWait) {\n                if (isPriorityDone()) {\n                    //Call resume, since it could have\n                    //some waiting dependencies to trace.\n                    resume();\n                } else {\n                    return undefined;\n                }\n            }\n\n            //See if anything is still in flight.\n            for (prop in loaded) {\n                if (!(prop in empty)) {\n                    hasLoadedProp = true;\n                    if (!loaded[prop]) {\n                        if (expired) {\n                            noLoads += prop + \" \";\n                        } else {\n                            stillLoading = true;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            //Check for exit conditions.\n            if (!hasLoadedProp && !context.waitCount) {\n                //If the loaded object had no items, then the rest of\n                //the work below does not need to be done.\n                return undefined;\n            }\n            if (expired && noLoads) {\n                //If wait time expired, throw error of unloaded modules.\n                err = new Error(\"require.js load timeout for modules: \" + noLoads);\n                err.requireType = \"timeout\";\n                err.requireModules = noLoads;\n                return req.onError(err);\n            }\n            if (stillLoading || context.scriptCount) {\n                //Something is still waiting to load. Wait for it.\n                if (isBrowser || isWebWorker) {\n                    setTimeout(checkLoaded, 50);\n                }\n                return undefined;\n            }\n\n            //If still have items in the waiting cue, but all modules have\n            //been loaded, then it means there are some circular dependencies\n            //that need to be broken.\n            //However, as a waiting thing is fired, then it can add items to\n            //the waiting cue, and those items should not be fired yet, so\n            //make sure to redo the checkLoaded call after breaking a single\n            //cycle, if nothing else loaded then this logic will pick it up\n            //again.\n            if (context.waitCount) {\n                //Cycle through the waitAry, and call items in sequence.\n                for (i = 0; (manager = waitAry[i]); i++) {\n                    forceExec(manager, {});\n                }\n\n                checkLoaded();\n                return undefined;\n            }\n\n            //Check for DOM ready, and nothing is waiting across contexts.\n            req.checkReadyState();\n\n            return undefined;\n        }\n\n        function callPlugin(pluginName, dep) {\n            var name = dep.name,\n                fullName = dep.fullName,\n                load;\n\n            //Do not bother if plugin is already defined or being loaded.\n            if (fullName in defined || fullName in loaded) {\n                return;\n            }\n\n            if (!plugins[pluginName]) {\n                plugins[pluginName] = defined[pluginName];\n            }\n\n            //Only set loaded to false for tracking if it has not already been set.\n            if (!loaded[fullName]) {\n                loaded[fullName] = false;\n            }\n\n            load = function (ret) {\n                //Allow the build process to register plugin-loaded dependencies.\n                if (require.onPluginLoad) {\n                    require.onPluginLoad(context, pluginName, name, ret);\n                }\n\n                execManager({\n                    prefix: dep.prefix,\n                    name: dep.name,\n                    fullName: dep.fullName,\n                    callback: function () {\n                        return ret;\n                    }\n                });\n                loaded[fullName] = true;\n            };\n\n            //Allow plugins to load other code without having to know the\n            //context or how to \"complete\" the load.\n            load.fromText = function (moduleName, text) {\n                /*jslint evil: true */\n                var hasInteractive = useInteractive;\n\n                //Indicate a the module is in process of loading.\n                context.loaded[moduleName] = false;\n                context.scriptCount += 1;\n\n                //Turn off interactive script matching for IE for any define\n                //calls in the text, then turn it back on at the end.\n                if (hasInteractive) {\n                    useInteractive = false;\n                }\n                eval(text);\n                if (hasInteractive) {\n                    useInteractive = true;\n                }\n\n                //Support anonymous modules.\n                context.completeLoad(moduleName);\n            };\n\n            //Use parentName here since the plugin's name is not reliable,\n            //could be some weird string with no path that actually wants to\n            //reference the parentName's path.\n            plugins[pluginName].load(name, makeRequire(dep.parentMap, true), load, config);\n        }\n\n        function loadPaused(dep) {\n            //Renormalize dependency if its name was waiting on a plugin\n            //to load, which as since loaded.\n            if (dep.prefix && dep.name.indexOf('__$p') === 0 && defined[dep.prefix]) {\n                dep = makeModuleMap(dep.originalName, dep.parentMap);\n            }\n\n            var pluginName = dep.prefix,\n                fullName = dep.fullName;\n\n            //Do not bother if the dependency has already been specified.\n            if (specified[fullName] || loaded[fullName]) {\n                return;\n            } else {\n                specified[fullName] = true;\n            }\n\n            if (pluginName) {\n                //If plugin not loaded, wait for it.\n                //set up callback list. if no list, then register\n                //managerCallback for that plugin.\n                if (defined[pluginName]) {\n                    callPlugin(pluginName, dep);\n                } else {\n                    if (!pluginsQueue[pluginName]) {\n                        pluginsQueue[pluginName] = [];\n                        (managerCallbacks[pluginName] ||\n                        (managerCallbacks[pluginName] = [])).push({\n                            onDep: function (name, value) {\n                                if (name === pluginName) {\n                                    var i, oldModuleMap, ary = pluginsQueue[pluginName];\n\n                                    //Now update all queued plugin actions.\n                                    for (i = 0; i < ary.length; i++) {\n                                        oldModuleMap = ary[i];\n                                        //Update the moduleMap since the\n                                        //module name may be normalized\n                                        //differently now.\n                                        callPlugin(pluginName,\n                                                   makeModuleMap(oldModuleMap.originalName, oldModuleMap.parentMap));\n                                    }\n                                    delete pluginsQueue[pluginName];\n                                }\n                            }\n                        });\n                    }\n                    pluginsQueue[pluginName].push(dep);\n                }\n            } else {\n                req.load(context, fullName, dep.url);\n            }\n        }\n\n        /**\n         * Resumes tracing of dependencies and then checks if everything is loaded.\n         */\n        resume = function () {\n            var args, i, p;\n\n            resumeDepth += 1;\n\n            if (context.scriptCount <= 0) {\n                //Synchronous envs will push the number below zero with the\n                //decrement above, be sure to set it back to zero for good measure.\n                //require() calls that also do not end up loading scripts could\n                //push the number negative too.\n                context.scriptCount = 0;\n            }\n\n            //Make sure any remaining defQueue items get properly processed.\n            while (defQueue.length) {\n                args = defQueue.shift();\n                if (args[0] === null) {\n                    return req.onError(new Error('Mismatched anonymous require.def modules'));\n                } else {\n                    callDefMain(args);\n                }\n            }\n\n            //Skip the resume of paused dependencies\n            //if current context is in priority wait.\n            if (!config.priorityWait || isPriorityDone()) {\n                while (context.paused.length) {\n                    p = context.paused;\n                    context.pausedCount += p.length;\n                    //Reset paused list\n                    context.paused = [];\n\n                    for (i = 0; (args = p[i]); i++) {\n                        loadPaused(args);\n                    }\n                    //Move the start time for timeout forward.\n                    context.startTime = (new Date()).getTime();\n                    context.pausedCount -= p.length;\n                }\n            }\n\n            //Only check if loaded when resume depth is 1. It is likely that\n            //it is only greater than 1 in sync environments where a factory\n            //function also then calls the callback-style require. In those\n            //cases, the checkLoaded should not occur until the resume\n            //depth is back at the top level.\n            if (resumeDepth === 1) {\n                checkLoaded();\n            }\n\n            resumeDepth -= 1;\n\n            return undefined;\n        };\n\n        //Define the context object. Many of these fields are on here\n        //just to make debugging easier.\n        context = {\n            contextName: contextName,\n            config: config,\n            defQueue: defQueue,\n            waiting: waiting,\n            waitCount: 0,\n            specified: specified,\n            loaded: loaded,\n            urlMap: urlMap,\n            scriptCount: 0,\n            urlFetched: {},\n            defined: defined,\n            paused: [],\n            pausedCount: 0,\n            plugins: plugins,\n            managerCallbacks: managerCallbacks,\n            makeModuleMap: makeModuleMap,\n            normalize: normalize,\n            /**\n             * Set a configuration for the context.\n             * @param {Object} cfg config object to integrate.\n             */\n            configure: function (cfg) {\n                var paths, prop, packages, pkgs, packagePaths, requireWait;\n\n                //Make sure the baseUrl ends in a slash.\n                if (cfg.baseUrl) {\n                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== \"/\") {\n                        cfg.baseUrl += \"/\";\n                    }\n                }\n\n                //Save off the paths and packages since they require special processing,\n                //they are additive.\n                paths = config.paths;\n                packages = config.packages;\n                pkgs = config.pkgs;\n\n                //Mix in the config values, favoring the new values over\n                //existing ones in context.config.\n                mixin(config, cfg, true);\n\n                //Adjust paths if necessary.\n                if (cfg.paths) {\n                    for (prop in cfg.paths) {\n                        if (!(prop in empty)) {\n                            paths[prop] = cfg.paths[prop];\n                        }\n                    }\n                    config.paths = paths;\n                }\n\n                packagePaths = cfg.packagePaths;\n                if (packagePaths || cfg.packages) {\n                    //Convert packagePaths into a packages config.\n                    if (packagePaths) {\n                        for (prop in packagePaths) {\n                            if (!(prop in empty)) {\n                                configurePackageDir(pkgs, packagePaths[prop], prop);\n                            }\n                        }\n                    }\n\n                    //Adjust packages if necessary.\n                    if (cfg.packages) {\n                        configurePackageDir(pkgs, cfg.packages);\n                    }\n\n                    //Done with modifications, assing packages back to context config\n                    config.pkgs = pkgs;\n                }\n\n                //If priority loading is in effect, trigger the loads now\n                if (cfg.priority) {\n                    //Hold on to requireWait value, and reset it after done\n                    requireWait = context.requireWait;\n\n                    //Allow tracing some require calls to allow the fetching\n                    //of the priority config.\n                    context.requireWait = false;\n\n                    //But first, call resume to register any defined modules that may\n                    //be in a data-main built file before the priority config\n                    //call. Also grab any waiting define calls for this context.\n                    context.takeGlobalQueue();\n                    resume();\n\n                    context.require(cfg.priority);\n\n                    //Trigger a resume right away, for the case when\n                    //the script with the priority load is done as part\n                    //of a data-main call. In that case the normal resume\n                    //call will not happen because the scriptCount will be\n                    //at 1, since the script for data-main is being processed.\n                    resume();\n\n                    //Restore previous state.\n                    context.requireWait = requireWait;\n                    config.priorityWait = cfg.priority;\n                }\n\n                //If a deps array or a config callback is specified, then call\n                //require with those args. This is useful when require is defined as a\n                //config object before require.js is loaded.\n                if (cfg.deps || cfg.callback) {\n                    context.require(cfg.deps || [], cfg.callback);\n                }\n\n                //Set up ready callback, if asked. Useful when require is defined as a\n                //config object before require.js is loaded.\n                if (cfg.ready) {\n                    req.ready(cfg.ready);\n                }\n            },\n\n            isDefined: function (moduleName, relModuleMap) {\n                return makeModuleMap(moduleName, relModuleMap).fullName in defined;\n            },\n\n            require: function (deps, callback, relModuleMap) {\n                var moduleName, ret, moduleMap;\n                if (typeof deps === \"string\") {\n                    //Synchronous access to one module. If require.get is\n                    //available (as in the Node adapter), prefer that.\n                    //In this case deps is the moduleName and callback is\n                    //the relModuleMap\n                    if (req.get) {\n                        return req.get(context, deps, callback);\n                    }\n\n                    //Just return the module wanted. In this scenario, the\n                    //second arg (if passed) is just the relModuleMap.\n                    moduleName = deps;\n                    relModuleMap = callback;\n\n                    //Normalize module name, if it contains . or ..\n                    moduleMap = makeModuleMap(moduleName, relModuleMap);\n\n                    ret = defined[moduleMap.fullName];\n                    if (ret === undefined) {\n                        return req.onError(new Error(\"require: module name '\" +\n                                    moduleMap.fullName +\n                                    \"' has not been loaded yet for context: \" +\n                                    contextName));\n                    }\n                    return ret;\n                }\n\n                main(null, deps, callback, relModuleMap);\n\n                //If the require call does not trigger anything new to load,\n                //then resume the dependency processing.\n                if (!context.requireWait) {\n                    while (!context.scriptCount && context.paused.length) {\n                        resume();\n                    }\n                }\n                return undefined;\n            },\n\n            /**\n             * Internal method to transfer globalQueue items to this context's\n             * defQueue.\n             */\n            takeGlobalQueue: function () {\n                //Push all the globalDefQueue items into the context's defQueue\n                if (globalDefQueue.length) {\n                    //Array splice in the values since the context code has a\n                    //local var ref to defQueue, so cannot just reassign the one\n                    //on context.\n                    apsp.apply(context.defQueue,\n                               [context.defQueue.length - 1, 0].concat(globalDefQueue));\n                    globalDefQueue = [];\n                }\n            },\n\n            /**\n             * Internal method used by environment adapters to complete a load event.\n             * A load event could be a script load or just a load pass from a synchronous\n             * load call.\n             * @param {String} moduleName the name of the module to potentially complete.\n             */\n            completeLoad: function (moduleName) {\n                var args;\n\n                context.takeGlobalQueue();\n\n                while (defQueue.length) {\n                    args = defQueue.shift();\n\n                    if (args[0] === null) {\n                        args[0] = moduleName;\n                        break;\n                    } else if (args[0] === moduleName) {\n                        //Found matching require.def call for this script!\n                        break;\n                    } else {\n                        //Some other named require.def call, most likely the result\n                        //of a build layer that included many require.def calls.\n                        callDefMain(args);\n                        args = null;\n                    }\n                }\n                if (args) {\n                    callDefMain(args);\n                } else {\n                    //A script that does not call define(), so just simulate\n                    //the call for it. Special exception for jQuery dynamic load.\n                    callDefMain([moduleName, [],\n                                moduleName === \"jquery\" && typeof jQuery !== \"undefined\" ?\n                                function () {\n                                    return jQuery;\n                                } : null]);\n                }\n\n                //Mark the script as loaded. Note that this can be different from a\n                //moduleName that maps to a require.def call. This line is important\n                //for traditional browser scripts.\n                loaded[moduleName] = true;\n\n                //If a global jQuery is defined, check for it. Need to do it here\n                //instead of main() since stock jQuery does not register as\n                //a module via define.\n                jQueryCheck();\n\n                //Doing this scriptCount decrement branching because sync envs\n                //need to decrement after resume, otherwise it looks like\n                //loading is complete after the first dependency is fetched.\n                //For browsers, it works fine to decrement after, but it means\n                //the checkLoaded setTimeout 50 ms cost is taken. To avoid\n                //that cost, decrement beforehand.\n                if (req.isAsync) {\n                    context.scriptCount -= 1;\n                }\n                resume();\n                if (!req.isAsync) {\n                    context.scriptCount -= 1;\n                }\n            },\n\n            /**\n             * Converts a module name + .extension into an URL path.\n             * *Requires* the use of a module name. It does not support using\n             * plain URLs like nameToUrl.\n             */\n            toUrl: function (moduleNamePlusExt, relModuleMap) {\n                var index = moduleNamePlusExt.lastIndexOf(\".\"),\n                    ext = null;\n\n                if (index !== -1) {\n                    ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);\n                    moduleNamePlusExt = moduleNamePlusExt.substring(0, index);\n                }\n\n                return context.nameToUrl(moduleNamePlusExt, ext, relModuleMap);\n            },\n\n            /**\n             * Converts a module name to a file path. Supports cases where\n             * moduleName may actually be just an URL.\n             */\n            nameToUrl: function (moduleName, ext, relModuleMap) {\n                var paths, pkgs, pkg, pkgPath, syms, i, parentModule, url,\n                    config = context.config;\n\n                if (moduleName.indexOf(\"./\") === 0 || moduleName.indexOf(\"../\") === 0) {\n                    //A relative ID, just map it relative to relModuleMap's url\n                    syms = relModuleMap && relModuleMap.url ? relModuleMap.url.split('/') : [];\n                    //Pop off the file name.\n                    if (syms.length) {\n                        syms.pop();\n                    }\n                    syms = syms.concat(moduleName.split('/'));\n                    trimDots(syms);\n                    url = syms.join('/') +\n                          (ext ? ext :\n                          (req.jsExtRegExp.test(moduleName) ? \"\" : \".js\"));\n                } else {\n\n                    //Normalize module name if have a base relative module name to work from.\n                    moduleName = normalize(moduleName, relModuleMap);\n\n                    //If a colon is in the URL, it indicates a protocol is used and it is just\n                    //an URL to a file, or if it starts with a slash or ends with .js, it is just a plain file.\n                    //The slash is important for protocol-less URLs as well as full paths.\n                    if (req.jsExtRegExp.test(moduleName)) {\n                        //Just a plain path, not module name lookup, so just return it.\n                        //Add extension if it is included. This is a bit wonky, only non-.js things pass\n                        //an extension, this method probably needs to be reworked.\n                        url = moduleName + (ext ? ext : \"\");\n                    } else {\n                        //A module that needs to be converted to a path.\n                        paths = config.paths;\n                        pkgs = config.pkgs;\n\n                        syms = moduleName.split(\"/\");\n                        //For each module name segment, see if there is a path\n                        //registered for it. Start with most specific name\n                        //and work up from it.\n                        for (i = syms.length; i > 0; i--) {\n                            parentModule = syms.slice(0, i).join(\"/\");\n                            if (paths[parentModule]) {\n                                syms.splice(0, i, paths[parentModule]);\n                                break;\n                            } else if ((pkg = pkgs[parentModule])) {\n                                //If module name is just the package name, then looking\n                                //for the main module.\n                                if (moduleName === pkg.name) {\n                                    pkgPath = pkg.location + '/' + pkg.main;\n                                } else {\n                                    pkgPath = pkg.location + '/' + pkg.lib;\n                                }\n                                syms.splice(0, i, pkgPath);\n                                break;\n                            }\n                        }\n\n                        //Join the path parts together, then figure out if baseUrl is needed.\n                        url = syms.join(\"/\") + (ext || \".js\");\n                        url = (url.charAt(0) === '/' || url.match(/^\\w+:/) ? \"\" : config.baseUrl) + url;\n                    }\n                }\n\n                return config.urlArgs ? url +\n                                        ((url.indexOf('?') === -1 ? '?' : '&') +\n                                         config.urlArgs) : url;\n            }\n        };\n\n        //Make these visible on the context so can be called at the very\n        //end of the file to bootstrap\n        context.jQueryCheck = jQueryCheck;\n        context.resume = resume;\n\n        return context;\n    }\n\n    /**\n     * Main entry point.\n     *\n     * If the only argument to require is a string, then the module that\n     * is represented by that string is fetched for the appropriate context.\n     *\n     * If the first argument is an array, then it will be treated as an array\n     * of dependency string names to fetch. An optional function callback can\n     * be specified to execute when all of those dependencies are available.\n     *\n     * Make a local req variable to help Caja compliance (it assumes things\n     * on a require that are not standardized), and to give a short\n     * name for minification/local scope use.\n     */\n    req = require = function (deps, callback) {\n\n        //Find the right context, use default\n        var contextName = defContextName,\n            context, config;\n\n        // Determine if have config object in the call.\n        if (!isArray(deps) && typeof deps !== \"string\") {\n            // deps is a config object\n            config = deps;\n            if (isArray(callback)) {\n                // Adjust args if there are dependencies\n                deps = callback;\n                callback = arguments[2];\n            } else {\n                deps = [];\n            }\n        }\n\n        if (config && config.context) {\n            contextName = config.context;\n        }\n\n        context = contexts[contextName] ||\n                  (contexts[contextName] = newContext(contextName));\n\n        if (config) {\n            context.configure(config);\n        }\n\n        return context.require(deps, callback);\n    };\n\n    req.version = version;\n    req.isArray = isArray;\n    req.isFunction = isFunction;\n    req.mixin = mixin;\n    //Used to filter out dependencies that are already paths.\n    req.jsExtRegExp = /^\\/|:|\\?|\\.js$/;\n    s = req.s = {\n        contexts: contexts,\n        //Stores a list of URLs that should not get async script tag treatment.\n        skipAsync: {},\n        isPageLoaded: !isBrowser,\n        readyCalls: []\n    };\n\n    req.isAsync = req.isBrowser = isBrowser;\n    if (isBrowser) {\n        head = s.head = document.getElementsByTagName(\"head\")[0];\n        //If BASE tag is in play, using appendChild is a problem for IE6.\n        //When that browser dies, this can be removed. Details in this jQuery bug:\n        //http://dev.jquery.com/ticket/2709\n        baseElement = document.getElementsByTagName(\"base\")[0];\n        if (baseElement) {\n            head = s.head = baseElement.parentNode;\n        }\n    }\n\n    /**\n     * Any errors that require explicitly generates will be passed to this\n     * function. Intercept/override it if you want custom error handling.\n     * @param {Error} err the error object.\n     */\n    req.onError = function (err) {\n        throw err;\n    };\n\n    /**\n     * Does the request to load a module for the browser case.\n     * Make this a separate function to allow other environments\n     * to override it.\n     *\n     * @param {Object} context the require context to find state.\n     * @param {String} moduleName the name of the module.\n     * @param {Object} url the URL to the module.\n     */\n    req.load = function (context, moduleName, url) {\n        var contextName = context.contextName,\n            urlFetched = context.urlFetched,\n            loaded = context.loaded;\n        isDone = false;\n\n        //Only set loaded to false for tracking if it has not already been set.\n        if (!loaded[moduleName]) {\n            loaded[moduleName] = false;\n        }\n\n        if (!urlFetched[url]) {\n            context.scriptCount += 1;\n            req.attach(url, contextName, moduleName);\n            urlFetched[url] = true;\n\n            //If tracking a jQuery, then make sure its readyWait\n            //is incremented to prevent its ready callbacks from\n            //triggering too soon.\n            if (context.jQuery && !context.jQueryIncremented) {\n                context.jQuery.readyWait += 1;\n                context.jQueryIncremented = true;\n            }\n        }\n    };\n\n    function getInteractiveScript() {\n        var scripts, i, script;\n        if (interactiveScript && interactiveScript.readyState === 'interactive') {\n            return interactiveScript;\n        }\n\n        scripts = document.getElementsByTagName('script');\n        for (i = scripts.length - 1; i > -1 && (script = scripts[i]); i--) {\n            if (script.readyState === 'interactive') {\n                return (interactiveScript = script);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * The function that handles definitions of modules. Differs from\n     * require() in that a string for the module should be the first argument,\n     * and the function to execute after dependencies are loaded should\n     * return a value to define the module corresponding to the first argument's\n     * name.\n     */\n    define = req.def = function (name, deps, callback) {\n        var node, context;\n\n        //Allow for anonymous functions\n        if (typeof name !== 'string') {\n            //Adjust args appropriately\n            callback = deps;\n            deps = name;\n            name = null;\n        }\n\n        //This module may not have dependencies\n        if (!req.isArray(deps)) {\n            callback = deps;\n            deps = [];\n        }\n\n        //If no name, and callback is a function, then figure out if it a\n        //CommonJS thing with dependencies.\n        if (!name && !deps.length && req.isFunction(callback)) {\n            //Remove comments from the callback string,\n            //look for require calls, and pull them into the dependencies,\n            //but only if there are function args.\n            if (callback.length) {\n                callback\n                    .toString()\n                    .replace(commentRegExp, \"\")\n                    .replace(cjsRequireRegExp, function (match, dep) {\n                        deps.push(dep);\n                    });\n\n                //May be a CommonJS thing even without require calls, but still\n                //could use exports, and such, so always add those as dependencies.\n                //This is a bit wasteful for RequireJS modules that do not need\n                //an exports or module object, but erring on side of safety.\n                //REQUIRES the function to expect the CommonJS variables in the\n                //order listed below.\n                deps = [\"require\", \"exports\", \"module\"].concat(deps);\n            }\n        }\n\n        //If in IE 6-8 and hit an anonymous define() call, do the interactive\n        //work.\n        if (useInteractive) {\n            node = currentlyAddingScript || getInteractiveScript();\n            if (!node) {\n                return req.onError(new Error(\"ERROR: No matching script interactive for \" + callback));\n            }\n            if (!name) {\n                name = node.getAttribute(\"data-requiremodule\");\n            }\n            context = contexts[node.getAttribute(\"data-requirecontext\")];\n        }\n\n        //Always save off evaluating the def call until the script onload handler.\n        //This allows multiple modules to be in a file without prematurely\n        //tracing dependencies, and allows for anonymous module support,\n        //where the module name is not known until the script onload event\n        //occurs. If no context, use the global queue, and get it processed\n        //in the onscript load callback.\n        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);\n\n        return undefined;\n    };\n\n    define.amd = {\n        multiversion: true,\n        plugins: true\n    };\n\n    /**\n     * Executes a module callack function. Broken out as a separate function\n     * solely to allow the build system to sequence the files in the built\n     * layer in the right sequence.\n     *\n     * @private\n     */\n    req.execCb = function (name, callback, args) {\n        return callback.apply(null, args);\n    };\n\n    /**\n     * callback for script loads, used to check status of loading.\n     *\n     * @param {Event} evt the event from the browser for the script\n     * that was loaded.\n     *\n     * @private\n     */\n    req.onScriptLoad = function (evt) {\n        //Using currentTarget instead of target for Firefox 2.0's sake. Not\n        //all old browsers will be supported, but this one was easy enough\n        //to support and still makes sense.\n        var node = evt.currentTarget || evt.srcElement, contextName, moduleName,\n            context;\n\n        if (evt.type === \"load\" || readyRegExp.test(node.readyState)) {\n            //Reset interactive script so a script node is not held onto for\n            //to long.\n            interactiveScript = null;\n\n            //Pull out the name of the module and the context.\n            contextName = node.getAttribute(\"data-requirecontext\");\n            moduleName = node.getAttribute(\"data-requiremodule\");\n            context = contexts[contextName];\n\n            contexts[contextName].completeLoad(moduleName);\n\n            //Clean up script binding. Favor detachEvent because of IE9\n            //issue, see attachEvent/addEventListener comment elsewhere\n            //in this file.\n            if (node.detachEvent && !isOpera) {\n                //Probably IE. If not it will throw an error, which will be\n                //useful to know.\n                node.detachEvent(\"onreadystatechange\", req.onScriptLoad);\n            } else {\n                node.removeEventListener(\"load\", req.onScriptLoad, false);\n            }\n        }\n    };\n\n    /**\n     * Attaches the script represented by the URL to the current\n     * environment. Right now only supports browser loading,\n     * but can be redefined in other environments to do the right thing.\n     * @param {String} url the url of the script to attach.\n     * @param {String} contextName the name of the context that wants the script.\n     * @param {moduleName} the name of the module that is associated with the script.\n     * @param {Function} [callback] optional callback, defaults to require.onScriptLoad\n     * @param {String} [type] optional type, defaults to text/javascript\n     */\n    req.attach = function (url, contextName, moduleName, callback, type) {\n        var node, loaded, context;\n        if (isBrowser) {\n            //In the browser so use a script tag\n            callback = callback || req.onScriptLoad;\n            node = document.createElement(\"script\");\n            node.type = type || \"text/javascript\";\n            node.charset = \"utf-8\";\n            //Use async so Gecko does not block on executing the script if something\n            //like a long-polling comet tag is being run first. Gecko likes\n            //to evaluate scripts in DOM order, even for dynamic scripts.\n            //It will fetch them async, but only evaluate the contents in DOM\n            //order, so a long-polling script tag can delay execution of scripts\n            //after it. But telling Gecko we expect async gets us the behavior\n            //we want -- execute it whenever it is finished downloading. Only\n            //Helps Firefox 3.6+\n            //Allow some URLs to not be fetched async. Mostly helps the order!\n            //plugin\n            node.async = !s.skipAsync[url];\n\n            node.setAttribute(\"data-requirecontext\", contextName);\n            node.setAttribute(\"data-requiremodule\", moduleName);\n\n            //Set up load listener. Test attachEvent first because IE9 has\n            //a subtle issue in its addEventListener and script onload firings\n            //that do not match the behavior of all other browsers with\n            //addEventListener support, which fire the onload event for a\n            //script right after the script execution. See:\n            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution\n            //UNFORTUNATELY Opera implements attachEvent but does not follow the script\n            //script execution mode.\n            if (node.attachEvent && !isOpera) {\n                //Probably IE. IE (at least 6-8) do not fire\n                //script onload right after executing the script, so\n                //we cannot tie the anonymous require.def call to a name.\n                //However, IE reports the script as being in \"interactive\"\n                //readyState at the time of the require.def call.\n                useInteractive = true;\n                node.attachEvent(\"onreadystatechange\", callback);\n            } else {\n                node.addEventListener(\"load\", callback, false);\n            }\n            node.src = url;\n\n            //For some cache cases in IE 6-8, the script executes before the end\n            //of the appendChild execution, so to tie an anonymous require.def\n            //call to the module name (which is stored on the node), hold on\n            //to a reference to this node, but clear after the DOM insertion.\n            currentlyAddingScript = node;\n            if (baseElement) {\n                head.insertBefore(node, baseElement);\n            } else {\n                head.appendChild(node);\n            }\n            currentlyAddingScript = null;\n            return node;\n        } else if (isWebWorker) {\n            //In a web worker, use importScripts. This is not a very\n            //efficient use of importScripts, importScripts will block until\n            //its script is downloaded and evaluated. However, if web workers\n            //are in play, the expectation that a build has been done so that\n            //only one script needs to be loaded anyway. This may need to be\n            //reevaluated if other use cases become common.\n            context = contexts[contextName];\n            loaded = context.loaded;\n            loaded[moduleName] = false;\n\n            importScripts(url);\n\n            //Account for anonymous modules\n            context.completeLoad(moduleName);\n        }\n        return null;\n    };\n\n    //Look for a data-main script attribute, which could also adjust the baseUrl.\n    if (isBrowser) {\n        //Figure out baseUrl. Get it from the script tag with require.js in it.\n        scripts = document.getElementsByTagName(\"script\");\n\n        for (i = scripts.length - 1; i > -1 && (script = scripts[i]); i--) {\n            //Set the \"head\" where we can append children by\n            //using the script's parent.\n            if (!head) {\n                head = script.parentNode;\n            }\n\n            //Look for a data-main attribute to set main script for the page\n            //to load. If it is there, the path to data main becomes the\n            //baseUrl, if it is not already set.\n            if ((dataMain = script.getAttribute('data-main'))) {\n                if (!cfg.baseUrl) {\n                    //Pull off the directory of data-main for use as the\n                    //baseUrl.\n                    src = dataMain.split('/');\n                    mainScript = src.pop();\n                    subPath = src.length ? src.join('/')  + '/' : './';\n\n                    //Set final config.\n                    cfg.baseUrl = subPath;\n                    //Strip off any trailing .js since dataMain is now\n                    //like a module name.\n                    dataMain = mainScript.replace(jsSuffixRegExp, '');\n                }\n\n                //Put the data-main script in the files to load.\n                cfg.deps = cfg.deps ? cfg.deps.concat(dataMain) : [dataMain];\n\n                break;\n            }\n        }\n    }\n\n    //Set baseUrl based on config.\n    s.baseUrl = cfg.baseUrl;\n\n    //****** START page load functionality ****************\n    /**\n     * Sets the page as loaded and triggers check for all modules loaded.\n     */\n    req.pageLoaded = function () {\n        if (!s.isPageLoaded) {\n            s.isPageLoaded = true;\n            if (scrollIntervalId) {\n                clearInterval(scrollIntervalId);\n            }\n\n            //Part of a fix for FF < 3.6 where readyState was not set to\n            //complete so libraries like jQuery that check for readyState\n            //after page load where not getting initialized correctly.\n            //Original approach suggested by Andrea Giammarchi:\n            //http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html\n            //see other setReadyState reference for the rest of the fix.\n            if (setReadyState) {\n                document.readyState = \"complete\";\n            }\n\n            req.callReady();\n        }\n    };\n\n    //See if there is nothing waiting across contexts, and if not, trigger\n    //callReady.\n    req.checkReadyState = function () {\n        var contexts = s.contexts, prop;\n        for (prop in contexts) {\n            if (!(prop in empty)) {\n                if (contexts[prop].waitCount) {\n                    return;\n                }\n            }\n        }\n        s.isDone = true;\n        req.callReady();\n    };\n\n    /**\n     * Internal function that calls back any ready functions. If you are\n     * integrating RequireJS with another library without require.ready support,\n     * you can define this method to call your page ready code instead.\n     */\n    req.callReady = function () {\n        var callbacks = s.readyCalls, i, callback, contexts, context, prop;\n\n        if (s.isPageLoaded && s.isDone) {\n            if (callbacks.length) {\n                s.readyCalls = [];\n                for (i = 0; (callback = callbacks[i]); i++) {\n                    callback();\n                }\n            }\n\n            //If jQuery with readyWait is being tracked, updated its\n            //readyWait count.\n            contexts = s.contexts;\n            for (prop in contexts) {\n                if (!(prop in empty)) {\n                    context = contexts[prop];\n                    if (context.jQueryIncremented) {\n                        context.jQuery.ready(true);\n                        context.jQueryIncremented = false;\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Registers functions to call when the page is loaded\n     */\n    req.ready = function (callback) {\n        if (s.isPageLoaded && s.isDone) {\n            callback();\n        } else {\n            s.readyCalls.push(callback);\n        }\n        return req;\n    };\n\n    if (isBrowser) {\n        if (document.addEventListener) {\n            //Standards. Hooray! Assumption here that if standards based,\n            //it knows about DOMContentLoaded.\n            document.addEventListener(\"DOMContentLoaded\", req.pageLoaded, false);\n            window.addEventListener(\"load\", req.pageLoaded, false);\n            //Part of FF < 3.6 readystate fix (see setReadyState refs for more info)\n            if (!document.readyState) {\n                setReadyState = true;\n                document.readyState = \"loading\";\n            }\n        } else if (window.attachEvent) {\n            window.attachEvent(\"onload\", req.pageLoaded);\n\n            //DOMContentLoaded approximation, as found by Diego Perini:\n            //http://javascript.nwbox.com/IEContentLoaded/\n            if (self === self.top) {\n                scrollIntervalId = setInterval(function () {\n                    try {\n                        //From this ticket:\n                        //http://bugs.dojotoolkit.org/ticket/11106,\n                        //In IE HTML Application (HTA), such as in a selenium test,\n                        //javascript in the iframe can't see anything outside\n                        //of it, so self===self.top is true, but the iframe is\n                        //not the top window and doScroll will be available\n                        //before document.body is set. Test document.body\n                        //before trying the doScroll trick.\n                        if (document.body) {\n                            document.documentElement.doScroll(\"left\");\n                            req.pageLoaded();\n                        }\n                    } catch (e) {}\n                }, 30);\n            }\n        }\n\n        //Check if document already complete, and if so, just trigger page load\n        //listeners. NOTE: does not work with Firefox before 3.6. To support\n        //those browsers, manually call require.pageLoaded().\n        if (document.readyState === \"complete\") {\n            req.pageLoaded();\n        }\n    }\n    //****** END page load functionality ****************\n\n    //Set up default context. If require was a configuration object, use that as base config.\n    req(cfg);\n\n    //If modules are built into require.js, then need to make sure dependencies are\n    //traced. Use a setTimeout in the browser world, to allow all the modules to register\n    //themselves. In a non-browser env, assume that modules are not built into require.js,\n    //which seems odd to do on the server.\n    if (req.isAsync && typeof setTimeout !== \"undefined\") {\n        ctx = s.contexts[(cfg.context || defContextName)];\n        //Indicate that the script that includes require() is still loading,\n        //so that require()'d dependencies are not traced until the end of the\n        //file is parsed (approximated via the setTimeout call).\n        ctx.requireWait = true;\n        setTimeout(function () {\n            ctx.requireWait = false;\n\n            //Any modules included with the require.js file will be in the\n            //global queue, assign them to this context.\n            ctx.takeGlobalQueue();\n\n            //Allow for jQuery to be loaded/already in the page, and if jQuery 1.4.3,\n            //make sure to hold onto it for readyWait triggering.\n            ctx.jQueryCheck();\n\n            if (!ctx.scriptCount) {\n                ctx.resume();\n            }\n            req.checkReadyState();\n        }, 0);\n    }\n}());\n"
          },
          "redirectURL": "",
          "headersSize": 360,
          "bodySize": 78199
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "connect": 59,
          "send": 0,
          "wait": 163,
          "receive": 727
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:17.161+01:00",
        "time": 233,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/css/main.css",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "text/css,*/*;q=0.1"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 301,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:48 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:35 GMT"
            },
            {
              "name": "Etag",
              "value": "\"12eb990-963-4d73309d376c0\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "2403"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=604800"
            },
            {
              "name": "Expires",
              "value": "Wed, 13 Mar 2013 07:11:48 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=50"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "text/css"
            }
          ],
          "content": {
            "mimeType": "text/css",
            "size": 2403,
            "text": "/* See license.txt for terms of usage */\n\n/* Domplate Widgets */\n@import url(\"console.css\");\n@import url(\"domTree.css\");\n\n.body {\n    margin: 0;\n    font-family: Lucida Grande,Tahoma,sans-serif;\n    font-size: 11px;\n}\n\n#content .domTable {\n    min-width: 500px;\n    border-right: 1px solid #EFEFEF;\n}\n\n#content .memberRow {\n    height: 19px;\n}\n\n#content .memberRow td {\n    border-bottom: 1px solid #EFEFEF;\n}\n\n#content .memberHeaderCell {\n    height: 100%;\n    padding: 0;\n    margin: 0;\n    width: 20px;\n}\n\n#content .memberRowHeader {\n    cursor: pointer;\n    height: 100%;\n    display: block;\n}\n\n#content .sourceLine {\n    -moz-user-select: none;\n    margin-right: 10px;\n    border-right: 1px solid #CCCCCC;\n    padding: 0px 4px 0 20px;\n    background: #EEEEEE no-repeat 2px 0px;\n    color: #888888;\n    white-space: pre;\n    font-family: monospace; /* see issue 2953 */\n}\n\n#content .memberRow:hover {\n    background-color: #EFEFEF;\n}\n\n#content .memberRow:hover .memberRowHeader {\n    background-color: #F6F6F6;\n}\n\n/*************************************************************************************************/\n/* Differences */\n\n#content .memberRow.differentRow {\n    display: table-row;\n    background-image: repeating-linear-gradient(135deg, rgba(0, 0, 0, 0.02), rgba(0, 0, 0, 0.02) 5px, transparent 5px, transparent 10px);\n    background-repeat: repeat;\n}\n\n#content .memberRow .memberValueWrapper > DIV {\n    display: inline;\n}\n\n/*#content .memberRow.equalRow .memberValueWrapper.oldValue {\n    display: none;\n}*/\n\n#content .memberRow .memberSeparator {\n    border-left: 1px solid #EFEFEF;\n}\n\n#content .memberRow.differentRow .memberValueWrapper.oldValue .objectBox {\n    text-decoration: line-through;\n}\n\n#content .memberRow .diffObj.oldValue .objectBox {\n    text-decoration: line-through;\n}\n\n#content .memberRow .diffObj.newValue .objectBox {\n    text-decoration: none !important;\n}\n\n/*#content .memberRow.objectRow .memberValueWrapper.oldValue {\n    display: none;\n}*/\n\n#content .memberRow.differentRow .memberRowHeader {\n    background-image: url(images/warning.svg);\n    background-repeat: no-repeat;\n    background-position: 8px 2px;\n}\n\n/*************************************************************************************************/\n/* console.css */\n\n.objectLeftBrace,\n.arrayLeftBracket {\n    margin-right: 0px;\n}\n\n.objectRightBrace,\n.arrayRightBracket {\n    margin-left: 0px;\n}\n\n"
          },
          "redirectURL": "",
          "headersSize": 347,
          "bodySize": 2403
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "connect": 60,
          "send": 0,
          "wait": 173,
          "receive": 0
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:17.459+01:00",
        "time": 252,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/css/console.css",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "text/css,*/*;q=0.1"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/css/main.css"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 316,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:48 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:34 GMT"
            },
            {
              "name": "Etag",
              "value": "\"1266b52-4448-4d73309c43480\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "17480"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=604800"
            },
            {
              "name": "Expires",
              "value": "Wed, 13 Mar 2013 07:11:48 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=49"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "text/css"
            }
          ],
          "content": {
            "mimeType": "text/css",
            "size": 17479,
            "text": "\r\n.panelNode-console {\r\n    overflow-x: hidden;\r\n}\r\n\r\n.objectLink:hover {\r\n    cursor: pointer;\r\n    text-decoration: underline;\r\n}\r\n\r\n.logRow {\r\n    position: relative;\r\n    margin: 0;\r\n    border-bottom: 1px solid #D7D7D7;\r\n    padding: 2px 4px 1px 6px;\r\n    background-color: #FFFFFF;\r\n}\r\n\r\n.logGroup {\r\n    background: #FFFFFF linear-gradient(to bottom, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1) 18px, transparent 51px) repeat-x;\r\n    padding: 0;\r\n    border: none;\r\n}\r\n\r\n.logGroupBody {\r\n    display: none;\r\n    margin-left: 16px;\r\n    border-left: 1px solid #D7D7D7;\r\n    border-top: 1px solid #D7D7D7;\r\n    background: #FFFFFF;\r\n}\r\n\r\n.logGroup > .logRow {\r\n    background-color: transparent !important;\r\n    font-weight: bold;\r\n}\r\n\r\n.logGroup.opened > .logRow {\r\n    border-bottom: none;\r\n}\r\n\r\n.logGroup.opened > .logGroupBody {\r\n    display: block;\r\n}\r\n\r\n/*************************************************************************************************/\r\n\r\n.logRow-command > .objectBox-text {\r\n    font-family: monospace;\r\n    color: #0000FF;\r\n    white-space: pre-wrap;\r\n}\r\n\r\n.logRow-info,\r\n.logRow-warn,\r\n.logRow-error,\r\n.logRow-assert,\r\n.logRow-warningMessage,\r\n.logRow-loading,\r\n.logRow-errorMessage {\r\n    padding-left: 22px;\r\n    background-repeat: no-repeat;\r\n    background-position: 4px 2px;\r\n}\r\n\r\n.logRow-assert,\r\n.logRow-warningMessage,\r\n.logRow-errorMessage {\r\n    padding-top: 0;\r\n    padding-bottom: 0;\r\n}\r\n\r\n.logRow-info,\r\n.logRow-info .objectLink-sourceLink {\r\n    background-color: #EBF5FF;\r\n}\r\n\r\n.logRow-warn,\r\n.logRow-warningMessage,\r\n.logRow-warn .objectLink-sourceLink,\r\n.logRow-warningMessage .objectLink-sourceLink {\r\n    background-color: #FFFFC8;\r\n}\r\n\r\n.logRow-error,\r\n.logRow-assert,\r\n.logRow-errorMessage,\r\n.logRow-error .objectLink-sourceLink,\r\n.logRow-errorMessage .objectLink-sourceLink {\r\n    background-color: #FFEBEB;\r\n}\r\n\r\n.logRow-error,\r\n.logRow-assert,\r\n.logRow-errorMessage {\r\n    color: #FF0000;\r\n}\r\n\r\n.logRow-info {\r\n    background-image: url(chrome://firebug/skin/info.svg);\r\n}\r\n\r\n.logRow-loading {\r\n    background-image: url(chrome://firebug/skin/loading.svg);\r\n}\r\n\r\n.logRow-warn,\r\n.logRow-warningMessage {\r\n    background-image: url(chrome://firebug/skin/warning.svg);\r\n}\r\n\r\n.logRow-error,\r\n.logRow-assert,\r\n.logRow-errorMessage {\r\n    background-image: url(chrome://firebug/skin/error.svg);\r\n}\r\n\r\n/*************************************************************************************************/\r\n\r\n.inline {\r\n    display: inline;\r\n    white-space: normal;\r\n}\r\n\r\n.objectBox-string,\r\n.objectBox-text,\r\n.objectBox-number,\r\n.objectLink-element,\r\n.objectLink-textNode,\r\n.objectLink-function,\r\n.objectBox-stackTrace,\r\n.objectLink-profile,\r\n.objectBox-table {\r\n    font-family: monospace;\r\n}\r\n\r\n.objectBox-string,\r\n.objectBox-text,\r\n.objectLink-textNode,\r\n.objectBox-table {\r\n    white-space: pre-wrap;\r\n}\r\n\r\n.objectBox-number,\r\n.objectLink-styleRule,\r\n.objectLink-element,\r\n.objectLink-textNode {\r\n    color: #000088;\r\n}\r\n\r\n.objectBox-string {\r\n    color: #FF0000;\r\n}\r\n\r\n.objectLink-function,\r\n.objectBox-stackTrace,\r\n.objectLink-profile  {\r\n    color: DarkGreen;\r\n}\r\n\r\n.objectBox-null,\r\n.objectBox-undefined,\r\n.objectBox-hint,\r\n.logRowHint {\r\n    font-style: italic;\r\n    color: #787878;\r\n}\r\n\r\n.objectBox-scope {\r\n    color: #707070;\r\n}\r\n.objectBox-optimizedAway {\r\n    color: #909090;\r\n}\r\n\r\n.objectLink-sourceLink {\r\n    position: absolute;\r\n    right: 4px;\r\n    top: 2px;\r\n    padding-left: 8px;\r\n    font-family: Lucida Grande, sans-serif;\r\n    font-weight: bold;\r\n    color: #0000FF;\r\n}\r\n.objectLink-sourceLink > .systemLink {\r\n    float: right;\r\n    color: #FF0000;\r\n}\r\n\r\n.logRow > .objectLink-sourceLink > div,\r\n.errorSourceBox > .objectLink-sourceLink > div {\r\n    float: left;\r\n    padding-left: 5px;\r\n}\r\n\r\n/*************************************************************************************************/\r\n\r\n.errorTitle {\r\n    margin-top: 0px;\r\n    margin-bottom: 1px;\r\n    padding-top: 2px;\r\n    padding-bottom: 2px;\r\n}\r\n\r\n.errorTrace {\r\n    margin-left: 17px;\r\n    color: blue;\r\n}\r\n\r\n.errorDuplication {\r\n    margin-right: 5px;\r\n    font-weight: bold;\r\n}\r\n\r\n.errorSourceBox {\r\n    margin: 2px 0;\r\n}\r\n\r\n.errorSource-none {\r\n    display: none;\r\n}\r\n\r\n.errorSource-syntax > .errorBreak {\r\n    visibility: hidden;\r\n}\r\n\r\n.errorSource {\r\n    cursor: pointer;\r\n    font-family: monospace;\r\n    color: DarkGreen;\r\n}\r\n\r\n.errorSource:hover {\r\n    text-decoration: underline;\r\n}\r\n\r\n.errorColPosition {\r\n    -moz-user-select: none;\r\n    font-family: monospace;\r\n    color: DarkGreen;\r\n    display: inline-block;\r\n}\r\n\r\n.errorColCaret {\r\n    width: 7px;\r\n    height: 8px;\r\n    background: url(chrome://firebug/skin/console-error-caret.png) no-repeat;\r\n    display: inline-block;\r\n    vertical-align: top;\r\n    margin-left: 1px;\r\n}\r\n\r\n.errorBreak {\r\n    cursor: pointer;\r\n    display: none;\r\n    margin: 0 6px 0 0;\r\n    width: 13px;\r\n    height: 14px;\r\n    vertical-align: bottom;\r\n    background: url(chrome://firebug/skin/breakpoint.png) no-repeat;\r\n    opacity: 0.1;\r\n}\r\n\r\n.errorUnbreakable {\r\n    display: none;\r\n}\r\n\r\n.hasBreakSwitch .errorBreak {\r\n    display: inline;\r\n}\r\n\r\n.breakForError .errorBreak {\r\n    opacity: 1;\r\n}\r\n\r\n.assertDescription {\r\n    margin: 0;\r\n}\r\n\r\n/*************************************************************************************************/\r\n/* Profiler */\r\n\r\n.logRow-profile > .logRow > .objectBox-text {\r\n    font-family: Lucida Grande, Tahoma, sans-serif;\r\n    color: #000000;\r\n}\r\n\r\n.logRow-profile > .logRow > .objectBox-text:last-child {\r\n    color: #555555;\r\n    font-style: italic;\r\n}\r\n\r\n.logRow-profile.opened > .logRow {\r\n    padding-bottom: 4px;\r\n}\r\n\r\n.profilerRunning > .logRow {\r\n    background: transparent url(chrome://firebug/skin/loading.svg) no-repeat 2px 0 !important;\r\n    padding-left: 22px !important;\r\n}\r\n\r\n/* Remove left border for the log body. It will be applied to the profile table, so there\r\n   can be a little padding at the bottom when the profile-log is expanded */\r\n.logRow-profile .logGroupBody {\r\n    border-left: 0;\r\n}\r\n\r\n.logGroup .profileTable {\r\n    border: none;\r\n    border-left: 1px solid #D7D7D7;\r\n}\r\n\r\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\r\n\r\n.logRow-table {\r\n    padding: 0;\r\n}\r\n\r\n.profileSizer {\r\n    width: 100%;\r\n    padding-bottom: 5px;\r\n}\r\n\r\n.profileSizer:focus {\r\n    outline: none;\r\n}\r\n\r\n.profileTable TBODY {\r\n    overflow-x: hidden;\r\n    overflow-y: scroll;\r\n}\r\n\r\n.profileTable tr:nth-child(even) {\r\n    background-color: #EFEFEF;\r\n}\r\n\r\n.profileTable tr:nth-child(even) {\r\n    background-color: #EFEFEF;\r\n}\r\n\r\n.profileTable .profileSummaryRow {\r\n    height: 30px;\r\n    background: #BBBBBB !important;\r\n    font-weight: bold;\r\n}\r\n\r\n.profileTable a {\r\n    vertical-align:middle;\r\n}\r\n\r\n.profileTable td {\r\n    padding: 1px 4px 0 4px;\r\n}\r\n\r\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\r\n/* Profiler Header */\r\r\n.headerCell {\r\n    cursor: pointer;\r\n    -moz-user-select: none;\r\n    border-bottom: 1px solid #9C9C9C;\r\n    padding: 0 !important;\r\n    font-weight: bold;\r\n    background: #C8C8C8 linear-gradient(to bottom, rgba(255, 255, 255, 0.3), rgba(0, 0, 0, 0.2));\r\n}\r\n\r\n.headerCellBox {\r\n    padding: 2px 13px 2px 4px;\r\n    border-left: 1px solid #D9D9D9;\r\n    border-right: 1px solid #9C9C9C;\r\n    white-space: nowrap;\r\n}\r\n\r\n.headerCell:hover:active {\r\n    background-color: #B4B4B4;\r\n}\r\n\r\n.headerSorted {\r\n    background-color: #8CA0BE;\r\n}\r\n\r\n.headerSorted > .headerCellBox {\r\n    border-right-color: #6B7C93;\r\n    background: url(chrome://firebug/skin/arrowDown.png) no-repeat right;\r\n}\r\n\r\n.headerSorted.sortedAscending > .headerCellBox {\r\n    background-image: url(chrome://firebug/skin/arrowUp.png);\r\n}\r\n\r\n.headerSorted:hover:active {\r\n    background-color: #6E87AA;\r\n}\r\n\r\n.linkCell {\r\n    text-align: right;\r\n}\r\n\r\n.linkCell > .objectLink-sourceLink {\r\n    position: static;\r\n}\r\n\r\n.useA11y .profileTable *:focus {\r\n    outline-offset: -2px;\r\n}\r\n\r\n/*************************************************************************************************/\r\n/* Command Line Help */\r\n\r\n.logRow-help .logGroupBody {\r\n    border-bottom: 1px solid #D7D7D7;\r\n}\r\n\r\n.logRow-help .logGroupLabel {\r\n    text-decoration: none !important;\r\n}\r\n\r\n.logRow-help > .logRow {\r\n    background-position: 2px 3px !important;\r\n}\r\n\r\n.logRow-help .helpCaptionDesc {\r\n    color: gray;\r\n    font-weight: normal;\r\n    padding-left: 10px;\r\n}\r\n\r\n.logRow-help .helpTable {\r\n    margin-bottom: 4px;\r\n}\r\n\r\n.logRow-help .helpCell {\r\n    padding: 2px 4px 2px 4px;\r\n}\r\n\r\n.logRow-help .helpTable tr:nth-child(even) {\r\n    background-color: #EFEFEF;\r\n}\r\n\r\n.logRow-help .commandName .objectLink {\r\n    color: green;\r\n    font-family: monospace;\r\n}\r\n\r\n.logRow-help .commandDesc {\r\n    color: gray;\r\n}\r\n\r\n.logRow-help .tipsContent .tip {\r\n    margin-bottom: 5px;\r\n}\r\n\r\n.logRow-help .tipsContent .tip .example {\r\n    color: green;\r\n    font-family: monospace;\r\n}\r\n\r\n/*************************************************************************************************/\r\n\r\n.logRow-stackTrace {\r\n    padding-top: 0;\r\n    background: #F8F8F8;\r\n}\r\n\r\n.errorSourceBox {\r\n    position: relative;\r\n    padding-top: 2px;\r\n}\r\n\r\n/*************************************************************************************************/\r\n\r\n.objectLink-event,\r\n.objectLink-eventLog,\r\n.objectLink-regexp,\r\n.objectLink-object,\r\n.objectLink-Date {\r\n    font-family: Lucida Grande, sans-serif;\r\n    font-weight: bold;\r\n    color: DarkGreen;\r\n    white-space: pre-wrap;\r\n}\r\n\r\n.objectPropValue {\r\n    font-weight: normal;\r\n    font-style: italic;\r\n    color: #555555;\r\n}\r\n\r\n.storageTitle {\r\n    font-weight: normal;\r\n}\r\n\r\n.objectLink-regexp > .regexpSource {\r\n    padding-right: 4px;\r\n    font-weight: normal;\r\n    font-family: Monaco, monospace;\r\n}\r\n\r\n\r\n/************************************************************************************************/\r\n\r\n.objectLink-NamedNodeMap .nodeName,\r\n.objectLink-NamedNodeMap .objectEqual,\r\n.objectLink-NamedNodeMap .arrayLeftBracket,\r\n.objectLink-NamedNodeMap .arrayRightBracket,\r\n.objectLink-Attr .attrEqual,\r\n.objectLink-Attr .attrTitle {\r\n    color: rgb(0, 0, 136)\r\n}\r\n\r\n/************************************************************************************************/\r\n\r\n.selectorTag,\r\n.selectorId,\r\n.selectorClass {\r\n    font-family: monospace;\r\n    font-weight: normal;\r\n}\r\n\r\n.selectorTag {\r\n    color: #0000FF;\r\n}\r\n\r\n.selectorId {\r\n    color: DarkBlue;\r\n}\r\n\r\n.selectorClass {\r\n    color: red;\r\n}\r\n\r\n.selectorHidden > .selectorTag {\r\n    color: #5F82D9;\r\n}\r\n\r\n.selectorHidden > .selectorId {\r\n    color: #888888;\r\n}\r\n\r\n.selectorHidden > .selectorClass {\r\n    color: #D86060;\r\n}\r\n\r\n.selectorValue {\r\n    font-family: Lucida Grande, sans-serif;\r\n    font-style: italic;\r\n    color: #555555;\r\n}\r\n\r\n/*****************************************************************************************/\r\n\r\n.panelNode.searching .logRow,\r\n.panelNode.searching .logRow-group > .objectLink {\r\n    display: none;\r\n}\r\n\r\n.panelNode.hideType-error .logRow-error,\r\n.panelNode.hideType-error .logRow-errorMessage,\r\n.panelNode.hideType-warning .logRow-warn,\r\n.panelNode.hideType-warning .logRow-warningMessage,\r\n.panelNode.hideType-info .logRow-info,\r\n.panelNode.hideType-debug .logRow-debug,\r\n.panelNode.hideType-profile .logRow-profile,\r\n.panelNode.hideType-table .logRow-table,\r\n.panelNode.hideType-group .logRow-group,\r\n.panelNode.hideType-command .logRow-command,\r\n.panelNode.hideType-stackTrace .logRow-stackTrace,\r\n.panelNode.hideType-log .logRow-log,\r\n.panelNode.hideType-dir .logRow-dir,\r\n.panelNode.hideType-assert .logRow-assert,\r\n.panelNode.hideType-spy .logRow-spy {\r\n    display: none !important;\r\n}\r\n\r\n.logRow.matched {\r\n    display: block !important;\r\n}\r\n\r\n.logRow.matching {\r\n    position: absolute;\r\n    left: -1000px;\r\n    top: -1000px;\r\n    max-width: 0;\r\n    max-height: 0;\r\n    overflow: hidden;\r\n}\r\n\r\n/*****************************************************************************************/\r\n\r\n.objectLeftBrace,\r\n.objectRightBrace,\r\n.objectEqual,\r\n.objectComma,\r\n.arrayLeftBracket,\r\n.arrayRightBracket,\r\n.arrayComma {\r\n    font-family: monospace;\r\n}\r\n\r\n.objectLeftBrace,\r\n.objectRightBrace,\r\n.arrayLeftBracket,\r\n.arrayRightBracket {\r\n    font-weight: bold;\r\n}\r\n\r\n.objectLeftBrace,\r\n.arrayLeftBracket {\r\n    margin-right: 4px;\r\n}\r\n\r\n.objectRightBrace,\r\n.arrayRightBracket {\r\n    margin-left: 4px;\r\n}\r\n\r\n/*************************************************************************************************/\r\n/* Cycle reference*/\r\n\r\n.objectLink-Reference {\r\n    font-family: monospace;\r\n    font-weight: bold;\r\n    color: rgb(102, 102, 255);\r\n}\r\n\r\n/*************************************************************************************************/\r\n\r\n.logRow-dir {\r\n    padding: 0;\r\n}\r\n\r\n/*************************************************************************************************/\r\n\r\n.logRow-errorMessage > .hasTwisty > .errorTitle,\r\n.logRow-spy .spyHead .spyTitle,\r\n.logGroup > .logRow {\r\n    cursor: pointer;\r\n    padding-left: 18px;\r\n    background-repeat: no-repeat;\r\n    background-position: 3px 3px;\r\n}\r\n\r\n.logRow-errorMessage > .hasTwisty > .errorTitle {\r\n    background-position: 2px 3px;\r\n}\r\n\r\n.logRow-errorMessage > .hasTwisty > .errorTitle:hover,\r\n.logRow-spy .spyHead .spyTitle:hover,\r\n.logGroup > .logRow:hover {\r\n    text-decoration: underline;\r\n}\r\n\r\n.logRow-errorMessage .errorTitle > .errorMessage {\r\n    white-space: pre-wrap;\r\n}\r\n\r\n/*****************************************************************************************/\r\n\r\n.logRow-log .objectBox-array.hasTwisty {\r\n    padding-left: 18px;\r\n}\r\n\r\n.logRow-log .objectBox-array > .arrayProperties:not(:empty) {\r\n    padding-left: 18px;\r\n}\r\n\r\n.objectBox-array > .objectTitle {\r\n    font-weight: bold;\r\n    color: DarkGreen;\r\n}\r\n\r\n/*****************************************************************************************/\r\n\r\n.logRow-spy,\r\n.logRow-spy .objectLink-sourceLink {\r\n    background: #FFFFFF linear-gradient(to bottom, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1) 18px, transparent 51px) repeat-x;\r\n    padding-right: 4px;\r\n    right: 0;\r\n}\r\n\r\n/* padding-right should be zero for .logRow-spy, so declare after the previous selector */\r\n.logRow-spy {\r\n    padding: 0px 0 1px 0;\r\n}\r\n\r\n.logRow-spy.opened {\r\n    padding-bottom: 4px;\r\n    border-bottom: none;\r\n}\r\n\r\n.spyTitle {\r\n    color: #000000;\r\n    font-weight: bold;\r\n    -moz-box-sizing: padding-box;\r\n    overflow: hidden;\r\n    z-index: 100;\r\n    padding-left: 18px;\r\n}\r\n\r\n.spyCol {\r\n    padding: 0;\r\n    white-space: nowrap;\r\n}\r\n\r\n.spyTitleCol:hover > .objectLink-sourceLink,\r\n.spyTitleCol:hover > .spyTime,\r\n.spyTitleCol:hover > .spyStatus,\r\n.spyTitleCol:hover > .spyTitle {\r\n    display: none;\r\n}\r\n\r\n.spyFullTitle {\r\n    display: none;\r\n    -moz-user-select: none;\r\n    max-width: 100%;\r\n    background-color: Transparent;\r\n}\r\n\r\n.spyTitleCol:hover > .spyFullTitle {\r\n    display: block;\r\n}\r\n\r\n.spyStatus {\r\n    padding-left: 10px;\r\n    color: rgb(128, 128, 128);\r\n}\r\n\r\n.spyTime {\r\n    margin-left:4px;\r\n    margin-right:4px;\r\n    color: rgb(128, 128, 128);\r\n}\r\n\r\n.spyIcon {\r\n    margin-right: 4px;\r\n    margin-left: 4px;\r\n    width: 16px;\r\n    height: 16px;\r\n    vertical-align: middle;\r\n    background: transparent no-repeat 0 0;\r\n}\r\n\r\n.logRow-spy.loading .spyHead .spyRow .spyIcon {\r\n    background-image: url(chrome://firebug/skin/loading.svg);\r\n}\r\n\r\n.logRow-spy.loaded:not(.error) .spyHead .spyRow .spyIcon {\r\n    width: 0;\r\n    margin: 0;\r\n}\r\n\r\n.logRow-spy.error .spyHead .spyRow .spyIcon {\r\n    background-image: url(chrome://firebug/skin/errorIcon-sm.png);\r\n    background-position: 2px 2px;\r\n}\r\n\r\n.logRow-spy .spyHead .netInfoBody {\r\n    display: none;\r\n}\r\n\r\n.logRow-spy.opened .spyHead .netInfoBody {\r\n    margin-top: 10px;\r\n    display: block;\r\n}\r\n\r\n.logRow-spy.error .spyTitle,\r\n.logRow-spy.error .spyStatus,\r\n.logRow-spy.error .spyTime {\r\n    color: red;\r\n}\r\n\r\n.logRow-spy.loading .spyResponseText {\r\n    font-style: italic;\r\n    color: #888888;\r\n}\r\n\r\n/************************************************************************************************/\r\n\r\n.caption {\r\n    font-family: Lucida Grande, Tahoma, sans-serif;\r\n    font-weight: bold;\r\n    color:  #444444;\r\n}\r\n\r\n.warning {\r\n    padding: 10px;\r\n    font-family: Lucida Grande, Tahoma, sans-serif;\r\n    font-weight: bold;\r\n    color:  #888888;\r\n}\r\n\r\n/************************************************************************************************/\r\n\r\n/* The panel content is always visible within the command popup on other panels */\r\n.commandPopup .panelNode-console {\r\n    display: block;\r\n}\r\n\r\n/************************************************************************************************/\r\n/* console.timeStamp */\r\n\r\n.logRow-timeStamp {\r\n    color: Olive;\r\n    font-family: Lucida Grande, Tahoma, sans-serif;\r\n}\r\n\r\n.logRow-timeStamp SPAN:last-child {\r\n    font-style: italic;\r\n    color: gray;\r\n    padding-left: 5px;\r\n}\r\n\r\n\r\n/************************************************************************************************/\r\n/* include */\r\n.tableCommandLineInclude td{\r\n    height: 17px;\r\n}\r\n.tableCommandLineInclude .closeButton{\r\n    display: none;\r\n}\r\n\r\n.tableCommandLineInclude tr:hover .closeButton{\r\n    display: block;\r\n}\r\n.tableCommandLineInclude .url{ float: left; }\r\n\r\n.tableCommandLineInclude .commands{ \r\n    float: right;\r\n    height:100%;\r\n}\r\n.tableCommandLineInclude td:last-child\r\n{\r\n    width: 75%;\r\n    padding-right: 0 !important; \r\n}\r\n"
          },
          "redirectURL": "",
          "headersSize": 349,
          "bodySize": 17480
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "connect": 0,
          "send": 0,
          "wait": 79,
          "receive": 173
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:17.459+01:00",
        "time": 247,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/css/domTree.css",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "text/css,*/*;q=0.1"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/css/main.css"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 316,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:48 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:35 GMT"
            },
            {
              "name": "Etag",
              "value": "\"12eb98e-658-4d73309d376c0\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "1624"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=604800"
            },
            {
              "name": "Expires",
              "value": "Wed, 13 Mar 2013 07:11:48 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=50"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "text/css"
            }
          ],
          "content": {
            "mimeType": "text/css",
            "size": 1621,
            "text": "/* See license.txt for terms of usage */\n\n.domTable {\n}\n\n.memberLabelCell {\n    padding: 2px 50px 2px 0;\n    vertical-align: top;\n}\n\n.memberValueCell {\n    padding: 1px 0 1px 5px;\n    overflow: hidden;\n}\n\n.memberLabel {\n    cursor: default;\n    -moz-user-select:  none;\n    overflow: hidden;\n    /*position: absolute;*/\n    padding-left: 18px;\n    /*max-width: 30%;*/    \n    white-space: nowrap;\n    /* background-color: #FFFFFF; breaks row highlighting */ \n}\n\n.memberRow.hasChildren.opened > .memberLabelCell > .memberLabel {\n    background-image: url(images/twisty-sprites.png);\n    background-position: 3px -16px;\n    background-color: transparent;\n}\n\n.memberRow.hasChildren > .memberLabelCell > .memberLabel:hover {\n    cursor: pointer;\n    color: blue;\n    text-decoration: underline;\n}\n\n.memberRow.hasChildren > .memberLabelCell > .memberLabel {\n    background-image: url(images/twisty-sprites.png);\n    background-repeat: no-repeat;\n    background-position: 3px 3px;\n}\n\n/*************************************************************************************************/\n\n.jumpHighlight {\n    background-color: #C4F4FF !important;\n}\n\n/*************************************************************************************************/\n\n.objectBox-object {\n    color: gray;\n}\n\n.objectBox-number {\n    color: #000088;\n}\n\n.objectBox-string {\n    color: #FF0000;\n    white-space: pre-wrap;\n}\n\n.objectBox-null,\n.objectBox-undefined {\n    font-style: italic;\n    color: #787878;\n}\n\n.objectBox-array {\n    color: gray;\n}\n\n/*************************************************************************************************/\n"
          },
          "redirectURL": "",
          "headersSize": 347,
          "bodySize": 1624
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 6,
          "connect": 74,
          "send": 0,
          "wait": 167,
          "receive": 0
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:18.337+01:00",
        "time": 32,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/scripts/main.js",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 289,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:49 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:38 GMT"
            },
            {
              "name": "Etag",
              "value": "\"12eb9d2-a29-4d7330a013d80\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "2601"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=30"
            },
            {
              "name": "Expires",
              "value": "Wed, 06 Mar 2013 07:12:19 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=41"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "application/javascript"
            }
          ],
          "content": {
            "mimeType": "application/javascript",
            "size": 2601,
            "text": "/* See license.txt for terms of usage */\n\ndefine([\n    \"differ\",\n    \"provider\",\n    \"domplate/domTree\",\n    \"domDiffTree\",\n],\nfunction(Differ, Provider, DomTree, DomDiffTree) {\n\n// ********************************************************************************************* //\n// The Application\n\nfunction JsonDiff()\n{\n}\n\n/**\n * The main application\n */\nJsonDiff.prototype =\n/** @lends JsonDiff */\n{\n    initialize: function initialize(content)\n    {\n        var mom = {\n            name: \"Anna\",\n            surname: \"Smith\",\n            age: 67,\n        }\n\n        var father = {\n            name: \"Johnas\",\n            surname: \"Smith\",\n            age: 69,\n        }\n\n        var myObject1 = {\n            name: \"Bob\",\n            age: 41,\n            son: {\n                age: 13,\n            },\n            daughter: {\n                name: \"Lola\"\n            },\n            mom: mom,\n            father: father,\n            wife: {\n                name: \"Kathrin\",\n                surname: \"Smith\",\n                age: 40,\n                job: \"Teacher\",\n                // cycle husband: myObject1,\n            },\n        }\n\n        var myObject2 = {\n            name: \"Bob\",\n            age: 53,\n            son: {\n                name: \"K\",\n                age: 15,\n            },\n            wife: {\n                name: \"Katherine\",\n                surname: \"Jones\",\n                age: 40,\n                job: \"Teacher\",\n            },\n            mom: mom,\n            father: father,\n        }\n\n        // Test\n        var differ = new Differ();\n        var result = [];\n        differ.diff(myObject1, myObject2, result);\n\n        console.log(\"Differences:\", result);\n\n        // Render log structure as an expandable tree.\n        var provider = new Provider(result);\n        var domTree = new DomDiffTree(provider);\n        domTree.replace(content, result);\n\n        var domTree1 = new DomTree();\n        domTree1.replace(document.getElementById(\"oldObject\"), myObject1);\n\n        var domTree2 = new DomTree();\n        domTree2.replace(document.getElementById(\"newObject\"), myObject2);\n\n        var domTree3 = new DomTree();\n        domTree3.replace(document.getElementById(\"differences\"), result);\n    },\n}\n\n// ********************************************************************************************* //\n\n// Application's entry point.\nvar content = document.getElementById(\"content\");\nvar JsonDiff = content.repObject = new JsonDiff();\nJsonDiff.initialize(content);\n\n// ********************************************************************************************* //\n});\n"
          },
          "redirectURL": "",
          "headersSize": 357,
          "bodySize": 2601
        },
        "cache": {},
        "timings": {
          "blocked": 1,
          "dns": 0,
          "connect": 0,
          "send": 0,
          "wait": 31,
          "receive": 0
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:18.419+01:00",
        "time": 95,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/scripts/differ.js",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 291,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:49 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:35 GMT"
            },
            {
              "name": "Etag",
              "value": "\"12eb9c2-841-4d73309d376c0\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "2113"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=30"
            },
            {
              "name": "Expires",
              "value": "Wed, 06 Mar 2013 07:12:19 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=40"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "application/javascript"
            }
          ],
          "content": {
            "mimeType": "application/javascript",
            "size": 2113,
            "text": "/* See license.txt for terms of usage */\n\ndefine([\n],\nfunction() {\n\n// ********************************************************************************************* //\n// The Application\n\nfunction Differ()\n{\n}\n\nDiffer.prototype =\n{\n    diff: function diff(first, second, members)\n    {\n        var props = [];\n\n        // Get all properties from both objects\n        if (typeof first == \"object\")\n            props.push.apply(props, Object.keys(first));\n        if (typeof second == \"object\")\n            props.push.apply(props, Object.keys(second));\n\n        // Bail out if there are no properties.\n        if (!props.length)\n            return;\n\n        // Make sure to have each property just once.\n        var map = {};\n        for (var p in props)\n            map[props[p]] = true;\n\n        // Iterate over all properties in both objects.\n        var diff = false;\n        for (var prop in map)\n        {\n            var value1 = first ? first[prop] : undefined;\n            var value2 = second ? second[prop] : undefined;\n\n            var member = {\n                name: prop,\n                value1: value1,\n                value2: value2,\n                first: first,\n                second: second,\n                children: [],\n                diff: false,\n            }\n\n            members.push(member);\n\n            if (typeof member.value1 != \"object\" &&\n                typeof member.value2 != \"object\")\n            {\n                if (member.value1 != member.value2)\n                    diff = member.diff = true;\n            }\n\n            // Recursion\n            member.diff = this.diff(value1, value2, member.children);\n\n            if (member.diff)\n                diff = true;\n        }\n\n        // Returns true if:\n        // 1) A property of first/second objects is different\n        // 2) A property from child objects is different.\n        return diff;\n    }\n}\n\n// ********************************************************************************************* //\n\nreturn Differ;\n\n// ********************************************************************************************* //\n});\n"
          },
          "redirectURL": "",
          "headersSize": 357,
          "bodySize": 2113
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "connect": 0,
          "send": 0,
          "wait": 94,
          "receive": 1
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:18.419+01:00",
        "time": 105,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/scripts/provider.js",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 293,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:49 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:38 GMT"
            },
            {
              "name": "Etag",
              "value": "\"12eb9d3-68f-4d7330a013d80\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "1679"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=30"
            },
            {
              "name": "Expires",
              "value": "Wed, 06 Mar 2013 07:12:19 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=48"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "application/javascript"
            }
          ],
          "content": {
            "mimeType": "application/javascript",
            "size": 1679,
            "text": "/* See license.txt for terms of usage */\n\ndefine([\n    \"core/lib\",\n    \"jsdiff\",\n],\nfunction(Lib, JSDiff) {\n\n// ********************************************************************************************* //\n// The Application\n\nfunction Provider(diffResult)\n{\n    this.diffResult = diffResult;\n}\n\nProvider.prototype =\n{\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n    // Provider\n\n    getLabel: function(member)\n    {\n        return member.name;\n    },\n\n    getValue: function(member, colName)\n    {\n        if (colName == \"old\")\n            return member.value1;\n        else if (colName == \"new\")\n            return member.value2;\n    },\n\n    hasChildren: function(member)\n    {\n        if (member.children)\n            return member.children.length > 0;\n        return false;\n    },\n\n    getChildren: function(member)\n    {\n        if (Lib.isArray(member))\n            return member;\n        return member.children;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n    // Decorator\n\n    getType: function(member)\n    {\n        if (member.diff)\n            return \"different\";\n\n        if (typeof member.value1 == \"object\" && typeof member.value2 == \"object\")\n            return \"object\";\n\n        if (member.value1 != member.value2)\n            return \"different\";\n        else\n            return \"equal\";\n\n        return null;\n    }\n}\n\n// ********************************************************************************************* //\n\nreturn Provider;\n\n// ********************************************************************************************* //\n});\n"
          },
          "redirectURL": "",
          "headersSize": 357,
          "bodySize": 1679
        },
        "cache": {},
        "timings": {
          "blocked": 1,
          "dns": 0,
          "connect": 0,
          "send": 0,
          "wait": 93,
          "receive": 11
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:18.419+01:00",
        "time": 102,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/scripts/domplate/domTree.js",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 301,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:49 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:41 GMT"
            },
            {
              "name": "Etag",
              "value": "\"12eba60-210a-4d7330a2f0440\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "8458"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=30"
            },
            {
              "name": "Expires",
              "value": "Wed, 06 Mar 2013 07:12:19 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=49"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "application/javascript"
            }
          ],
          "content": {
            "mimeType": "application/javascript",
            "size": 8458,
            "text": "/* See license.txt for terms of usage */\n\nrequire.def(\"domplate/domTree\", [\n    \"domplate/domplate\",\n    \"core/lib\",\n    \"core/trace\",\n    \"domplate/reps\",\n],\n\nfunction(Domplate, Lib, Trace, Reps) { with (Domplate) {\n\n// ********************************************************************************************* //\n\nfunction DomTree(provider)\n{\n    this.provider = provider;\n}\n\n/**\n* @domplate Represents a tree of properties/objects\n*/\nDomTree.prototype = domplate(\n{\n    tag:\n        TABLE({\"class\": \"domTable\", cellpadding: 0, cellspacing: 0, onclick: \"$onClick\"},\n            TBODY(\n                FOR(\"member\", \"$object|memberIterator\",\n                    TAG(\"$member|getRowTag\", {member: \"$member\"}))\n            )\n        ),\n\n    rowTag:\n        TR({\"class\": \"memberRow $member.open $member.type\\\\Row $member|hasChildren\",\n            _repObject: \"$member\", level: \"$member.level\"},\n            TD({\"class\": \"memberLabelCell\", style: \"padding-left: $member|getIndent\\\\px\"},\n                SPAN({\"class\": \"memberLabel $member.type\\\\Label\"}, \"$member|getLabel\")\n            ),\n            TD({\"class\": \"memberValueCell\"},\n                TAG(\"$member|getValueTag\", {object: \"$member|getValue\"})\n            )\n        ),\n\n    loop:\n        FOR(\"member\", \"$members\",\n            TAG(\"$member|getRowTag\", {member: \"$member\"})),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n    hasChildren: function(object)\n    {\n        return object.hasChildren ? \"hasChildren\" : \"\";\n    },\n\n    getIndent: function(member)\n    {\n        return member.level * 16;\n    },\n\n    getLabel: function(member)\n    {\n        if (member.provider)\n            return member.provider.getLabel(member.value);\n\n        return member.name;\n    },\n\n    getValue: function(member)\n    {\n        if (member.provider)\n            return member.provider.getValue(member.value);\n        return member.value;\n    },\n\n    getValueTag: function(member)\n    {\n        // Get proper UI template for the value.\n        var value = this.getValue(member);\n        var valueTag = Reps.getRep(value);\n        return valueTag.tag;\n    },\n\n    getRowTag: function(member)\n    {\n        return this.rowTag;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n    // Evenet Handlers\n\n    onClick: function(event)\n    {\n        var e = Lib.fixEvent(event);\n        if (!Lib.isLeftClick(e))\n            return;\n\n        var row = Lib.getAncestorByClass(e.target, \"memberRow\");\n        var label = Lib.getAncestorByClass(e.target, \"memberLabel\");\n        if (label && Lib.hasClass(row, \"hasChildren\"))\n            this.toggleRow(row);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n    toggleRow: function(row, forceOpen)\n    {\n        if (!row)\n            return;\n\n        var level = parseInt(row.getAttribute(\"level\"));\n        if (forceOpen && Lib.hasClass(row, \"opened\"))\n            return;\n\n        if (Lib.hasClass(row, \"opened\"))\n        {\n            Lib.removeClass(row, \"opened\");\n\n            var tbody = row.parentNode;\n            for (var firstRow = row.nextSibling; firstRow; firstRow = row.nextSibling)\n            {\n                if (parseInt(firstRow.getAttribute(\"level\")) <= level)\n                    break;\n                tbody.removeChild(firstRow);\n            }\n        }\n        else\n        {\n            Lib.setClass(row, \"opened\");\n\n            var repObject = row.repObject;\n            if (repObject)\n            {\n                if (!repObject.hasChildren)\n                    return;\n\n                var members = this.getMembers(repObject.value, level+1);\n                if (members && members.length)\n                    this.loop.insertRows({members: members}, row);\n                else\n                    Lib.setClass(row, \"spinning\");\n\n            }\n        }\n    },\n\n    memberIterator: function(object)\n    {\n        return this.getMembers(object);\n    },\n\n    getMembers: function(object, level)\n    {\n        if (!level)\n            level = 0;\n\n        var members = [];\n\n        if (this.provider)\n        {\n            var children = this.provider.getChildren(object);\n            for (var i=0; children && i<children.length; i++)\n            {\n                var child = children[i];\n                var hasChildren = this.provider.hasChildren(child);\n                var type = this.provider.getType(child) || \"dom\";\n\n                var member = this.createMember(type, null, child, level, hasChildren);\n                member.provider = this.provider;\n                members.push(member);\n            }\n            return members;\n        }\n\n        for (var p in object)\n        {\n            var value = object[p];\n            var valueType = typeof(value);\n            var hasChildren = this.hasProperties(value) && (valueType == \"object\");\n\n            members.push(this.createMember(\"dom\", p, value, level, hasChildren));\n        }\n\n        return members;\n    },\n\n    createMember: function(type, name, value, level, hasChildren)\n    {\n        var member = {\n            name: name,\n            type: type,\n            rowClass: \"memberRow-\" + type,\n            open: \"\",\n            level: level,\n            hasChildren: hasChildren,\n            value: value,\n        };\n\n        return member;\n    },\n\n    hasProperties: function(ob)\n    {\n        if (typeof(ob) == \"string\")\n            return false;\n\n        try {\n            for (var name in ob)\n                return true;\n        } catch (exc) {}\n        return false;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n    // Public\n\n    append: function(parentNode, input)\n    {\n        this.parentNode = parentNode;\n        this.element = this.tag.append({object: input}, parentNode, this);\n        this.element.repObject = this;\n\n        this.input = input;\n\n        // Expand the first node (root) by default\n        // Do not expand if the root is an array with more than one element.\n        var value = Lib.isArray(input) && input.length > 2;\n        var firstRow = this.element.firstChild.firstChild;\n        if (firstRow && !value)\n            this.toggleRow(firstRow);\n    },\n\n    // xxxHonza: put into the core object.\n    replace: function(parentNode, input)\n    {\n        Lib.clearNode(parentNode);\n        this.append(parentNode, input);\n    },\n\n    expandRow: function(object)\n    {\n        var row = this.getRow(object);\n        this.toggleRow(row, true);\n        return row;\n    },\n\n    getRow: function(object)\n    {\n        // If not rendered yet, bail out.\n        if (!this.element)\n            return;\n\n        // Iterate all existing rows and expand the one associated with specified object.\n        // The repObject is a \"member\" object created in createMember method.\n        var rows = Lib.getElementsByClass(this.element, \"memberRow\");\n        for (var i=0; i<rows.length; i++)\n        {\n            var row = rows[i];\n            if (row.repObject.value == object)\n                return row;\n        }\n\n        return null;\n    },\n\n    updateObject: function(object)\n    {\n        var row = this.getRow(object);\n\n        // The input object itself doesn't have a row.\n        if (this.input == object)\n        {\n            var members = this.getMembers(object);\n            if (members)\n                this.loop.insertRows({members: members}, this.element.firstChild);\n            return;\n        }\n\n        if (!row)\n            return;\n\n        var member = row.repObject;\n        member.hasChildren = this.provider.hasChildren(object);\n\n        // Generate new row with new value.\n        var rowTag = this.getRowTag();\n        var rows = rowTag.insertRows({member: member}, row, this);\n\n        // If the old row was expanded remember it.\n        var expanded = Lib.hasClass(row, \"opened\");\n\n        // Remove the old row before expanding the new row,otherwise the old one\n        // would be expanded and consequently removed.\n        row.parentNode.removeChild(row);\n\n        if (expanded)\n            this.expandRow(object);\n\n        Lib.removeClass(row, \"spinning\");\n    },\n});\n\n// ********************************************************************************************* //\n\nreturn DomTree;\n\n// ********************************************************************************************* //\n}});\n"
          },
          "redirectURL": "",
          "headersSize": 358,
          "bodySize": 8458
        },
        "cache": {},
        "timings": {
          "blocked": 1,
          "dns": 0,
          "connect": 0,
          "send": 0,
          "wait": 95,
          "receive": 6
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:18.420+01:00",
        "time": 198,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/scripts/domDiffTree.js",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 296,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:49 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:36 GMT"
            },
            {
              "name": "Etag",
              "value": "\"12eb9c8-e6e-4d73309e2b900\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "3694"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=30"
            },
            {
              "name": "Expires",
              "value": "Wed, 06 Mar 2013 07:12:19 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=50"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "application/javascript"
            }
          ],
          "content": {
            "mimeType": "application/javascript",
            "size": 3694,
            "text": "/* See license.txt for terms of usage */\n\ndefine([\n    \"domplate/domplate\",\n    \"domplate/domTree\",\n    \"domplate/reps\",\n    \"core/trace\",\n    \"diffObj\",\n],\n\nfunction(Domplate, DomTree, Reps, Trace, DiffObj) { with (Domplate) {\n\n// ********************************************************************************************* //\n\nfunction DomDiffTree(provider)\n{\n    this.provider = provider;\n}\n\n/**\n* @domplate Represents a tree of properties/objects\n*/\nDomDiffTree.prototype = domplate(new DomTree(),\n{\n    rowTag:\n        TR({\"class\": \"memberRow $member.open $member.type\\\\Row $member|hasChildren\",\n            _repObject: \"$member\", level: \"$member.level\"},\n            TD({\"class\": \"memberHeaderCell\"},\n                DIV({\"class\": \"sourceLine memberRowHeader\"},\n                    \"&nbsp;\"\n                )\n            ),\n            TD({\"class\": \"memberLabelCell\", style: \"padding-left: $member|getIndent\\\\px\"},\n                SPAN({\"class\": \"memberLabel $member.type\\\\Label\"}, \"$member|getLabel\")\n            ),\n            TD({\"class\": \"memberValueCell\"},\n                SPAN({\"class\": \"memberValueWrapper oldValue\"},\n                    TAG(\"$member|getDiffValueTag\", {object: \"$member|getDiffValue\"})\n                )\n            ),\n            TD({\"class\": \"memberSeparator\", width: \"10px\"}),\n            TD({\"class\": \"memberLabelCell\", style: \"padding-left: $member|getIndent\\\\px\"},\n                SPAN({\"class\": \"memberLabel $member.type\\\\Label\"}, \"$member|getLabel\")\n            ),\n            TD({\"class\": \"memberValueCell\"},\n                TAG(\"$member|getValueTag2\", {object: \"$member|getValue2\"})\n            )\n        ),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n    getValue1: function(member)\n    {\n        if (member.provider)\n            return member.provider.getValue(member.value, \"old\");\n        return member.value;\n    },\n\n    getValue2: function(member)\n    {\n        if (member.provider)\n            return member.provider.getValue(member.value, \"new\");\n        return member.value;\n    },\n\n    getValueTag1: function(member)\n    {\n        var value = this.getValue1(member);\n        var valueRep = Reps.getRep(value);\n        if (valueRep == Reps.Rep)\n            return Reps.Obj.shortTag;\n\n        return valueRep.tag;\n    },\n\n    getValueTag2: function(member)\n    {\n        var value = this.getValue2(member);\n        var valueRep = Reps.getRep(value);\n        if (valueRep == Reps.Rep)\n            return Reps.Obj.shortTag;\n\n        return valueRep.tag;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n    getDiffValue: function(member)\n    {\n        var value1 = this.getValue1(member);\n        var value2 = this.getValue2(member);\n\n        if (value1 && value2 && typeof(value1) == \"object\" && typeof(value2) == \"object\")\n            return member.value.children;\n\n        return this.getValue1(member);\n    },\n\n    getDiffValueTag: function(member)\n    {\n        var value1 = this.getValue1(member);\n        var value2 = this.getValue2(member);\n\n        if (value1 && value2 && typeof(value1) == \"object\" && typeof(value2) == \"object\")\n            return DiffObj.tag;\n\n        return this.getValueTag1(member);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n    getRowTag: function(member)\n    {\n        return this.rowTag;\n    },\n});\n\n// ********************************************************************************************* //\n\nreturn DomDiffTree;\n\n// ********************************************************************************************* //\n}});\n"
          },
          "redirectURL": "",
          "headersSize": 357,
          "bodySize": 3694
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "connect": 93,
          "send": 0,
          "wait": 104,
          "receive": 1
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:18.576+01:00",
        "time": 78,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/scripts/domplate/domplate.js",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 302,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:49 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:41 GMT"
            },
            {
              "name": "Etag",
              "value": "\"12eba41-7729-4d7330a2f0440\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "30505"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=30"
            },
            {
              "name": "Expires",
              "value": "Wed, 06 Mar 2013 07:12:19 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=39"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "application/javascript"
            }
          ],
          "content": {
            "mimeType": "application/javascript",
            "size": 30505,
            "text": "/* See license.txt for terms of usage */\n\nrequire.def(\"domplate/domplate\", [], function() {\n\n//*************************************************************************************************\n\nDomplate = {};\n\n(function(){\n\nfunction DomplateTag(tagName)\n{\n    this.tagName = tagName;\n}\n\nthis.DomplateTag = DomplateTag;\n\nfunction DomplateEmbed()\n{\n}\n\nfunction DomplateLoop()\n{\n}\n\nvar womb = null;\n\nvar domplate = function()\n{\n    var lastSubject;\n    for (var i = 0; i < arguments.length; ++i)\n        lastSubject = lastSubject ? copyObject(lastSubject, arguments[i]) : arguments[i];\n\n    for (var name in lastSubject)\n    {\n        var val = lastSubject[name];\n        if (isTag(val))\n        {\n            if (val.tag.subject)\n            {\n                lastSubject[name] = val = copyObject({}, val);\n                val.tag = copyObject({}, val.tag);\n            }\n            val.tag.subject = lastSubject;\n        }\n    }\n\n    return lastSubject;\n};\n\ndomplate.context = function(context, fn)\n{\n    var lastContext = domplate.lastContext;\n    domplate.topContext = context;\n    fn.apply(context);\n    domplate.topContext = lastContext;\n};\n\nthis.domplate = domplate;\nthis.create = domplate;\n\n\nthis.TAG = function()\n{\n    var embed = new DomplateEmbed();\n    return embed.merge(arguments);\n};\n\nthis.FOR = function()\n{\n    var loop = new DomplateLoop();\n    return loop.merge(arguments);\n};\n\nDomplateTag.prototype =\n{\n    merge: function(args, oldTag)\n    {\n        if (oldTag)\n            this.tagName = oldTag.tagName;\n\n        this.context = oldTag ? oldTag.context : null;\n        this.subject = oldTag ? oldTag.subject : null;\n        this.attrs = oldTag ? copyObject(oldTag.attrs) : {};\n        this.classes = oldTag ? copyObject(oldTag.classes) : {};\n        this.props = oldTag ? copyObject(oldTag.props) : null;\n        this.listeners = oldTag ? copyArray(oldTag.listeners) : null;\n        this.children = oldTag ? copyArray(oldTag.children) : [];\n        this.vars = oldTag ? copyArray(oldTag.vars) : [];\n\n        var attrs = args.length ? args[0] : null;\n        var hasAttrs = typeof(attrs) == \"object\" && !isTag(attrs);\n\n        this.children = [];\n\n        if (domplate.topContext)\n            this.context = domplate.topContext;\n\n        if (args.length)\n            parseChildren(args, hasAttrs ? 1 : 0, this.vars, this.children);\n\n        if (hasAttrs)\n            this.parseAttrs(attrs);\n\n        return creator(this, DomplateTag);\n    },\n\n    parseAttrs: function(args)\n    {\n        for (var name in args)\n        {\n            var val = parseValue(args[name]);\n            readPartNames(val, this.vars);\n\n            if (name.indexOf(\"on\") == 0)\n            {\n                var eventName = $.browser.msie ? name : name.substr(2);\n                if (!this.listeners)\n                    this.listeners = [];\n                this.listeners.push(eventName, val);\n            }\n            else if (name.indexOf(\"_\") == 0)\n            {\n                var propName = name.substr(1);\n                if (!this.props)\n                    this.props = {};\n                this.props[propName] = val;\n            }\n            else if (name.indexOf(\"$\") == 0)\n            {\n                var className = name.substr(1);\n                if (!this.classes)\n                    this.classes = {};\n                this.classes[className] = val;\n            }\n            else\n            {\n                if (name == \"class\" && name in this.attrs)\n                    this.attrs[name] += \" \" + val;\n                else\n                    this.attrs[name] = val;\n            }\n        }\n    },\n\n    compile: function()\n    {\n        if (this.renderMarkup)\n            return;\n\n        this.compileMarkup();\n        this.compileDOM();\n\n        //ddd(this.renderMarkup);\n        //ddd(this.renderDOM);\n        //ddd(this.domArgs);\n    },\n\n    compileMarkup: function()\n    {\n        this.markupArgs = [];\n        var topBlock = [], topOuts = [], blocks = [], info = {args: this.markupArgs, argIndex: 0};\n        //this.addLocals(blocks);\n        this.generateMarkup(topBlock, topOuts, blocks, info);\n        this.addCode(topBlock, topOuts, blocks);\n\n        var fnBlock = ['(function (__code__, __context__, __in__, __out__'];\n        for (var i = 0; i < info.argIndex; ++i)\n            fnBlock.push(', s', i);\n        fnBlock.push(') {\\n');\n\n        if (this.subject)\n            fnBlock.push('with (this) {\\n');\n        if (this.context)\n            fnBlock.push('with (__context__) {\\n');\n        fnBlock.push('with (__in__) {\\n');\n\n        fnBlock.push.apply(fnBlock, blocks);\n\n        if (this.subject)\n            fnBlock.push('}\\n');\n        if (this.context)\n            fnBlock.push('}\\n');\n\n        fnBlock.push('}})\\n');\n\n        function __link__(tag, code, outputs, args)\n        {\n            tag.tag.compile();\n\n            var tagOutputs = [];\n            var markupArgs = [code, tag.tag.context, args, tagOutputs];\n            markupArgs.push.apply(markupArgs, tag.tag.markupArgs);\n            tag.tag.renderMarkup.apply(tag.tag.subject, markupArgs);\n\n            outputs.push(tag);\n            outputs.push(tagOutputs);\n        }\n\n        function __escape__(value)\n        {\n            function replaceChars(ch)\n            {\n                switch (ch)\n                {\n                    case \"<\":\n                        return \"&lt;\";\n                    case \">\":\n                        return \"&gt;\";\n                    case \"&\":\n                        return \"&amp;\";\n                    case \"'\":\n                        return \"&#39;\";\n                    case '\"':\n                        return \"&quot;\";\n                }\n                return \"?\";\n            };\n            return String(value).replace(/[<>&\"']/g, replaceChars);\n        }\n\n        function __loop__(iter, outputs, fn)\n        {\n            var iterOuts = [];\n            outputs.push(iterOuts);\n\n            if (iter instanceof Array)\n                iter = new ArrayIterator(iter);\n\n            try\n            {\n                while (1)\n                {\n                    var value = iter.next();\n                    var itemOuts = [0,0];\n                    iterOuts.push(itemOuts);\n                    fn.apply(this, [value, itemOuts]);\n                }\n            }\n            catch (exc)\n            {\n                if (exc != StopIteration)\n                    throw exc;\n            }\n        }\n\n        var js = $.browser.msie ? 'var f = ' + fnBlock.join(\"\") + ';f' : fnBlock.join(\"\");\n        this.renderMarkup = eval(js);\n    },\n\n    getVarNames: function(args)\n    {\n        if (this.vars)\n            args.push.apply(args, this.vars);\n\n        for (var i = 0; i < this.children.length; ++i)\n        {\n            var child = this.children[i];\n            if (isTag(child))\n                child.tag.getVarNames(args);\n            else if (child instanceof Parts)\n            {\n                for (var i = 0; i < child.parts.length; ++i)\n                {\n                    if (child.parts[i] instanceof Variable)\n                    {\n                        var name = child.parts[i].name;\n                        var names = name.split(\".\");\n                        args.push(names[0]);\n                    }\n                }\n            }\n        }\n    },\n\n    generateMarkup: function(topBlock, topOuts, blocks, info)\n    {\n        topBlock.push(',\"<', this.tagName, '\"');\n\n        for (var name in this.attrs)\n        {\n            if (name != \"class\")\n            {\n                var val = this.attrs[name];\n                topBlock.push(', \" ', name, '=\\\\\"\"');\n                addParts(val, ',', topBlock, info, true);\n                topBlock.push(', \"\\\\\"\"');\n            }\n        }\n\n        if (this.listeners)\n        {\n            for (var i = 0; i < this.listeners.length; i += 2)\n                readPartNames(this.listeners[i+1], topOuts);\n        }\n\n        if (this.props)\n        {\n            for (var name in this.props)\n                readPartNames(this.props[name], topOuts);\n        }\n\n        if (\"class\" in this.attrs || this.classes)\n        {\n            topBlock.push(', \" class=\\\\\"\"');\n            if (\"class\" in this.attrs)\n                addParts(this.attrs[\"class\"], ',', topBlock, info, true);\n              topBlock.push(', \" \"');\n            for (var name in this.classes)\n            {\n                topBlock.push(', (');\n                addParts(this.classes[name], '', topBlock, info);\n                topBlock.push(' ? \"', name, '\" + \" \" : \"\")');\n            }\n            topBlock.push(', \"\\\\\"\"');\n        }\n        topBlock.push(',\">\"');\n\n        this.generateChildMarkup(topBlock, topOuts, blocks, info);\n        topBlock.push(',\"</', this.tagName, '>\"');\n    },\n\n    generateChildMarkup: function(topBlock, topOuts, blocks, info)\n    {\n        for (var i = 0; i < this.children.length; ++i)\n        {\n            var child = this.children[i];\n            if (isTag(child))\n                child.tag.generateMarkup(topBlock, topOuts, blocks, info);\n            else\n                addParts(child, ',', topBlock, info, true);\n        }\n    },\n\n    addCode: function(topBlock, topOuts, blocks)\n    {\n        if (topBlock.length)\n            blocks.push('__code__.push(\"\"', topBlock.join(\"\"), ');\\n');\n        if (topOuts.length)\n            blocks.push('__out__.push(', topOuts.join(\",\"), ');\\n');\n        topBlock.splice(0, topBlock.length);\n        topOuts.splice(0, topOuts.length);\n    },\n\n    addLocals: function(blocks)\n    {\n        var varNames = [];\n        this.getVarNames(varNames);\n\n        var map = {};\n        for (var i = 0; i < varNames.length; ++i)\n        {\n            var name = varNames[i];\n            if ( map.hasOwnProperty(name) )\n                continue;\n\n            map[name] = 1;\n            var names = name.split(\".\");\n            blocks.push('var ', names[0] + ' = ' + '__in__.' + names[0] + ';\\n');\n        }\n    },\n\n    compileDOM: function()\n    {\n        var path = [];\n        var blocks = [];\n        this.domArgs = [];\n        path.embedIndex = 0;\n        path.loopIndex = 0;\n        path.staticIndex = 0;\n        path.renderIndex = 0;\n        var nodeCount = this.generateDOM(path, blocks, this.domArgs);\n\n        var fnBlock = ['(function (root, context, o'];\n\n        for (var i = 0; i < path.staticIndex; ++i)\n            fnBlock.push(', ', 's'+i);\n\n        for (var i = 0; i < path.renderIndex; ++i)\n            fnBlock.push(', ', 'd'+i);\n\n        fnBlock.push(') {\\n');\n        for (var i = 0; i < path.loopIndex; ++i)\n            fnBlock.push('var l', i, ' = 0;\\n');\n        for (var i = 0; i < path.embedIndex; ++i)\n            fnBlock.push('var e', i, ' = 0;\\n');\n\n        if (this.subject)\n            fnBlock.push('with (this) {\\n');\n        if (this.context)\n            fnBlock.push('with (context) {\\n');\n\n        fnBlock.push(blocks.join(\"\"));\n\n        if (this.subject)\n            fnBlock.push('}\\n');\n        if (this.context)\n            fnBlock.push('}\\n');\n\n        fnBlock.push('return ', nodeCount, ';\\n');\n        fnBlock.push('})\\n');\n\n        function __prop__(object, prop, value)\n        {\n            object[prop] = value;\n        }\n\n        function __bind__(object, fn)\n        {\n            return function(event) { return fn.apply(object, [event]); }\n        }\n\n        function __link__(node, tag, args)\n        {\n            tag.tag.compile();\n\n            var domArgs = [node, tag.tag.context, 0];\n            domArgs.push.apply(domArgs, tag.tag.domArgs);\n            domArgs.push.apply(domArgs, args);\n\n            return tag.tag.renderDOM.apply(tag.tag.subject, domArgs);\n        }\n\n        var self = this;\n        function __loop__(iter, fn)\n        {\n            var nodeCount = 0;\n            for (var i = 0; i < iter.length; ++i)\n            {\n                iter[i][0] = i;\n                iter[i][1] = nodeCount;\n                nodeCount += fn.apply(this, iter[i]);\n                //ddd(\"nodeCount\", nodeCount);\n            }\n            return nodeCount;\n        }\n\n        function __path__(parent, offset)\n        {\n            //ddd(\"offset\", arguments[2])\n            var root = parent;\n\n            for (var i = 2; i < arguments.length; ++i)\n            {\n                var index = arguments[i];\n                if (i == 3)\n                    index += offset;\n\n                if (index == -1)\n                    parent = parent.parentNode;\n                else\n                    parent = parent.childNodes[index];\n            }\n\n            //ddd(arguments[2], root, parent);\n            return parent;\n        }\n\n        var js = $.browser.msie ? 'var f = ' + fnBlock.join(\"\") + ';f' : fnBlock.join(\"\");\n        //ddd(js.replace(/(\\;|\\{)/g, \"$1\\n\"));\n        this.renderDOM = eval(js);\n    },\n\n    generateDOM: function(path, blocks, args)\n    {\n        if (this.listeners || this.props)\n            this.generateNodePath(path, blocks);\n\n        if (this.listeners)\n        {\n            for (var i = 0; i < this.listeners.length; i += 2)\n            {\n                var val = this.listeners[i+1];\n                var arg = generateArg(val, path, args);\n                if ($.browser.msie)\n                    blocks.push('node.attachEvent(\"', this.listeners[i], '\", __bind__(this, ', arg, '));\\n');\n                else\n                    blocks.push('node.addEventListener(\"', this.listeners[i], '\", __bind__(this, ', arg, '), false);\\n');\n            }\n        }\n\n        if (this.props)\n        {\n            for (var name in this.props)\n            {\n                var val = this.props[name];\n                var arg = generateArg(val, path, args);\n                blocks.push(\"__prop__(node, '\" + name + \"', \" + arg + \");\\n\");\n                //blocks.push('node.', name, ' = ', arg, ';');\n            }\n        }\n\n        this.generateChildDOM(path, blocks, args);\n        return 1;\n    },\n\n    generateNodePath: function(path, blocks)\n    {\n        blocks.push(\"var node = __path__(root, o\");\n        for (var i = 0; i < path.length; ++i)\n            blocks.push(\",\", path[i]);\n        blocks.push(\");\\n\");\n        //blocks.push(\"try {ddd(l0,l1,l2); } catch (exc) {}\");\n    },\n\n    generateChildDOM: function(path, blocks, args)\n    {\n        path.push(0);\n        for (var i = 0; i < this.children.length; ++i)\n        {\n            var child = this.children[i];\n            if (isTag(child))\n                path[path.length-1] += '+' + child.tag.generateDOM(path, blocks, args);\n            else\n                path[path.length-1] += '+1';\n        }\n        path.pop();\n    }\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nDomplateEmbed.prototype = copyObject(DomplateTag.prototype,\n{\n    merge: function(args, oldTag)\n    {\n        this.value = oldTag ? oldTag.value : parseValue(args[0]);\n        this.attrs = oldTag ? oldTag.attrs : {};\n        this.vars = oldTag ? copyArray(oldTag.vars) : [];\n\n        var attrs = args[1];\n        for (var name in attrs)\n        {\n            var val = parseValue(attrs[name]);\n            this.attrs[name] = val;\n            readPartNames(val, this.vars);\n        }\n\n        return creator(this, DomplateEmbed);\n    },\n\n    getVarNames: function(names)\n    {\n        if (this.value instanceof Parts)\n            names.push(this.value.parts[0].name);\n\n        if (this.vars)\n            names.push.apply(names, this.vars);\n    },\n\n    generateMarkup: function(topBlock, topOuts, blocks, info)\n    {\n        this.addCode(topBlock, topOuts, blocks);\n\n        blocks.push('__link__(');\n        addParts(this.value, '', blocks, info);\n        blocks.push(', __code__, __out__, {\\n');\n\n        var lastName = null;\n        for (var name in this.attrs)\n        {\n            if (lastName)\n                blocks.push(',');\n            lastName = name;\n\n            var val = this.attrs[name];\n            blocks.push('\"', name, '\":');\n            addParts(val, '', blocks, info);\n        }\n\n        blocks.push('});\\n');\n        //this.generateChildMarkup(topBlock, topOuts, blocks, info);\n    },\n\n    generateDOM: function(path, blocks, args)\n    {\n        var embedName = 'e'+path.embedIndex++;\n\n        this.generateNodePath(path, blocks);\n\n        var valueName = 'd' + path.renderIndex++;\n        var argsName = 'd' + path.renderIndex++;\n        blocks.push(embedName + ' = __link__(node, ', valueName, ', ', argsName, ');\\n');\n\n        return embedName;\n    }\n});\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nDomplateLoop.prototype = copyObject(DomplateTag.prototype,\n{\n    merge: function(args, oldTag)\n    {\n        this.isLoop = true;\n        this.varName = oldTag ? oldTag.varName : args[0];\n        this.iter = oldTag ? oldTag.iter : parseValue(args[1]);\n        this.vars = [];\n\n        this.children = oldTag ? copyArray(oldTag.children) : [];\n\n        var offset = Math.min(args.length, 2);\n        parseChildren(args, offset, this.vars, this.children);\n\n        return creator(this, DomplateLoop);\n    },\n\n    getVarNames: function(names)\n    {\n        if (this.iter instanceof Parts)\n            names.push(this.iter.parts[0].name);\n\n        DomplateTag.prototype.getVarNames.apply(this, [names]);\n    },\n\n    generateMarkup: function(topBlock, topOuts, blocks, info)\n    {\n        this.addCode(topBlock, topOuts, blocks);\n\n        var iterName;\n        if (this.iter instanceof Parts)\n        {\n            var part = this.iter.parts[0];\n            iterName = part.name;\n\n            if (part.format)\n            {\n                for (var i = 0; i < part.format.length; ++i)\n                    iterName = part.format[i] + \"(\" + iterName + \")\";\n            }\n        }\n        else\n            iterName = this.iter;\n\n        blocks.push('__loop__.apply(this, [', iterName, ', __out__, function(', this.varName, ', __out__) {\\n');\n        this.generateChildMarkup(topBlock, topOuts, blocks, info);\n        this.addCode(topBlock, topOuts, blocks);\n        blocks.push('}]);\\n');\n    },\n\n    generateDOM: function(path, blocks, args)\n    {\n        var iterName = 'd'+path.renderIndex++;\n        var counterName = 'i'+path.loopIndex;\n        var loopName = 'l'+path.loopIndex++;\n\n        if (!path.length)\n            path.push(-1, 0);\n\n        var preIndex = path.renderIndex;\n        path.renderIndex = 0;\n\n        var nodeCount = 0;\n\n        var subBlocks = [];\n        var basePath = path[path.length-1];\n        for (var i = 0; i < this.children.length; ++i)\n        {\n            path[path.length-1] = basePath+'+'+loopName+'+'+nodeCount;\n\n            var child = this.children[i];\n            if (isTag(child))\n                nodeCount += '+' + child.tag.generateDOM(path, subBlocks, args);\n            else\n                nodeCount += '+1';\n        }\n\n        path[path.length-1] = basePath+'+'+loopName;\n\n        //blocks.push(\"console.group('\", loopName, \"');\");\n        blocks.push(loopName,' = __loop__.apply(this, [', iterName, ', function(', counterName,',',loopName);\n        for (var i = 0; i < path.renderIndex; ++i)\n            blocks.push(',d'+i);\n        blocks.push(') {\\n');\n        blocks.push(subBlocks.join(\"\"));\n        blocks.push('return ', nodeCount, ';\\n');\n        blocks.push('}]);\\n');\n        //blocks.push(\"console.groupEnd();\");\n\n        path.renderIndex = preIndex;\n\n        return loopName;\n    }\n});\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nfunction Variable(name, format)\n{\n    this.name = name;\n    this.format = format;\n}\n\nfunction Parts(parts)\n{\n    this.parts = parts;\n}\n\n// ************************************************************************************************\n\nfunction parseParts(str)\n{\n    var re = /\\$([_A-Za-z][_A-Za-z0-9.|]*)/g;\n    var index = 0;\n    var parts = [];\n\n    var m;\n    while (m = re.exec(str))\n    {\n        var pre = str.substr(index, (re.lastIndex-m[0].length)-index);\n        if (pre)\n            parts.push(pre);\n\n        var expr = m[1].split(\"|\");\n        parts.push(new Variable(expr[0], expr.slice(1)));\n        index = re.lastIndex;\n    }\n\n    if (!index)\n        return str;\n\n    var post = str.substr(index);\n    if (post)\n        parts.push(post);\n\n    return new Parts(parts);\n}\n\nfunction parseValue(val)\n{\n    return typeof(val) == 'string' ? parseParts(val) : val;\n}\n\nfunction parseChildren(args, offset, vars, children)\n{\n    for (var i = offset; i < args.length; ++i)\n    {\n        var val = parseValue(args[i]);\n        children.push(val);\n        readPartNames(val, vars);\n    }\n}\n\nfunction readPartNames(val, vars)\n{\n    if (val instanceof Parts)\n    {\n        for (var i = 0; i < val.parts.length; ++i)\n        {\n            var part = val.parts[i];\n            if (part instanceof Variable)\n                vars.push(part.name);\n        }\n    }\n}\n\nfunction generateArg(val, path, args)\n{\n    if (val instanceof Parts)\n    {\n        var vals = [];\n        for (var i = 0; i < val.parts.length; ++i)\n        {\n            var part = val.parts[i];\n            if (part instanceof Variable)\n            {\n                var varName = 'd'+path.renderIndex++;\n                if (part.format)\n                {\n                    for (var j = 0; j < part.format.length; ++j)\n                        varName = part.format[j] + '(' + varName + ')';\n                }\n\n                vals.push(varName);\n            }\n            else\n                vals.push('\"'+part.replace(/\"/g, '\\\\\"')+'\"');\n        }\n\n        return vals.join('+');\n    }\n    else\n    {\n        args.push(val);\n        return 's' + path.staticIndex++;\n    }\n}\n\nfunction addParts(val, delim, block, info, escapeIt)\n{\n    var vals = [];\n    if (val instanceof Parts)\n    {\n        for (var i = 0; i < val.parts.length; ++i)\n        {\n            var part = val.parts[i];\n            if (part instanceof Variable)\n            {\n                var partName = part.name;\n                if (part.format)\n                {\n                    for (var j = 0; j < part.format.length; ++j)\n                        partName = part.format[j] + \"(\" + partName + \")\";\n                }\n\n                if (escapeIt)\n                    vals.push(\"__escape__(\" + partName + \")\");\n                else\n                    vals.push(partName);\n            }\n            else\n                vals.push('\"'+ part + '\"');\n        }\n    }\n    else if (isTag(val))\n    {\n        info.args.push(val);\n        vals.push('s'+info.argIndex++);\n    }\n    else\n        vals.push('\"'+ val + '\"');\n\n    var parts = vals.join(delim);\n    if (parts)\n        block.push(delim, parts);\n}\n\nfunction isTag(obj)\n{\n    return (typeof(obj) == \"function\" || obj instanceof Function) && !!obj.tag;\n}\n\nfunction isDomplate(obj)\n{\n    return (typeof(obj) == \"object\") && !!obj.render;\n}\n\nfunction creator(tag, cons)\n{\n    var fn = new Function(\n        \"var tag = arguments.callee.tag;\" +\n        \"var cons = arguments.callee.cons;\" +\n        \"var newTag = new cons();\" +\n        \"return newTag.merge(arguments, tag);\");\n\n    fn.tag = tag;\n    fn.cons = cons;\n    extend(fn, Renderer);\n\n    return fn;\n}\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nfunction copyArray(oldArray)\n{\n    var ary = [];\n    if (oldArray)\n        for (var i = 0; i < oldArray.length; ++i)\n            ary.push(oldArray[i]);\n   return ary;\n}\n\nfunction copyObject(l, r)\n{\n    var m = {};\n    extend(m, l);\n    extend(m, r);\n    return m;\n}\n\nfunction extend(l, r)\n{\n    for (var n in r)\n        l[n] = r[n];\n}\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nfunction ArrayIterator(array)\n{\n    var index = -1;\n\n    this.next = function()\n    {\n        if (++index >= array.length)\n            throw StopIteration;\n\n        return array[index];\n    };\n}\n\nfunction StopIteration() {}\n\nthis.$break = function()\n{\n    throw StopIteration;\n};\n\n// ************************************************************************************************\n\nvar Renderer =\n{\n    renderHTML: function(args, outputs, self)\n    {\n        var code = [];\n        var markupArgs = [code, this.tag.context, args, outputs];\n        markupArgs.push.apply(markupArgs, this.tag.markupArgs);\n        this.tag.renderMarkup.apply(self ? self : this.tag.subject, markupArgs);\n        return code.join(\"\");\n    },\n\n    insertRows: function(args, before, self)\n    {\n        this.tag.compile();\n\n        var outputs = [];\n        var html = this.renderHTML(args, outputs, self);\n\n        var doc = before.ownerDocument;\n        var tableParent = doc.createElement(\"div\"); // Workaround: IE doesn't allow to set TABLE.innerHTML\n        tableParent.innerHTML = \"<table>\" + html + \"</table>\";\n\n        var tbody = tableParent.firstChild.firstChild;\n        var parent = before.tagName.toLowerCase() == \"tr\" ? before.parentNode : before;\n        var after = before.tagName.toLowerCase() == \"tr\" ? before.nextSibling : null;\n\n        var firstRow = tbody.firstChild, lastRow;\n        while (tbody.firstChild)\n        {\n            lastRow = tbody.firstChild;\n            if (after)\n                parent.insertBefore(lastRow, after);\n            else\n                parent.appendChild(lastRow);\n        }\n\n        var offset = 0;\n        if (this.tag.isLoop)\n        {\n            var node = firstRow.parentNode.firstChild;\n            for (; node && node != firstRow; node = node.nextSibling)\n                ++offset;\n        }\n\n        var domArgs = [firstRow, this.tag.context, offset];\n        domArgs.push.apply(domArgs, this.tag.domArgs);\n        domArgs.push.apply(domArgs, outputs);\n\n        this.tag.renderDOM.apply(self ? self : this.tag.subject, domArgs);\n        return [firstRow, lastRow];\n    },\n\n    insertAfter: function(args, before, self)\n    {\n        this.tag.compile();\n\n        var outputs = [];\n        var html = this.renderHTML(args, outputs, self);\n\n        var doc = before.ownerDocument;\n        var range = doc.createRange();\n        range.selectNode(doc.body);\n        var frag = range.createContextualFragment(html);\n\n        var root = frag.firstChild;\n        if (before.nextSibling)\n            before.parentNode.insertBefore(frag, before.nextSibling);\n        else\n            before.parentNode.appendChild(frag);\n\n        var domArgs = [root, this.tag.context, 0];\n        domArgs.push.apply(domArgs, this.tag.domArgs);\n        domArgs.push.apply(domArgs, outputs);\n\n        this.tag.renderDOM.apply(self ? self : (this.tag.subject ? this.tag.subject : null),\n            domArgs);\n\n        return root;\n    },\n\n    replace: function(args, parent, self)\n    {\n        this.tag.compile();\n\n        var outputs = [];\n        var html = this.renderHTML(args, outputs, self);\n\n        var root;\n        if (parent.nodeType == 1)\n        {\n            parent.innerHTML = html;\n            root = parent.firstChild;\n        }\n        else\n        {\n            if (!parent || parent.nodeType != 9)\n                parent = document; //xxxHonza: There are no globals.\n\n            if (!womb || womb.ownerDocument != parent)\n                womb = parent.createElement(\"div\");\n            womb.innerHTML = html;\n\n            root = womb.firstChild;\n            //womb.removeChild(root);\n        }\n\n        var domArgs = [root, this.tag.context, 0];\n        domArgs.push.apply(domArgs, this.tag.domArgs);\n        domArgs.push.apply(domArgs, outputs);\n        this.tag.renderDOM.apply(self ? self : this.tag.subject, domArgs);\n\n        return root;\n    },\n\n    append: function(args, parent, self)\n    {\n        this.tag.compile();\n\n        var outputs = [];\n        var html = this.renderHTML(args, outputs, self);\n\n        if (!womb || womb.ownerDocument != parent.ownerDocument)\n            womb = parent.ownerDocument.createElement(\"div\");\n        womb.innerHTML = html;\n\n        var root = womb.firstChild;\n        while (womb.firstChild)\n            parent.appendChild(womb.firstChild);\n\n        var domArgs = [root, this.tag.context, 0];\n        domArgs.push.apply(domArgs, this.tag.domArgs);\n        domArgs.push.apply(domArgs, outputs);\n        this.tag.renderDOM.apply(self ? self : this.tag.subject, domArgs);\n\n        return root;\n    },\n\n    insertCols: function(args, parent, self)\n    {\n        this.tag.compile();\n\n        var outputs = [];\n        var html = this.renderHTML(args, outputs, self);\n\n        // This doesn't work in IE.\n        //var table = parent.ownerDocument.createElement(\"table\");\n        //var womb = parent.ownerDocument.createElement(\"tr\");\n        //table.appendChild(womb);\n        //womb.innerHTML = html;\n\n        var womb = parent.ownerDocument.createElement(\"div\");\n        womb.innerHTML = \"<table><tbody><tr>\" + html + \"</tr></tbody></table>\";\n        womb = womb.firstChild.firstChild.firstChild;\n\n        var firstCol = womb.firstChild;\n        if (!firstCol)\n            return null;\n\n        while (womb.firstChild)\n            parent.appendChild(womb.firstChild);\n\n        // See insertRows for comment.\n        var offset = 0;\n        if (this.tag.isLoop)\n        {\n            var node = firstCol.parentNode.firstChild;\n            for (; node && node != firstCol; node = node.nextSibling)\n                ++offset;\n        }\n\n        var domArgs = [firstCol, this.tag.context, offset];\n        domArgs.push.apply(domArgs, this.tag.domArgs);\n        domArgs.push.apply(domArgs, outputs);\n        this.tag.renderDOM.apply(self ? self : this.tag.subject, domArgs);\n\n        return firstCol;\n    }\n};\n\n// ************************************************************************************************\n\nfunction defineTags()\n{\n    for (var i = 0; i < arguments.length; ++i)\n    {\n        var tagName = arguments[i];\n        var fn = new Function(\"var newTag = new Domplate.DomplateTag('\"+tagName+\"'); return newTag.merge(arguments);\");\n\n        var fnName = tagName.toUpperCase();\n        Domplate[fnName] = fn;\n    }\n}\n\ndefineTags(\n    \"a\", \"button\", \"br\", \"canvas\", \"col\", \"colgroup\", \"div\", \"fieldset\", \"form\", \"h1\", \"h2\", \"h3\", \"hr\",\n     \"img\", \"input\", \"label\", \"legend\", \"li\", \"ol\", \"optgroup\", \"option\", \"p\", \"pre\", \"select\",\n    \"span\", \"strong\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"tr\", \"tt\", \"ul\", \"code\",\n    \"iframe\", \"canvas\"\n);\n\n}).apply(Domplate);\n\nreturn Domplate;\n\n//*************************************************************************************************\n});\n\n"
          },
          "redirectURL": "",
          "headersSize": 359,
          "bodySize": 30505
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "connect": 0,
          "send": 0,
          "wait": 45,
          "receive": 33
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:18.576+01:00",
        "time": 208,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/scripts/core/lib.js",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 293,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:49 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:41 GMT"
            },
            {
              "name": "Etag",
              "value": "\"12eb9dd-7a1a-4d7330a2f0440\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "31258"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=30"
            },
            {
              "name": "Expires",
              "value": "Wed, 06 Mar 2013 07:12:19 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=47"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "application/javascript"
            }
          ],
          "content": {
            "mimeType": "application/javascript",
            "size": 31258,
            "text": "/* See license.txt for terms of usage */\n\nrequire.def(\"core/lib\", [\n    \"core/trace\"\n],\n\nfunction(Trace) {\n\n//***********************************************************************************************//\n\nvar Lib = {};\n\n//***********************************************************************************************//\n// Browser Version\n\nvar userAgent = navigator.userAgent.toLowerCase();\nLib.isFirefox = /firefox/.test(userAgent);\nLib.isOpera   = /opera/.test(userAgent);\nLib.isWebkit  = /webkit/.test(userAgent);\nLib.isSafari  = /webkit/.test(userAgent);\nLib.isIE      = /msie/.test(userAgent) && !/opera/.test(userAgent);\nLib.isIE6     = /msie 6/i.test(navigator.appVersion);\nLib.browserVersion = (userAgent.match( /.+(?:rv|it|ra|ie)[\\/: ]([\\d.]+)/ ) || [0,'0'])[1];\nLib.isIElt8   = Lib.isIE && (Lib.browserVersion-0 < 8); \n\n//***********************************************************************************************//\n// Core concepts (extension, dispatch, bind)\n\nLib.extend = function copyObject(l, r)\n{\n    var m = {};\n    Lib.append(m, l);\n    Lib.append(m, r);\n    return m;\n};\n\nLib.append = function(l, r)\n{\n    for (var n in r)\n        l[n] = r[n];\n    return l;\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\nLib.bind = function()  // fn, thisObject, args => thisObject.fn(args, arguments);\n{\n    var args = Lib.cloneArray(arguments), fn = args.shift(), object = args.shift();\n    return function() { return fn.apply(object, Lib.arrayInsert(Lib.cloneArray(args), 0, arguments)); }\n};\n\nLib.bindFixed = function() // fn, thisObject, args => thisObject.fn(args);\n{\n    var args = Lib.cloneArray(arguments), fn = args.shift(), object = args.shift();\n    return function() { return fn.apply(object, args); }\n};\n\nLib.dispatch = function(listeners, name, args)\n{\n    for (var i=0; listeners && i<listeners.length; i++)\n    {\n        var listener = listeners[i];\n        if (listener[name])\n        {\n            try\n            {\n                listener[name].apply(listener, args);\n            }\n            catch (exc)\n            {\n                Trace.exception(exc);\n            }\n        }\n    }\n};\n\nLib.dispatch2 = function(listeners, name, args)\n{\n    for (var i=0; i<listeners.length; i++)\n    {\n        var listener = listeners[i];\n        if (listener[name])\n        {\n            try\n            {\n                var result = listener[name].apply(listener, args);\n                if (result)\n                    return result;\n            }\n            catch (exc)\n            {\n                Trace.exception(exc);\n            }\n        }\n    }\n};\n\n//***********************************************************************************************//\n// Type Checking\n\nvar toString = Object.prototype.toString;\nvar reFunction = /^\\s*function(\\s+[\\w_$][\\w\\d_$]*)?\\s*\\(/; \n\nLib.isArray = function(object)\n{\n    //return toString.call(object) === \"[object Array]\";\n    return jQuery.isArray(object);\n};\n\nLib.isFunction = function(object)\n{\n    if (!object)\n        return false;\n\n    return toString.call(object) === \"[object Function]\" ||\n        Lib.isIE && typeof object != \"string\" &&\n        reFunction.test(\"\"+object);\n};\n\n//***********************************************************************************************//\n// DOM\n\nLib.isAncestor = function(node, potentialAncestor)\n{\n    for (var parent = node; parent; parent = parent.parentNode)\n    {\n        if (parent == potentialAncestor)\n            return true;\n    }\n\n    return false;\n};\n\n//***********************************************************************************************//\n// Events\n\nLib.fixEvent = function(e)\n{\n    return jQuery.event.fix(e || window.event);\n}\n\nLib.fireEvent = function(element, event)\n{\n    if (document.createEvent)\n    {\n        var evt = document.createEvent(\"Events\");\n        evt.initEvent(event, true, false); // event type,bubbling,cancelable\n        return !element.dispatchEvent(evt);\n    }\n}\n\nLib.cancelEvent = function(event)\n{\n    var e = Lib.fixEvent(event);\n    e.stopPropagation();\n    e.preventDefault();\n};\n\nLib.addEventListener = function(object, name, handler, direction)\n{\n    direction = direction || false;\n\n    if (object.addEventListener)\n        object.addEventListener(name, handler, direction);\n    else\n        object.attachEvent(\"on\"+name, handler);\n};\n\nLib.removeEventListener = function(object, name, handler, direction)\n{\n    direction = direction || false;\n\n    if (object.removeEventListener)\n        object.removeEventListener(name, handler, direction);\n    else\n        object.detachEvent(\"on\"+name, handler);\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n// Key Events\n\nLib.isLeftClick = function(event)\n{\n    return event.button == 0 && Lib.noKeyModifiers(event);\n};\n\nLib.noKeyModifiers = function(event)\n{\n    return !event.ctrlKey && !event.shiftKey && !event.altKey && !event.metaKey;\n};\n\nLib.isControlClick = function(event)\n{\n    return event.button == 0 && Lib.isControl(event);\n};\n\nLib.isShiftClick = function(event)\n{\n    return event.button == 0 && Lib.isShift(event);\n};\n\nLib.isControl = function(event)\n{\n    return (event.metaKey || event.ctrlKey) && !event.shiftKey && !event.altKey;\n};\n\nLib.isAlt = function(event)\n{\n    return event.altKey && !event.ctrlKey && !event.shiftKey && !event.metaKey;\n};\n\nLib.isAltClick = function(event)\n{\n    return event.button == 0 && Lib.isAlt(event);\n};\n\nLib.isControlShift = function(event)\n{\n    return (event.metaKey || event.ctrlKey) && event.shiftKey && !event.altKey;\n};\n\nLib.isShift = function(event)\n{\n    return event.shiftKey && !event.metaKey && !event.ctrlKey && !event.altKey;\n};\n\n//***********************************************************************************************//\n// Rect {top, left, height, width}\n\nLib.inflateRect = function(rect, x, y)\n{\n    return {\n        top: rect.top - y,\n        left: rect.left - x,\n        height: rect.height + 2*y,\n        width: rect.width + 2*x\n    }\n};\n\nLib.pointInRect = function(rect, x, y)\n{\n    return (y >= rect.top && y <= rect.top + rect.height &&\n        x >= rect.left && x <= rect.left + rect.width);\n}\n\n//*************************************************************************************************\n// Arrays\n\nLib.cloneArray = function(array, fn)\n{\n   var newArray = [];\n\n   if (fn)\n       for (var i = 0; i < array.length; ++i)\n           newArray.push(fn(array[i]));\n   else\n       for (var i = 0; i < array.length; ++i)\n           newArray.push(array[i]);\n\n   return newArray;\n};\n\nLib.arrayInsert = function(array, index, other)\n{\n   for (var i = 0; i < other.length; ++i)\n       array.splice(i+index, 0, other[i]);\n   return array;\n};\n\nLib.remove = function(list, item)\n{\n    for (var i = 0; i < list.length; ++i)\n    {\n        if (list[i] == item)\n        {\n            list.splice(i, 1);\n            return true;\n        }\n    }\n    return false;\n};\n\n//*************************************************************************************************\n// Text Formatting\n\nLib.formatSize = function(bytes)\n{\n    var sizePrecision = 1; // Can be customizable from cookies?\n    sizePrecision = (sizePrecision > 2) ? 2 : sizePrecision;\n    sizePrecision = (sizePrecision < -1) ? -1 : sizePrecision;\n\n    if (sizePrecision == -1)\n        return bytes + \" B\";\n\n    var a = Math.pow(10, sizePrecision);\n\n    if (bytes == -1 || bytes == undefined)\n        return \"?\";\n    else if (bytes == 0)\n        return \"0\";\n    else if (bytes < 1024)\n        return bytes + \" B\";\n    else if (bytes < (1024*1024))\n        return Math.round((bytes/1024)*a)/a + \" KB\";\n    else\n        return Math.round((bytes/(1024*1024))*a)/a + \" MB\";\n};\n\nLib.formatTime = function(elapsed)\n{\n    if (elapsed == -1)\n        return \"-\"; // should be &nbsp; but this will be escaped so we need something that is no whitespace\n    else if (elapsed < 1000)\n        return elapsed + \"ms\";\n    else if (elapsed < 60000)\n        return (Math.ceil(elapsed/10) / 100) + \"s\";\n    else\n        return (Math.ceil((elapsed/60000)*100)/100) + \"m\";\n};\n\nLib.formatNumber = function(number)\n{\n    number += \"\";\n    var x = number.split(\".\");\n    var x1 = x[0];\n    var x2 = x.length > 1 ? \".\" + x[1] : \"\";\n    var rgx = /(\\d+)(\\d{3})/;\n    while (rgx.test(x1))\n        x1 = x1.replace(rgx, \"$1\" + \" \" + \"$2\");\n    return x1 + x2;\n};\n\nLib.formatString = function(string)\n{\n    var args = Lib.cloneArray(arguments), string = args.shift();\n    for (var i=0; i<args.length; i++)\n    {\n        var value = args[i].toString();\n        string = string.replace(\"%S\", value);\n    }\n    return string;\n};\n\n//*************************************************************************************************\n// Date\n\nLib.parseISO8601 = function(text)\n{\n    var date = Lib.fromISOString(text);\n    return date ? date.getTime() : null;\n};\n\nLib.fromISOString = function(text)\n{\n    if (!text)\n        return null;\n\n    // Date time pattern: YYYY-MM-DDThh:mm:ss.sTZD\n    // eg 1997-07-16T19:20:30.451+01:00\n    // http://www.w3.org/TR/NOTE-datetime\n    // xxxHonza: use the one from the schema.\n    var regex = /(\\d\\d\\d\\d)(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))/;\n    var reg = new RegExp(regex);\n    var m = text.toString().match(new RegExp(regex));\n    if (!m)\n        return null;\n\n    var date = new Date();\n    date.setUTCDate(1);\n    date.setUTCFullYear(parseInt(m[1], 10));\n    date.setUTCMonth(parseInt(m[3], 10) - 1);\n    date.setUTCDate(parseInt(m[5], 10));\n    date.setUTCHours(parseInt(m[7], 10));\n    date.setUTCMinutes(parseInt(m[9], 10));\n    date.setUTCSeconds(parseInt(m[11], 10));\n\n    if (m[12])\n        date.setUTCMilliseconds(parseFloat(m[12]) * 1000);\n    else\n        date.setUTCMilliseconds(0);\n\n    if (m[13] != 'Z')\n    {\n        var offset = (m[15] * 60) + parseInt(m[17], 10);\n        offset *= ((m[14] == '-') ? -1 : 1);\n        date.setTime(date.getTime() - offset * 60 * 1000);\n    }\n\n    return date;\n},\n\nLib.toISOString = function(date)\n{\n    function f(n, c) {\n        if (!c) c = 2;\n        var s = new String(n);\n        while (s.length < c) s = \"0\" + s;\n        return s;\n    }\n\n    var result = date.getUTCFullYear() + '-' +\n        f(date.getMonth() + 1) + '-' +\n        f(date.getDate()) + 'T' +\n        f(date.getHours()) + ':' +\n        f(date.getMinutes()) + ':' +\n        f(date.getSeconds()) + '.' +\n        f(date.getMilliseconds(), 3);\n\n    var offset = date.getTimezoneOffset();\n    var offsetHours = Math.floor(offset / 60);\n    var offsetMinutes = Math.floor(offset % 60);\n    var prettyOffset = (offset > 0 ? \"-\" : \"+\") +\n        f(Math.abs(offsetHours)) + \":\" + f(Math.abs(offsetMinutes));\n\n    return result + prettyOffset;\n},\n\n//*************************************************************************************************\n// URL\n\nLib.getFileName = function(url)\n{\n    try\n    {\n        var split = Lib.splitURLBase(url);\n        return split.name;\n    }\n    catch (e)\n    {\n        Trace.log(unescape(url));\n    }\n\n    return url;\n};\n\nLib.getFileExtension = function(url)\n{\n    if (!url)\n        return null;\n\n    // Remove query string from the URL if any.\n    var queryString = url.indexOf(\"?\");\n    if (queryString != -1)\n        url = url.substr(0, queryString);\n\n    // Now get the file extension.\n    var lastDot = url.lastIndexOf(\".\");\n    return url.substr(lastDot+1);\n};\n\nLib.splitURLBase = function(url)\n{\n    if (Lib.isDataURL(url))\n        return Lib.splitDataURL(url);\n    return Lib.splitURLTrue(url);\n};\n\nLib.isDataURL = function(url)\n{\n    return (url && url.substr(0,5) == \"data:\");\n};\n\nLib.splitDataURL = function(url)\n{\n    var mark = url.indexOf(':', 3);\n    if (mark != 4)\n        return false;   //  the first 5 chars must be 'data:'\n\n    var point = url.indexOf(',', mark+1);\n    if (point < mark)\n        return false; // syntax error\n\n    var props = { encodedContent: url.substr(point+1) };\n\n    var metadataBuffer = url.substr(mark+1, point);\n    var metadata = metadataBuffer.split(';');\n    for (var i = 0; i < metadata.length; i++)\n    {\n        var nv = metadata[i].split('=');\n        if (nv.length == 2)\n            props[nv[0]] = nv[1];\n    }\n\n    // Additional Firebug-specific properties\n    if (props.hasOwnProperty('fileName'))\n    {\n         var caller_URL = decodeURIComponent(props['fileName']);\n         var caller_split = Lib.splitURLTrue(caller_URL);\n\n        if (props.hasOwnProperty('baseLineNumber'))  // this means it's probably an eval()\n        {\n            props['path'] = caller_split.path;\n            props['line'] = props['baseLineNumber'];\n            var hint = decodeURIComponent(props['encodedContent'].substr(0,200)).replace(/\\s*$/, \"\");\n            props['name'] =  'eval->'+hint;\n        }\n        else\n        {\n            props['name'] = caller_split.name;\n            props['path'] = caller_split.path;\n        }\n    }\n    else\n    {\n        if (!props.hasOwnProperty('path'))\n            props['path'] = \"data:\";\n        if (!props.hasOwnProperty('name'))\n            props['name'] =  decodeURIComponent(props['encodedContent'].substr(0,200)).replace(/\\s*$/, \"\");\n    }\n\n    return props;\n};\n\nLib.splitURLTrue = function(url)\n{\n    var reSplitFile = /:\\/{1,3}(.*?)\\/([^\\/]*?)\\/?($|\\?.*)/;\n    var m = reSplitFile.exec(url);\n    if (!m)\n        return {name: url, path: url};\n    else if (!m[2])\n        return {path: m[1], name: m[1]};\n    else\n        return {path: m[1], name: m[2]+m[3]};\n};\n\n/**\n * Returns value of specified parameter in the current URL.\n * @param {String} name Name of the requested parameter.\n * @return {String} Value of the requested parameter.\n */\nLib.getURLParameter = function(name)\n{\n    var query = window.location.search.substring(1);\n    var vars = query.split(\"&\");\n    for (var i=0;i<vars.length;i++)\n    {\n        var pair = vars[i].split(\"=\");\n        if (pair[0] == name)\n            return unescape(pair[1]);\n    }\n    return null;\n};\n\n/**\n * Supports multiple URL parameters with the same name. Returns array\n * of values.\n * @param {String} name Name of the requested parameter.\n * @return {Array} Array with values.\n */\nLib.getURLParameters = function(name)\n{\n    var result = [];\n    var query = window.location.search.substring(1);\n    var vars = query.split(\"&\");\n    for (var i=0;i<vars.length;i++)\n    {\n        var pair = vars[i].split(\"=\");\n        if (pair[0] == name)\n            result.push(unescape(pair[1]));\n    }\n    return result;\n};\n\nLib.parseURLParams = function(url)\n{\n    var q = url ? url.indexOf(\"?\") : -1;\n    if (q == -1)\n        return [];\n\n    var search = url.substr(q+1);\n    var h = search.lastIndexOf(\"#\");\n    if (h != -1)\n        search = search.substr(0, h);\n\n    if (!search)\n        return [];\n\n    return Lib.parseURLEncodedText(search);\n};\n\nLib.parseURLEncodedText = function(text, noLimit)\n{\n    var maxValueLength = 25000;\n\n    var params = [];\n\n    // In case the text is empty just return the empty parameters\n    if(text == '')\n      return params;\n\n    // Unescape '+' characters that are used to encode a space.\n    // See section 2.2.in RFC 3986: http://www.ietf.org/rfc/rfc3986.txt\n    text = text.replace(/\\+/g, \" \");\n\n    // Unescape '&amp;' character\n    //xxxHonza: text = Lib.unescapeForURL(text);\n\n    function decodeText(text)\n    {\n        try\n        {\n            return decodeURIComponent(text);\n        }\n        catch (e)\n        {\n            return decodeURIComponent(unescape(text));\n        }\n    }\n\n    var args = text.split(\"&\");\n    for (var i = 0; i < args.length; ++i)\n    {\n        try\n        {\n            var index = args[i].indexOf(\"=\");\n            if (index != -1)\n            {\n                var paramName = args[i].substring(0, index);\n                var paramValue = args[i].substring(index + 1);\n\n                if (paramValue.length > maxValueLength && !noLimit)\n                    paramValue = Lib.$STR(\"LargeData\");\n\n                params.push({name: decodeText(paramName), value: decodeText(paramValue)});\n            }\n            else\n            {\n                var paramName = args[i];\n                params.push({name: decodeText(paramName), value: \"\"});\n            }\n        }\n        catch (e)\n        {\n        }\n    }\n\n    params.sort(function(a, b) { return a.name <= b.name ? -1 : 1; });\n\n    return params;\n};\n\n//*************************************************************************************************\n// DOM\n\nLib.getBody = function(doc)\n{\n    if (doc.body)\n        return doc.body;\n\n    var body = doc.getElementsByTagName(\"body\")[0];\n    if (body)\n        return body;\n\n    // Should never happen.\n    return null;\n};\n\nLib.getHead = function(doc)\n{\n    return doc.getElementsByTagName(\"head\")[0];\n};\n\nLib.getAncestorByClass = function(node, className)\n{\n    for (var parent = node; parent; parent = parent.parentNode)\n    {\n        if (Lib.hasClass(parent, className))\n            return parent;\n    }\n\n    return null;\n};\n\nLib.$ = function()\n{\n    return Lib.getElementByClass.apply(this, arguments);\n};\n\nLib.getElementByClass = function(node, className)  // className, className, ...\n{\n    if (!node)\n        return null;\n\n    var args = Lib.cloneArray(arguments); args.splice(0, 1);\n    for (var child = node.firstChild; child; child = child.nextSibling)\n    {\n        var args1 = Lib.cloneArray(args); args1.unshift(child);\n        if (Lib.hasClass.apply(this, args1))\n            return child;\n        else\n        {\n            var found = Lib.getElementByClass.apply(this, args1);\n            if (found)\n                return found;\n        }\n    }\n\n    return null;\n};\n\nLib.getElementsByClass = function(node, className)  // className, className, ...\n{\n    if (node.querySelectorAll)\n    {\n        var args = Lib.cloneArray(arguments); args.shift();\n        var selector = \".\" + args.join(\".\");\n        return node.querySelectorAll(selector);\n    }\n\n    function iteratorHelper(node, classNames, result)\n    {\n        for (var child = node.firstChild; child; child = child.nextSibling)\n        {\n            var args1 = Lib.cloneArray(classNames); args1.unshift(child);\n            if (Lib.hasClass.apply(null, args1))\n                result.push(child);\n\n            iteratorHelper(child, classNames, result);\n        }\n    }\n\n    var result = [];\n    var args = Lib.cloneArray(arguments); args.shift();\n    iteratorHelper(node, args, result);\n    return result;\n}\n\nLib.getChildByClass = function(node) // ,classname, classname, classname...\n{\n    for (var i = 1; i < arguments.length; ++i)\n    {\n        var className = arguments[i];\n        var child = node.firstChild;\n        node = null;\n        for (; child; child = child.nextSibling)\n        {\n            if (Lib.hasClass(child, className))\n            {\n                node = child;\n                break;\n            }\n        }\n    }\n\n    return node;\n};\n\nLib.eraseNode = function(node)\n{\n    while (node.lastChild)\n        node.removeChild(node.lastChild);\n};\n\nLib.clearNode = function(node)\n{\n    node.innerHTML = \"\";\n};\n\n//***********************************************************************************************//\n// CSS\n\nLib.hasClass = function(node, name) // className, className, ...\n{\n    if (!node || node.nodeType != 1)\n        return false;\n    else\n    {\n        for (var i=1; i<arguments.length; ++i)\n        {\n            var name = arguments[i];\n            //var re = new RegExp(\"(^|\\\\s)\"+name+\"($|\\\\s)\");\n            //if (!re.exec(node.getAttribute(\"class\")))\n            //    return false;\n            var className = node.className;//node.getAttribute(\"class\");\n            if (!className || className.indexOf(name + \" \") == -1)\n                return false;\n        }\n\n        return true;\n    }\n};\n\nLib.setClass = function(node, name)\n{\n    if (node && !Lib.hasClass(node, name))\n        node.className += \" \" + name + \" \";\n};\n\nLib.removeClass = function(node, name)\n{\n    if (node && node.className)\n    {\n        var index = node.className.indexOf(name);\n        if (index >= 0)\n        {\n            var size = name.length;\n            node.className = node.className.substr(0,index-1) + node.className.substr(index+size);\n        }\n    }\n};\n\nLib.toggleClass = function(elt, name)\n{\n    if (Lib.hasClass(elt, name))\n    {\n        Lib.removeClass(elt, name);\n        return false;\n    }\n    else\n    {\n        Lib.setClass(elt, name);\n        return true;\n    }\n};\n\nLib.setClassTimed = function(elt, name, timeout)\n{\n    if (!timeout)\n        timeout = 1300;\n\n    if (elt.__setClassTimeout)  // then we are already waiting to remove the class mark\n        clearTimeout(elt.__setClassTimeout);  // reset the timer\n    else                        // then we are not waiting to remove the mark\n        Lib.setClass(elt, name);\n\n    elt.__setClassTimeout = setTimeout(function()\n    {\n        delete elt.__setClassTimeout;\n        Lib.removeClass(elt, name);\n    }, timeout);\n};\n\n//*************************************************************************************************\n// Text\n\nLib.trim = function(text)\n{\n    return text.replace(/^\\s*|\\s*$/g, \"\");\n};\n\nLib.wrapText = function(text, noEscapeHTML)\n{\n    var reNonAlphaNumeric = /[^A-Za-z_$0-9'\"-]/;\n\n    var html = [];\n    var wrapWidth = 100;\n\n    // Split long text into lines and put every line into an <pre> element (only in case\n    // if noEscapeHTML is false). This is useful for automatic scrolling when searching\n    // within response body (in order to scroll we need an element).\n    var lines = Lib.splitLines(text);\n    for (var i = 0; i < lines.length; ++i)\n    {\n        var line = lines[i];\n        while (line.length > wrapWidth)\n        {\n            var m = reNonAlphaNumeric.exec(line.substr(wrapWidth, 100));\n            var wrapIndex = wrapWidth+ (m ? m.index : 0);\n            var subLine = line.substr(0, wrapIndex);\n            line = line.substr(wrapIndex);\n\n            if (!noEscapeHTML) html.push(\"<pre>\");\n            html.push(noEscapeHTML ? subLine : Lib.escapeHTML(subLine));\n            if (!noEscapeHTML) html.push(\"</pre>\");\n        }\n\n        if (!noEscapeHTML) html.push(\"<pre>\");\n        html.push(noEscapeHTML ? line : Lib.escapeHTML(line));\n        if (!noEscapeHTML) html.push(\"</pre>\");\n    }\n\n    return html.join(noEscapeHTML ? \"\\n\" : \"\");\n};\n\nLib.insertWrappedText = function(text, textBox, noEscapeHTML)\n{\n    textBox.innerHTML = \"<pre>\" + Lib.wrapText(text, noEscapeHTML) + \"</pre>\";\n};\n\nLib.splitLines = function(text)\n{\n    var reSplitLines = /\\r\\n|\\r|\\n/;\n\n    if (!text)\n        return [];\n    else if (text.split)\n        return text.split(reSplitLines);\n\n    var str = text + \"\";\n    var theSplit = str.split(reSplitLines);\n    return theSplit;\n};\n\nLib.getPrettyDomain = function(url)\n{\n    var m = /[^:]+:\\/{1,3}(www\\.)?([^\\/]+)/.exec(url);\n    return m ? m[2] : \"\";\n},\n\nLib.escapeHTML = function(value)\n{\n    function replaceChars(ch)\n    {\n        switch (ch)\n        {\n            case \"<\":\n                return \"&lt;\";\n            case \">\":\n                return \"&gt;\";\n            case \"&\":\n                return \"&amp;\";\n            case \"'\":\n                return \"&#39;\";\n            case '\"':\n                return \"&quot;\";\n        }\n        return \"?\";\n    };\n    return String(value).replace(/[<>&\"']/g, replaceChars);\n};\n\nLib.cropString = function(text, limit)\n{\n    text = text + \"\";\n\n    if (!limit)\n        var halfLimit = 50;\n    else\n        var halfLimit = limit / 2;\n\n    if (text.length > limit)\n        return Lib.escapeNewLines(text.substr(0, halfLimit) + \"...\" + text.substr(text.length-halfLimit));\n    else\n        return Lib.escapeNewLines(text);\n};\n\nLib.escapeNewLines = function(value)\n{\n    return value.replace(/\\r/g, \"\\\\r\").replace(/\\n/g, \"\\\\n\");\n};\n\n//***********************************************************************************************//\n// JSON\n\nLib.cloneJSON = function(obj)\n{\n    if (obj == null || typeof(obj) != \"object\")\n        return obj;\n\n    try\n    {\n        var temp = obj.constructor();\n        for (var key in obj)\n            temp[key] = this.cloneJSON(obj[key]);\n        return temp;\n    }\n    catch (err)\n    {\n        Trace.exception(err);\n    }\n\n    return null;\n};\n\n//***********************************************************************************************//\n// Layout\n\nLib.getOverflowParent = function(element)\n{\n    for (var scrollParent = element.parentNode; scrollParent;\n        scrollParent = scrollParent.offsetParent)\n    {\n        if (scrollParent.scrollHeight > scrollParent.offsetHeight)\n            return scrollParent;\n    }\n};\n\nLib.getElementBox = function(el)\n{\n    var result = {};\n\n    if (el.getBoundingClientRect)\n    {\n        var rect = el.getBoundingClientRect();\n\n        // fix IE problem with offset when not in fullscreen mode\n        var offset = Lib.isIE ? document.body.clientTop || document.documentElement.clientTop: 0;\n        var scroll = Lib.getWindowScrollPosition();\n\n        result.top = Math.round(rect.top - offset + scroll.top);\n        result.left = Math.round(rect.left - offset + scroll.left);\n        result.height = Math.round(rect.bottom - rect.top);\n        result.width = Math.round(rect.right - rect.left);\n    }\n    else\n    {\n        var position = Lib.getElementPosition(el);\n\n        result.top = position.top;\n        result.left = position.left;\n        result.height = el.offsetHeight;\n        result.width = el.offsetWidth;\n    }\n\n    return result;\n};\n\nLib.getElementPosition = function(el)\n{\n    var left = 0\n    var top = 0;\n\n    do\n    {\n        left += el.offsetLeft;\n        top += el.offsetTop;\n    }\n    while (el = el.offsetParent);\n\n    return {left:left, top:top};\n};\n\nLib.getWindowSize = function()\n{\n    var width=0, height=0, el;\n    \n    if (typeof window.innerWidth == \"number\")\n    {\n        width = window.innerWidth;\n        height = window.innerHeight;\n    }\n    else if ((el=document.documentElement) && (el.clientHeight || el.clientWidth))\n    {\n        width = el.clientWidth;\n        height = el.clientHeight;\n    }\n    else if ((el=document.body) && (el.clientHeight || el.clientWidth))\n    {\n        width = el.clientWidth;\n        height = el.clientHeight;\n    }\n    \n    return {width: width, height: height};\n};\n\nLib.getWindowScrollSize = function()\n{\n    var width=0, height=0, el;\n\n    // first try the document.documentElement scroll size\n    if (!Lib.isIEQuiksMode && (el=document.documentElement) && \n       (el.scrollHeight || el.scrollWidth))\n    {\n        width = el.scrollWidth;\n        height = el.scrollHeight;\n    }\n\n    // then we need to check if document.body has a bigger scroll size value\n    // because sometimes depending on the browser and the page, the document.body\n    // scroll size returns a smaller (and wrong) measure\n    if ((el=document.body) && (el.scrollHeight || el.scrollWidth) &&\n        (el.scrollWidth > width || el.scrollHeight > height))\n    {\n        width = el.scrollWidth;\n        height = el.scrollHeight;\n    }\n\n    return {width: width, height: height};\n};\n\nLib.getWindowScrollPosition = function()\n{\n    var top=0, left=0, el;\n\n    if(typeof window.pageYOffset == \"number\")\n    {\n        top = window.pageYOffset;\n        left = window.pageXOffset;\n    }\n    else if((el=document.body) && (el.scrollTop || el.scrollLeft))\n    {\n        top = el.scrollTop;\n        left = el.scrollLeft;\n    }\n    else if((el=document.documentElement) && (el.scrollTop || el.scrollLeft))\n    {\n        top = el.scrollTop;\n        left = el.scrollLeft;\n    }\n\n    return {top:top, left:left};\n};\n\n// ********************************************************************************************* //\n// Scrolling\n\nLib.scrollIntoCenterView = function(element, scrollBox, notX, notY)\n{\n    if (!element)\n        return;\n\n    if (!scrollBox)\n        scrollBox = Lib.getOverflowParent(element);\n\n    if (!scrollBox)\n        return;\n\n    var offset = Lib.getClientOffset(element);\n\n    if (!notY)\n    {\n        var topSpace = offset.y - scrollBox.scrollTop;\n        var bottomSpace = (scrollBox.scrollTop + scrollBox.clientHeight)\n            - (offset.y + element.offsetHeight);\n\n        if (topSpace < 0 || bottomSpace < 0)\n        {\n            var centerY = offset.y - (scrollBox.clientHeight/2);\n            scrollBox.scrollTop = centerY;\n        }\n    }\n\n    if (!notX)\n    {\n        var leftSpace = offset.x - scrollBox.scrollLeft;\n        var rightSpace = (scrollBox.scrollLeft + scrollBox.clientWidth)\n            - (offset.x + element.clientWidth);\n\n        if (leftSpace < 0 || rightSpace < 0)\n        {\n            var centerX = offset.x - (scrollBox.clientWidth/2);\n            scrollBox.scrollLeft = centerX;\n        }\n    }\n};\n\nLib.getClientOffset = function(elt)\n{\n    function addOffset(elt, coords, view)\n    {\n        var p = elt.offsetParent;\n\n        var style = view.getComputedStyle(elt, \"\");\n\n        if (elt.offsetLeft)\n            coords.x += elt.offsetLeft + parseInt(style.borderLeftWidth);\n        if (elt.offsetTop)\n            coords.y += elt.offsetTop + parseInt(style.borderTopWidth);\n\n        if (p)\n        {\n            if (p.nodeType == 1)\n                addOffset(p, coords, view);\n        }\n        else if (elt.ownerDocument.defaultView.frameElement)\n        {\n            addOffset(elt.ownerDocument.defaultView.frameElement,\n                coords, elt.ownerDocument.defaultView);\n        }\n    }\n\n    var coords = {x: 0, y: 0};\n    if (elt)\n    {\n        var view = elt.ownerDocument.defaultView;\n        addOffset(elt, coords, view);\n    }\n\n    return coords;\n};\n\n// ********************************************************************************************* //\n// Stylesheets\n\n/**\n * Load stylesheet into the specified document. The method doesn't wait till the stylesheet\n * is loaded and so, not suitable for cases when you do not care when the file is loaded.\n * @param {Object} doc The document to load the stylesheet into.\n * @param {Object} url URL of the target stylesheet.\n */\nLib.addStyleSheet = function(doc, url)\n{\n    if (doc.getElementById(url))\n        return;\n\n    var link = doc.createElement(\"link\");\n    link.type = \"text/css\";\n    link.rel = \"stylesheet\";\n    link.href = url;\n    link.setAttribute(\"id\", url);\n\n    var head = Lib.getHead(doc);\n    head.appendChild(link);\n}\n\n// ********************************************************************************************* //\n// Selection\n\nLib.selectElementText = function(textNode, startOffset, endOffset)\n{\n    var win = window;\n    var doc = win.document;\n    if (win.getSelection && doc.createRange)\n    {\n        var sel = win.getSelection();\n        var range = doc.createRange();\n        //range.selectNodeContents(el);\n\n        range.setStart(textNode, startOffset);\n        range.setEnd(textNode, endOffset);\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n    else if (doc.body.createTextRange)\n    {\n        range = doc.body.createTextRange();\n        range.moveToElementText(textNode);\n        range.select();\n    }\n}\n\n// ********************************************************************************************* //\n\nreturn Lib;\n\n// ********************************************************************************************* //\n});\n"
          },
          "redirectURL": "",
          "headersSize": 359,
          "bodySize": 31258
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "connect": 0,
          "send": 0,
          "wait": 65,
          "receive": 143
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:18.576+01:00",
        "time": 78,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/scripts/core/trace.js",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 295,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:49 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:41 GMT"
            },
            {
              "name": "Etag",
              "value": "\"12eba0e-497-4d7330a2f0440\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "1175"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=30"
            },
            {
              "name": "Expires",
              "value": "Wed, 06 Mar 2013 07:12:19 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=48"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "application/javascript"
            }
          ],
          "content": {
            "mimeType": "application/javascript",
            "size": 1175,
            "text": "/* See license.txt for terms of usage */\n\nrequire.def(\"core/trace\", [\n],\n\nfunction() {\n\n//*************************************************************************************************\n\nvar Trace = {\n    log: function(){},\n    error: function(){},\n    exception: function(){},\n    time: function(){},\n    timeEnd: function(){}\n};\n\nif (typeof(console) == \"undefined\")\n    return Trace;\n\n// #ifdef _DEBUG\nTrace.log = function()\n{\n    if (typeof(console.log) == \"function\")\n        console.log.apply(console, arguments);\n};\n\nTrace.error = function()\n{\n    if (typeof(console.error) == \"function\")\n        console.error.apply(console, arguments);\n};\n\nTrace.exception = function()\n{\n    if (typeof(console.error) == \"function\")\n        console.error.apply(console, arguments);\n};\n\nTrace.time = function()\n{\n    if (typeof(console.time) == \"function\")\n        console.time.apply(console, arguments);\n};\n\nTrace.timeEnd = function(name, message)\n{\n    if (typeof(console.timeEnd) == \"function\")\n        console.timeEnd.apply(console, arguments);\n};\n// #endif\n\nreturn Trace;\n\n//*************************************************************************************************\n});\n\n"
          },
          "redirectURL": "",
          "headersSize": 357,
          "bodySize": 1175
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "connect": 0,
          "send": 0,
          "wait": 65,
          "receive": 13
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:18.576+01:00",
        "time": 147,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/scripts/domplate/reps.js",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 298,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:49 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:44 GMT"
            },
            {
              "name": "Etag",
              "value": "\"12eba69-2696-4d7330a5ccb00\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "9878"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=30"
            },
            {
              "name": "Expires",
              "value": "Wed, 06 Mar 2013 07:12:19 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=49"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "application/javascript"
            }
          ],
          "content": {
            "mimeType": "application/javascript",
            "size": 9878,
            "text": "/* See license.txt for terms of usage */\n\ndefine([\n    \"domplate/domplate\",\n    \"core/lib\",\n    \"core/trace\"\n],\n\nfunction(Domplate, Lib, Trace) { with (Domplate) {\n\n// ********************************************************************************************* //\n// Templates\n\nvar OBJECTBOX =\n    PRE({\"class\": \"objectBox inline objectBox-$className\", role: \"presentation\"});\n\nvar OBJECTLINK =\n    A({\n        \"class\": \"objectLink objectLink-$className a11yFocus\",\n        _repObject: \"$object\"\n    });\n\n// ********************************************************************************************* //\n\nvar Reps =\n{\n    OBJECTLINK: OBJECTLINK,\n    OBJECTBOX: OBJECTBOX,\n\n    reps: [],\n\n    registerRep: function()\n    {\n        this.reps.push.apply(this.reps, arguments);\n    },\n\n    getRep: function(object)\n    {\n        var type = typeof(object);\n        if (type == \"object\" && object instanceof String)\n            type = \"string\";\n\n        for (var i=0; i<this.reps.length; ++i)\n        {\n            var rep = this.reps[i];\n            try\n            {\n                if (rep.supportsObject(object, type))\n                    return rep;\n            }\n            catch (exc)\n            {\n                Trace.exception(\"reps.getRep; \", exc);\n            }\n        }\n\n        return Reps.Rep;\n    }\n}\n\n// ********************************************************************************************* //\n\nReps.Rep = domplate(\n{\n    tag:\n        OBJECTBOX(\"$object|getTitle\"),\n\n    className: \"object\",\n\n    getTitle: function(object)\n    {\n        var label = safeToString(object);\n        var re = /\\[object (.*?)\\]/;\n        var m = re.exec(label);\n        var result = m ? m[1] : label;\n\n        return Lib.cropString(result, 100);\n    },\n\n    getTooltip: function(object)\n    {\n        return null;\n    },\n\n    supportsObject: function(object, type)\n    {\n        return false;\n    }\n});\n\n// ********************************************************************************************* //\n\nReps.Undefined = domplate(Reps.Rep,\n{\n    tag:\n        OBJECTBOX(\"undefined\"),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n    className: \"undefined\",\n\n    supportsObject: function(object, type)\n    {\n        return type == \"undefined\";\n    }\n});\n\n// ********************************************************************************************* //\n\nReps.Null = domplate(Reps.Rep,\n{\n    tag:\n        OBJECTBOX(\"null\"),\n\n    className: \"null\",\n\n    supportsObject: function(object, type)\n    {\n        return object == null;\n    }\n});\n\n// ********************************************************************************************* //\n\nReps.Number = domplate(Reps.Rep,\n{\n    tag:\n        OBJECTBOX(\"$object\"),\n\n    className: \"number\",\n\n    supportsObject: function(object, type)\n    {\n        return type == \"boolean\" || type == \"number\";\n    }\n});\n\n// ********************************************************************************************* //\n\nReps.String = domplate(Reps.Rep,\n{\n    tag:\n        //OBJECTBOX(\"&quot;$object&quot;\"),\n        OBJECTBOX(\"$object\"),\n\n    className: \"string\",\n\n    supportsObject: function(object, type)\n    {\n        return type == \"string\";\n    }\n});\n\n// ********************************************************************************************* //\n\nReps.Arr = domplate(Reps.Rep,\n{\n    tag:\n        OBJECTBOX(\"$object|getTitle\"),\n\n    className: \"array\",\n\n    supportsObject: function(object, type)\n    {\n        return Lib.isArray(object);\n    },\n\n    getTitle: function(object)\n    {\n        return \"Array [\" + object.length + \"]\";\n    }\n});\n\n// ********************************************************************************************* //\n\nReps.Tree = domplate(Reps.Rep,\n{\n    tag:\n        OBJECTBOX(\n            TAG(\"$object|getTag\", {object: \"$object|getRoot\"})\n        ),\n\n    className: \"tree\",\n\n    getTag: function(object)\n    {\n        return Tree.tag;\n    },\n\n    getRoot: function(object)\n    {\n        // Create fake root for embedded object-tree.\n        return [object];\n    },\n\n    supportsObject: function(object, type)\n    {\n        return type == \"object\";\n    }\n});\n\n// ********************************************************************************************* //\n\nReps.Caption = domplate(Reps.Rep,\n{\n    tag:\n        SPAN({\"class\": \"caption\"}, \"$object\")\n});\n\n// ********************************************************************************************* //\n\nReps.Obj = domplate(Reps.Rep,\n{\n    tag:\n        OBJECTLINK(\n            //SPAN({\"class\": \"objectTitle\"}, \"$object|getTitle \"),\n            SPAN({\"class\": \"objectLeftBrace\", role: \"presentation\"}, \"{\"),\n            FOR(\"prop\", \"$object|shortPropIterator\",\n                \"$prop.name\",\n                SPAN({\"class\": \"objectEqual\", role: \"presentation\"}, \"$prop.equal\"),\n                TAG(\"$prop.tag\", {object: \"$prop.object\"}),\n                SPAN({\"class\": \"objectComma\", role: \"presentation\"}, \"$prop.delim\")\n            ),\n            SPAN({\"class\": \"objectRightBrace\"}, \"}\")\n        ),\n\n    shortTag:\n        OBJECTLINK(\n            //SPAN({\"class\": \"objectTitle\"}, \"$object|getTitle \"),\n            SPAN({\"class\": \"objectLeftBrace\", role: \"presentation\"}, \"{\"),\n            FOR(\"prop\", \"$object|shortPropIterator\",\n                \"$prop.name\",\n                SPAN({\"class\": \"objectEqual\", role: \"presentation\"}, \"$prop.equal\"),\n                TAG(\"$prop.tag\", {object: \"$prop.object\"}),\n                SPAN({\"class\": \"objectComma\", role: \"presentation\"}, \"$prop.delim\")\n            ),\n            SPAN({\"class\": \"objectRightBrace\"}, \"}\")\n        ),\n\n    titleTag:\n        SPAN({\"class\": \"objectTitle\"}, \"$object|getTitleTag\"),\n\n    getTitleTag: function(object)\n    {\n        var title;\n        if (typeof(object) == \"string\")\n            title = object;\n        else\n            title = this.getTitle(object);\n\n        if (title == \"Object\")\n            title = \"{...}\";\n\n        return title;\n    },\n\n    longPropIterator: function (object)\n    {\n        return this.propIterator(object, 100);\n    },\n\n    shortPropIterator: function (object)\n    {\n        return this.propIterator(object, 3);\n    },\n\n    propIterator: function (object, max)\n    {\n        var props = [];\n\n        // Object members with non-empty values are preferred since it gives the\n        // user a better overview of the object.\n        this.getProps(props, object, max, function(t, value)\n        {\n            return (t == \"boolean\" || t == \"number\" || (t == \"string\" && value) ||\n                (t == \"object\" && value && value.toString));\n        });\n\n        if (props.length+1 <= max)\n        {\n            // There is not enough props yet, let's display also empty members and functions.\n            this.getProps(props, object, max, function(t, value)\n            {\n                return ((t == \"string\" && !value) || (t == \"object\" && !value) ||\n                    (t == \"function\"));\n            });\n        }\n\n        if (props.length > max)\n        {\n            props[props.length-1] = {\n                object: \"more...\",\n                tag: Reps.Caption.tag,\n                name: \"\",\n                equal: \"\",\n                delim: \"\"\n            };\n        }\n        else if (props.length > 0)\n        {\n            props[props.length-1].delim = '';\n        }\n\n        return props;\n    },\n\n    getProps: function (props, object, max, filter)\n    {\n        max = max || 3;\n        if (!object)\n            return [];\n\n        var len = 0;\n\n        try\n        {\n            for (var name in object)\n            {\n                var value;\n                try\n                {\n                    value = object[name];\n                }\n                catch (exc)\n                {\n                    continue;\n                }\n\n                var t = typeof(value);\n                if (filter(t, value))\n                {\n                    var rep = Reps.getRep(value);\n                    var tag = rep.shortTag || rep.tag;\n                    if ((t == \"object\" || t == \"function\") && value)\n                    {\n                        value = rep.getTitle(value);\n                        if (rep.titleTag)\n                            tag = rep.titleTag;\n                        else\n                            tag = Reps.Obj.titleTag;\n                    }\n\n                    if (props.length <= max)\n                        props.push({tag: tag, name: name, object: value, equal: \"=\", delim: \", \"});\n                    else\n                        break;\n                }\n            }\n        }\n        catch (exc)\n        {\n            // Sometimes we get exceptions when trying to read from certain objects, like\n            // StorageList, but don't let that gum up the works\n            // XXXjjb also History.previous fails because object is a web-page object\n            // which does not have permission to read the history\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n    className: \"object\",\n\n    supportsObject: function(object, type)\n    {\n        return true;\n    }\n});\n\n// ********************************************************************************************* //\n// Helpers\n\nfunction safeToString(ob)\n{\n    try\n    {\n        return ob.toString();\n    }\n    catch (exc)\n    {\n        return \"\";\n    }\n}\n\n// ********************************************************************************************* //\n\n// Registration\nReps.registerRep(\n    Reps.Undefined,\n    Reps.Null,\n    Reps.Number,\n    Reps.String,\n    Reps.Arr\n    //Reps.Obj\n)\n\n// ********************************************************************************************* //\n\nreturn Reps;\n\n// ********************************************************************************************* //\n}});\n"
          },
          "redirectURL": "",
          "headersSize": 358,
          "bodySize": 9878
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "connect": 42,
          "send": 0,
          "wait": 97,
          "receive": 8
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:18.591+01:00",
        "time": 137,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/scripts/jsdiff.js",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 291,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:49 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:38 GMT"
            },
            {
              "name": "Etag",
              "value": "\"12eb9d1-134f-4d7330a013d80\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "4943"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=30"
            },
            {
              "name": "Expires",
              "value": "Wed, 06 Mar 2013 07:12:19 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=50"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "application/javascript"
            }
          ],
          "content": {
            "mimeType": "application/javascript",
            "size": 4943,
            "text": "define([\r\n],\r\nfunction() {\r\n\r\n// ********************************************************************************************* //\r\n\r\n/*\r\n * Javascript Diff Algorithm\r\n *  By John Resig (http://ejohn.org/)\r\n *  Modified by Chu Alan \"sprite\"\r\n *\r\n * Released under the MIT license.\r\n *\r\n * More Info:\r\n *  http://ejohn.org/projects/javascript-diff-algorithm/\r\n */\r\n\r\nfunction escapeText(s) {\r\n    return s;\r\n\r\n/*    var n = s;\r\n    n = n.replace(/&/g, \"&amp;\");\r\n    n = n.replace(/</g, \"&lt;\");\r\n    n = n.replace(/>/g, \"&gt;\");\r\n    n = n.replace(/\"/g, \"&quot;\");\r\n\r\n    return n;*/\r\n}\r\n\r\nfunction diffString( o, n ) {\r\n  o = o.replace(/\\s+$/, '');\r\n  n = n.replace(/\\s+$/, '');\r\n\r\n  var out = diff(o == \"\" ? [] : o.split(/\\s+/), n == \"\" ? [] : n.split(/\\s+/) );\r\n  var str = \"\";\r\n\r\n  var oSpace = o.match(/\\s+/g);\r\n  if (oSpace == null) {\r\n    oSpace = [\"\\n\"];\r\n  } else {\r\n    oSpace.push(\"\\n\");\r\n  }\r\n  var nSpace = n.match(/\\s+/g);\r\n  if (nSpace == null) {\r\n    nSpace = [\"\\n\"];\r\n  } else {\r\n    nSpace.push(\"\\n\");\r\n  }\r\n\r\n  if (out.n.length == 0) {\r\n      for (var i = 0; i < out.o.length; i++) {\r\n        str += '<del>' + escapeText(out.o[i]) + oSpace[i] + \"</del>\";\r\n      }\r\n  } else {\r\n    if (out.n[0].text == null) {\r\n      for (n = 0; n < out.o.length && out.o[n].text == null; n++) {\r\n        str += '<del>' + escapeText(out.o[n]) + oSpace[n] + \"</del>\";\r\n      }\r\n    }\r\n\r\n    for ( var i = 0; i < out.n.length; i++ ) {\r\n      if (out.n[i].text == null) {\r\n        str += '<ins>' + escapeText(out.n[i]) + nSpace[i] + \"</ins>\";\r\n      } else {\r\n        var pre = \"\";\r\n\r\n        for (n = out.n[i].row + 1; n < out.o.length && out.o[n].text == null; n++ ) {\r\n          pre += '<del>' + escapeText(out.o[n]) + oSpace[n] + \"</del>\";\r\n        }\r\n        str += \" \" + out.n[i].text + nSpace[i] + pre;\r\n      }\r\n    }\r\n  }\r\n  \r\n  return str;\r\n}\r\n\r\nfunction randomColor() {\r\n    return \"rgb(\" + (Math.random() * 100) + \"%, \" + \r\n                    (Math.random() * 100) + \"%, \" + \r\n                    (Math.random() * 100) + \"%)\";\r\n}\r\nfunction diffString2( o, n ) {\r\n  o = o.replace(/\\s+$/, '');\r\n  n = n.replace(/\\s+$/, '');\r\n\r\n  var out = diff(o == \"\" ? [] : o.split(/\\s+/), n == \"\" ? [] : n.split(/\\s+/) );\r\n\r\n  var oSpace = o.match(/\\s+/g);\r\n  if (oSpace == null) {\r\n    oSpace = [\"\\n\"];\r\n  } else {\r\n    oSpace.push(\"\\n\");\r\n  }\r\n  var nSpace = n.match(/\\s+/g);\r\n  if (nSpace == null) {\r\n    nSpace = [\"\\n\"];\r\n  } else {\r\n    nSpace.push(\"\\n\");\r\n  }\r\n\r\n  var os = \"\";\r\n  var colors = new Array();\r\n  for (var i = 0; i < out.o.length; i++) {\r\n      colors[i] = randomColor();\r\n\r\n      if (out.o[i].text != null) {\r\n          os += '<span style=\"background-color: ' +colors[i]+ '\">' + \r\n                escapeText(out.o[i].text) + oSpace[i] + \"</span>\";\r\n      } else {\r\n          os += \"<del>\" + escapeText(out.o[i]) + oSpace[i] + \"</del>\";\r\n      }\r\n  }\r\n\r\n  var ns = \"\";\r\n  for (var i = 0; i < out.n.length; i++) {\r\n      if (out.n[i].text != null) {\r\n          ns += '<span style=\"background-color: ' +colors[out.n[i].row]+ '\">' + \r\n                escapeText(out.n[i].text) + nSpace[i] + \"</span>\";\r\n      } else {\r\n          ns += \"<ins>\" + escapeText(out.n[i]) + nSpace[i] + \"</ins>\";\r\n      }\r\n  }\r\n\r\n  return { o : os , n : ns };\r\n}\r\n\r\nfunction diff( o, n ) {\r\n  var ns = new Object();\r\n  var os = new Object();\r\n  \r\n  for ( var i = 0; i < n.length; i++ ) {\r\n    if ( ns[ n[i] ] == null )\r\n      ns[ n[i] ] = { rows: new Array(), o: null };\r\n    ns[ n[i] ].rows.push( i );\r\n  }\r\n  \r\n  for ( var i = 0; i < o.length; i++ ) {\r\n    if ( os[ o[i] ] == null )\r\n      os[ o[i] ] = { rows: new Array(), n: null };\r\n    os[ o[i] ].rows.push( i );\r\n  }\r\n  \r\n  for ( var i in ns ) {\r\n    if ( ns[i].rows.length == 1 && typeof(os[i]) != \"undefined\" && os[i].rows.length == 1 ) {\r\n      n[ ns[i].rows[0] ] = { text: n[ ns[i].rows[0] ], row: os[i].rows[0] };\r\n      o[ os[i].rows[0] ] = { text: o[ os[i].rows[0] ], row: ns[i].rows[0] };\r\n    }\r\n  }\r\n  \r\n  for ( var i = 0; i < n.length - 1; i++ ) {\r\n    if ( n[i].text != null && n[i+1].text == null && n[i].row + 1 < o.length && o[ n[i].row + 1 ].text == null && \r\n         n[i+1] == o[ n[i].row + 1 ] ) {\r\n      n[i+1] = { text: n[i+1], row: n[i].row + 1 };\r\n      o[n[i].row+1] = { text: o[n[i].row+1], row: i + 1 };\r\n    }\r\n  }\r\n  \r\n  for ( var i = n.length - 1; i > 0; i-- ) {\r\n    if ( n[i].text != null && n[i-1].text == null && n[i].row > 0 && o[ n[i].row - 1 ].text == null && \r\n         n[i-1] == o[ n[i].row - 1 ] ) {\r\n      n[i-1] = { text: n[i-1], row: n[i].row - 1 };\r\n      o[n[i].row-1] = { text: o[n[i].row-1], row: i - 1 };\r\n    }\r\n  }\r\n  \r\n  return { o: o, n: n };\r\n}\r\n\r\n// ********************************************************************************************* //\r\n// Registration\r\n\r\nreturn {\r\n    diffString: diffString,\r\n    escapeText: escapeText\r\n}\r\n\r\n// ********************************************************************************************* //\r\n});\r\n"
          },
          "redirectURL": "",
          "headersSize": 358,
          "bodySize": 4943
        },
        "cache": {},
        "timings": {
          "blocked": 50,
          "dns": 0,
          "connect": 0,
          "send": 0,
          "wait": 83,
          "receive": 4
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:18.755+01:00",
        "time": 33,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/scripts/diffObj.js",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 292,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:49 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:35 GMT"
            },
            {
              "name": "Etag",
              "value": "\"12eb9c3-d67-4d73309d376c0\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "3431"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=30"
            },
            {
              "name": "Expires",
              "value": "Wed, 06 Mar 2013 07:12:19 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=38"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "application/javascript"
            }
          ],
          "content": {
            "mimeType": "application/javascript",
            "size": 3431,
            "text": "/* See license.txt for terms of usage */\n\ndefine([\n    \"domplate/domplate\",\n    \"domplate/reps\",\n    \"core/lib\",\n    \"core/trace\"\n],\n\nfunction(Domplate, Reps, Lib, Trace) { with (Domplate) {\n\n// ********************************************************************************************* //\n// Diff Object\n\nvar DiffObj = domplate(Reps.Rep,\n{\n    tag:\n        Reps.OBJECTLINK(\n            //SPAN({\"class\": \"objectTitle\"}, \"$object|getTitle \"),\n            SPAN({\"class\": \"objectLeftBrace\", role: \"presentation\"}, \"{\"),\n            FOR(\"prop\", \"$object|shortPropIterator\",\n                \"$prop.name\",\n                SPAN({\"class\": \"objectEqual\", role: \"presentation\"}, \"$prop.equal\"),\n                SPAN({\"class\": \"diffObj oldValue\"},\n                    TAG(\"$prop.tag1\", {object: \"$prop.object1\"})\n                ),\n                SPAN({\"class\": \"diffObj newValue\"},\n                    TAG(\"$prop.tag2\", {object: \"$prop.object2\"})\n                ),\n                SPAN({\"class\": \"objectComma\", role: \"presentation\"}, \"$prop.delim\")\n            ),\n            SPAN({\"class\": \"objectRightBrace\"}, \"}\")\n        ),\n\n    titleTag:\n        SPAN({\"class\": \"objectTitle\"}, \"$object|getTitleTag\"),\n\n    getTitleTag: function(object)\n    {\n        var title;\n        if (typeof(object) == \"string\")\n            title = object;\n        else\n            title = this.getTitle(object);\n\n        if (title == \"Object\")\n            title = \"{...}\";\n\n        return title;\n    },\n\n    shortPropIterator: function(object)\n    {\n        Trace.log(\"shortPropIterator\", object)\n        return this.propIterator(object, 3);\n    },\n\n    propIterator: function(children, max)\n    {\n        var props = this.getProps(children, max);\n\n        if (props.length > max)\n        {\n            props[props.length-1] = {\n                object: \"more...\",\n                tag: Reps.Caption.tag,\n                name: \"\",\n                equal: \"\",\n                delim: \"\"\n            };\n        }\n        else if (props.length > 0)\n        {\n            props[props.length-1].delim = \"\";\n        }\n\n        return props;\n    },\n\n    getProps: function(children, max)\n    {\n        max = max || 3;\n\n        var props = [];\n        for (var i=0; i<children.length; i++)\n        {\n            var child = children[i];\n            if (child.value1 != child.value2)\n            {\n                var rep1 = Reps.getRep(child.value1);\n                var tag1 = rep1.shortTag || rep1.tag;\n\n                var rep2 = Reps.getRep(child.value2);\n                var tag2 = rep2.shortTag || rep2.tag;\n\n                props.push({\n                    tag1: tag1,\n                    tag2: tag2,\n                    name: child.name,\n                    object1: child.value1,\n                    object2: child.value2,\n                    equal: \"=\",\n                    delim: \", \"\n                });\n\n                if (props.length >= max)\n                    break;\n            }\n        }\n\n        return props;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n    className: \"object\",\n\n    supportsObject: function(object, type)\n    {\n        return true;\n    }\n});\n\n// ********************************************************************************************* //\n\nreturn DiffObj;\n\n// ********************************************************************************************* //\n}});\n"
          },
          "redirectURL": "",
          "headersSize": 357,
          "bodySize": 3431
        },
        "cache": {},
        "timings": {
          "blocked": 1,
          "dns": 0,
          "connect": 0,
          "send": 1,
          "wait": 28,
          "receive": 3
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:18.949+01:00",
        "time": 41,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/css/images/warning.svg",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "image/png,image/*;q=0.8,*/*;q=0.5"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/css/main.css"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 338,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:50 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:35 GMT"
            },
            {
              "name": "Etag",
              "value": "\"12eb9c0-b75-4d73309d376c0\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "2933"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=30"
            },
            {
              "name": "Expires",
              "value": "Wed, 06 Mar 2013 07:12:20 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=37"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "image/svg+xml"
            }
          ],
          "content": {
            "mimeType": "image/svg+xml",
            "size": 2933,
            "text": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n\r\n<svg\r\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\r\n   xmlns:cc=\"http://creativecommons.org/ns#\"\r\n   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\r\n   xmlns:svg=\"http://www.w3.org/2000/svg\"\r\n   xmlns=\"http://www.w3.org/2000/svg\"\r\n   version=\"1.1\"\r\n   width=\"14\"\r\n   height=\"14\"\r\n   id=\"svg2\">\r\n  <defs\r\n     id=\"defs4\" />\r\n  <metadata\r\n     id=\"metadata7\">\r\n    <rdf:RDF>\r\n      <cc:Work\r\n         rdf:about=\"\">\r\n        <dc:format>image/svg+xml</dc:format>\r\n        <dc:type\r\n           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\r\n        <dc:title></dc:title>\r\n      </cc:Work>\r\n    </rdf:RDF>\r\n  </metadata>\r\n  <g\r\n     transform=\"translate(0,-1038.3622)\"\r\n     id=\"layer1\">\r\n    <path\r\n       d=\"m 9.5089285,6.0200891 a 2.4441965,2.4441965 0 1 1 -4.8883929,0 2.4441965,2.4441965 0 1 1 4.8883929,0 z\"\r\n       transform=\"matrix(2.7634691,0,0,2.7634692,-12.52317,1028.7259)\"\r\n       id=\"path2989\"\r\n       style=\"fill:#ffff00;fill-opacity:1;stroke:#a0a000;stroke-width:0.17770305;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none\" />\r\n    <g\r\n       transform=\"translate(-9.9989433e-8,-0.20315)\"\r\n       id=\"g3802\">\r\n      <path\r\n         d=\"m 5.3600206,1049.4025 c -2e-6,-0.3548 0.1419377,-0.6425 0.4258191,-0.8628 0.283877,-0.2202 0.6790061,-0.3305 1.1853888,-0.3305 0.4987032,0 0.9015047,0.1066 1.208406,0.3214 0.3068917,0.2142 0.4603399,0.5017 0.4603451,0.8628 -5.2e-6,0.3795 -0.1419448,0.6731 -0.4258193,0.8812 -0.283884,0.202 -0.6790131,0.303 -1.1853887,0.303 -0.5293999,0 -0.9398739,-0.098 -1.2314232,-0.2938 -0.291554,-0.1958 -0.4373298,-0.4896 -0.4373278,-0.8813 z\"\r\n         id=\"path3798\"\r\n         style=\"font-size:17.0612011px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;\" />\r\n      <path\r\n         d=\"m 7.7883411,1047.3892 -1.5766821,0 c -0.038365,-0.2202 -0.084399,-0.4725 -0.1381036,-0.7572 -0.046036,-0.2845 -0.092071,-0.552 -0.1381036,-0.8025 -0.1150881,-0.645 -0.2109938,-1.3565 -0.2877157,-2.1345 -0.069055,-0.7779 -0.1035804,-1.4248 -0.1035777,-1.9409 l 0,-0.2903 c -2e-6,-0.3377 0.088231,-0.573 0.2646985,-0.7059 0.1841355,-0.1366 0.5600837,-0.2048 1.1278455,-0.2048 0.6521515,0 1.0664618,0.068 1.2429319,0.2048 0.1841332,0.1329 0.2762021,0.3454 0.276207,0.6375 l 0,0.3587 c -4.9e-6,0.5161 -0.038366,1.1555 -0.1150867,1.9181 -0.069057,0.7628 -0.168798,1.4819 -0.2992244,2.1573 -0.038366,0.2201 -0.084401,0.4838 -0.1381036,0.7912 -0.046039,0.3074 -0.084401,0.5635 -0.1150868,0.7684 z\"\r\n         id=\"path3772\"\r\n         style=\"font-size:17.0612011px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;\" />\r\n    </g>\r\n  </g>\r\n</svg>\r\n"
          },
          "redirectURL": "",
          "headersSize": 348,
          "bodySize": 2933
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "connect": 0,
          "send": 0,
          "wait": 28,
          "receive": 13
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      },
      {
        "pageref": "page_30168",
        "startedDateTime": "2013-03-06T08:11:18.949+01:00",
        "time": 27,
        "request": {
          "method": "GET",
          "url": "http://janodvarko.cz/json/diff2/css/images/twisty-sprites.png",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Host",
              "value": "janodvarko.cz"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 6.0; rv:21.0) Gecko/20130219 Firefox/21.0"
            },
            {
              "name": "Accept",
              "value": "image/png,image/*;q=0.8,*/*;q=0.5"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Referer",
              "value": "http://janodvarko.cz/json/diff2/css/domTree.css"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            }
          ],
          "queryString": [],
          "headersSize": 348,
          "bodySize": -1
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [
            {
              "name": "Date",
              "value": "Wed, 06 Mar 2013 07:11:50 GMT"
            },
            {
              "name": "Server",
              "value": "Apache"
            },
            {
              "name": "Last-Modified",
              "value": "Tue, 05 Mar 2013 20:08:35 GMT"
            },
            {
              "name": "Etag",
              "value": "\"12eb9ac-116-4d73309d376c0\""
            },
            {
              "name": "Accept-Ranges",
              "value": "bytes"
            },
            {
              "name": "Content-Length",
              "value": "278"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=1209600"
            },
            {
              "name": "Expires",
              "value": "Wed, 20 Mar 2013 07:11:50 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5, max=46"
            },
            {
              "name": "Connection",
              "value": "Keep-Alive"
            },
            {
              "name": "Content-Type",
              "value": "image/png"
            }
          ],
          "content": {
            "mimeType": "image/png",
            "size": 96,
            "text": "Reload the page to get source for: http://janodvarko.cz/json/diff2/css/images/twisty-sprites.png"
          },
          "redirectURL": "",
          "headersSize": 348,
          "bodySize": 278
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "connect": 0,
          "send": 0,
          "wait": 27,
          "receive": 0
        },
        "serverIPAddress": "91.239.200.165",
        "connection": "80"
      }
    ]
  }
}